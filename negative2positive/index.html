<!DOCTYPE html>
<html lang="zh">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
  <title>Negative Converter</title>

  <!-- Google Fonts -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600&display=swap" rel="stylesheet">

  <style>
    :root {
      --bg-primary: #1a1a1a;
      --bg-secondary: #252525;
      --bg-tertiary: #2d2d2d;
      --bg-hover: #363636;
      --text-primary: #e0e0e0;
      --text-secondary: #888;
      --text-muted: #666;
      --accent: #4a9eff;
      --accent-hover: #6db3ff;
      --accent-dim: #3a7ecc;
      --danger: #ff6b6b;
      --success: #4caf50;
      --warning: #ffb74d;
      --border: #3a3a3a;
      --border-light: #444;
      --shadow: rgba(0, 0, 0, 0.3);
      --viewport-h: 100vh;
      --safe-top: env(safe-area-inset-top, 0px);
      --safe-right: env(safe-area-inset-right, 0px);
      --safe-bottom: env(safe-area-inset-bottom, 0px);
      --safe-left: env(safe-area-inset-left, 0px);
    }

    @supports (height: 100dvh) {
      :root {
        --viewport-h: 100dvh;
      }
    }

    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    html, body {
      height: 100%;
      overflow: hidden;
    }

    body {
      font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background: var(--bg-primary);
      color: var(--text-primary);
      display: flex;
      flex-direction: column;
      min-height: var(--viewport-h);
      -webkit-font-smoothing: antialiased;
    }

    @supports (-webkit-touch-callout: none) {
      html {
        height: -webkit-fill-available;
      }

      body {
        min-height: -webkit-fill-available;
      }
    }

    /* Header */
    .app-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 12px 20px;
      background: var(--bg-secondary);
      border-bottom: 1px solid var(--border);
    }

    .app-title {
      font-size: 18px;
      font-weight: 600;
      color: var(--text-primary);
    }

    .lang-selector {
      display: flex;
      gap: 4px;
    }

    .lang-btn {
      padding: 6px 12px;
      background: transparent;
      border: 1px solid var(--border);
      color: var(--text-secondary);
      cursor: pointer;
      font-size: 13px;
      transition: all 0.2s;
    }

    .lang-btn:hover {
      background: var(--bg-tertiary);
      color: var(--text-primary);
    }

    .lang-btn.active {
      background: var(--accent);
      border-color: var(--accent);
      color: white;
    }

    /* Main Layout */
    .app-main {
      display: grid;
      grid-template-columns: 1fr 320px;
      flex: 1;
      overflow: hidden;
      min-height: 0;
    }

    /* Preview Section */
    .preview-section {
      display: flex;
      flex-direction: column;
      background: var(--bg-primary);
      padding: 16px;
      overflow: hidden;
      height: 100%;
      max-height: calc(var(--viewport-h) - 120px); /* Account for header and footer */
      min-height: 0;
    }

    .canvas-container {
      flex: 1;
      display: flex;
      align-items: center;
      justify-content: center;
      background: #111;
      border-radius: 8px;
      position: relative;
      overflow: hidden;
      min-height: 400px;
    }

    #canvas {
      max-width: 100%;
      max-height: 100%;
      object-fit: contain;
    }

    #glCanvas {
      max-width: 100%;
      max-height: 100%;
      object-fit: contain;
    }

    .crop-overlay {
      border: 2px dashed var(--accent);
      position: absolute;
      pointer-events: none;
      display: none;
      background: rgba(74, 158, 255, 0.1);
      z-index: 100;
    }

    /* Sampling Loupe (Magnifier) */
    .loupe {
      position: absolute;
      pointer-events: none;
      display: none;
      z-index: 250;
      padding: 8px;
      border-radius: 10px;
      background: rgba(17, 17, 17, 0.95);
      border: 1px solid var(--border-light);
      box-shadow: 0 10px 30px rgba(0, 0, 0, 0.55);
      backdrop-filter: blur(6px);
    }

    #loupeCanvas {
      display: block;
      border-radius: 8px;
      border: 1px solid var(--border);
      image-rendering: pixelated;
    }

    .loupe-info {
      margin-top: 6px;
      font-size: 11px;
      color: var(--text-secondary);
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      white-space: nowrap;
      opacity: 0.95;
    }

    /* Upload Placeholder */
    .upload-placeholder {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      color: var(--text-secondary);
      gap: 16px;
    }

    .upload-placeholder svg {
      width: 64px;
      height: 64px;
      opacity: 0.5;
    }

    .upload-btn {
      padding: 12px 24px;
      background: var(--accent);
      border: none;
      border-radius: 6px;
      color: white;
      font-size: 14px;
      font-weight: 500;
      cursor: pointer;
      transition: background 0.2s;
    }

    .upload-btn:hover {
      background: var(--accent-hover);
    }

    #fileInput {
      display: none;
    }

    /* Preview Toolbar */
    .preview-toolbar {
      display: flex;
      gap: 8px;
      padding: 12px 0;
      flex-wrap: wrap;
      align-items: center;
    }

    .toolbar-btn {
      padding: 8px 16px;
      background: var(--bg-secondary);
      border: 1px solid var(--border);
      border-radius: 4px;
      color: var(--text-primary);
      font-size: 13px;
      cursor: pointer;
      transition: all 0.2s;
      display: flex;
      align-items: center;
      gap: 6px;
    }

    .toolbar-btn:hover {
      background: var(--bg-tertiary);
      border-color: var(--border-light);
    }

    .toolbar-btn.active {
      background: var(--accent);
      border-color: var(--accent);
      color: white;
    }

    .toolbar-btn.primary {
      background: var(--accent);
      border-color: var(--accent);
      color: white;
    }

    .toolbar-btn.primary:hover {
      background: var(--accent-hover);
    }

    .toolbar-btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    .toolbar-btn svg {
      width: 16px;
      height: 16px;
    }

    .toolbar-separator {
      width: 1px;
      height: 24px;
      background: var(--border);
      margin: 0 4px;
    }

    /* Status Badge */
    .status-badge {
      padding: 4px 10px;
      border-radius: 12px;
      font-size: 11px;
      font-weight: 500;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    .status-badge.step1 {
      background: rgba(255, 183, 77, 0.2);
      color: var(--warning);
    }

    .status-badge.step2 {
      background: rgba(74, 158, 255, 0.2);
      color: var(--accent);
    }

    .status-badge.step3 {
      background: rgba(76, 175, 80, 0.2);
      color: var(--success);
    }

    /* Histogram */
    .histogram-container {
      background: var(--bg-secondary);
      border-radius: 6px;
      padding: 8px;
      margin-top: 8px;
    }

    .histogram-label {
      font-size: 11px;
      color: var(--text-secondary);
      margin-bottom: 4px;
    }

    #histogramCanvas {
      width: 100%;
      height: 60px;
      background: #111;
      border-radius: 4px;
    }

    /* Controls Panel */
    .controls-panel {
      background: var(--bg-secondary);
      border-left: 1px solid var(--border);
      overflow-y: auto;
      overflow-x: hidden;
      display: flex;
      flex-direction: column;
      height: 100%;
      max-height: calc(var(--viewport-h) - 120px); /* Account for header and footer */
      min-height: 0;
    }

    .control-section {
      border-bottom: 1px solid var(--border);
      padding: 16px;
    }

    .section-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 12px;
      cursor: pointer;
    }

    .section-title {
      font-size: 13px;
      font-weight: 600;
      color: var(--text-primary);
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    .section-toggle {
      color: var(--text-secondary);
      transition: transform 0.2s;
    }

    .section-toggle.collapsed {
      transform: rotate(-90deg);
    }

    .section-content {
      display: flex;
      flex-direction: column;
      gap: 12px;
    }

    .section-content.collapsed {
      display: none;
    }

    /* Workflow Steps */
    .workflow-steps {
      display: flex;
      flex-direction: column;
      gap: 8px;
      padding: 12px;
      background: var(--bg-tertiary);
      border-radius: 6px;
      margin-bottom: 12px;
    }

    .workflow-step {
      display: flex;
      align-items: center;
      gap: 10px;
      padding: 8px;
      border-radius: 4px;
      font-size: 12px;
      color: var(--text-secondary);
    }

    .workflow-step.active {
      background: rgba(74, 158, 255, 0.1);
      color: var(--accent);
    }

    .workflow-step.completed {
      color: var(--success);
    }

    .step-number {
      width: 20px;
      height: 20px;
      border-radius: 50%;
      background: var(--bg-secondary);
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 11px;
      font-weight: 600;
    }

    .workflow-step.active .step-number {
      background: var(--accent);
      color: white;
    }

    .workflow-step.completed .step-number {
      background: var(--success);
      color: white;
    }

    /* Film Type Toggle */
    .film-type-toggle {
      display: flex;
      background: var(--bg-tertiary);
      border-radius: 6px;
      padding: 3px;
    }

    .film-type-btn {
      flex: 1;
      padding: 8px;
      background: transparent;
      border: none;
      color: var(--text-secondary);
      font-size: 13px;
      cursor: pointer;
      border-radius: 4px;
      transition: all 0.2s;
    }

    .film-type-btn.active {
      background: var(--accent);
      color: white;
    }

    /* Preset Selector */
    .preset-select {
      width: 100%;
      padding: 8px 12px;
      background: var(--bg-tertiary);
      border: 1px solid var(--border);
      border-radius: 4px;
      color: var(--text-primary);
      font-size: 13px;
      cursor: pointer;
    }

    .preset-select:focus {
      outline: none;
      border-color: var(--accent);
    }

    /* Film Base Buttons */
    .film-base-buttons {
      display: flex;
      gap: 8px;
    }

    .film-base-btn {
      flex: 1;
      padding: 8px;
      background: var(--bg-tertiary);
      border: 1px solid var(--border);
      border-radius: 4px;
      color: var(--text-primary);
      font-size: 12px;
      cursor: pointer;
      transition: all 0.2s;
    }

    .film-base-btn:hover {
      background: var(--bg-hover);
      border-color: var(--border-light);
    }

    .film-base-btn.active {
      background: var(--accent);
      border-color: var(--accent);
      color: white;
    }

    /* Film Base Preview */
    .film-base-preview {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 8px;
      background: var(--bg-tertiary);
      border-radius: 4px;
    }

    .film-base-color {
      width: 32px;
      height: 32px;
      border-radius: 4px;
      border: 1px solid var(--border);
    }

    .film-base-values {
      font-size: 11px;
      color: var(--text-secondary);
      font-family: monospace;
    }

    /* Slider Control */
    .slider-control {
      display: flex;
      flex-direction: column;
      gap: 4px;
    }

    .slider-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .slider-label {
      font-size: 12px;
      color: var(--text-secondary);
    }

    .slider-value-group {
      display: flex;
      align-items: center;
      gap: 6px;
    }

    .slider-number-input {
      width: 72px;
      padding: 4px 6px;
      background: var(--bg-tertiary);
      border: 1px solid var(--border);
      border-radius: 4px;
      color: var(--text-primary);
      font-size: 12px;
      font-family: monospace;
      text-align: right;
    }

    .slider-number-input:focus {
      outline: none;
      border-color: var(--accent);
    }

    .slider-unit {
      font-size: 11px;
      color: var(--text-secondary);
      min-width: 16px;
    }

    .slider-input {
      -webkit-appearance: none;
      appearance: none;
      width: 100%;
      height: 4px;
      background: var(--bg-tertiary);
      border-radius: 2px;
      cursor: pointer;
    }

    .slider-input::-webkit-slider-thumb {
      -webkit-appearance: none;
      width: 14px;
      height: 14px;
      background: var(--accent);
      border-radius: 50%;
      cursor: pointer;
      transition: transform 0.1s;
    }

    .slider-input::-webkit-slider-thumb:hover {
      transform: scale(1.2);
    }

    .slider-input::-moz-range-thumb {
      width: 14px;
      height: 14px;
      background: var(--accent);
      border: none;
      border-radius: 50%;
      cursor: pointer;
    }

    /* Curve Editor */
    .curve-editor {
      background: var(--bg-tertiary);
      border-radius: 4px;
      padding: 8px;
    }

    .curve-hint {
      font-size: 11px;
      color: var(--text-secondary);
      margin: 0 0 8px 0;
    }

    .curve-tabs {
      display: flex;
      gap: 4px;
      margin-bottom: 8px;
    }

    .curve-tab.reset {
      color: var(--text-secondary);
      margin-left: auto;
    }

    .curve-tab.reset:hover {
      color: var(--accent);
      border-color: var(--accent);
    }

    .curve-tab {
      flex: 1;
      padding: 4px 8px;
      background: transparent;
      border: 1px solid var(--border);
      border-radius: 3px;
      font-size: 11px;
      cursor: pointer;
      transition: all 0.2s;
    }

    .curve-tab.r { color: #ff6b6b; }
    .curve-tab.g { color: #69db7c; }
    .curve-tab.b { color: #74c0fc; }

    .curve-tab.active {
      background: var(--bg-hover);
      border-color: var(--border-light);
    }

    .curve-canvas {
      width: 100%;
      height: 120px;
      background: #111;
      border-radius: 4px;
      border: 1px solid var(--border);
      cursor: crosshair;
      touch-action: none;
      transition: border-color 0.2s;
    }

    .curve-canvas:hover {
      border-color: var(--accent);
    }

    .curve-presets {
      display: flex;
      gap: 4px;
      margin-top: 8px;
    }

    .curve-preset-btn {
      flex: 1;
      padding: 4px;
      background: var(--bg-secondary);
      border: 1px solid var(--border);
      border-radius: 3px;
      color: var(--text-secondary);
      font-size: 10px;
      cursor: pointer;
    }

    .curve-preset-btn:hover {
      background: var(--bg-hover);
      color: var(--text-primary);
    }

    /* Footer */
    .app-footer {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 12px 20px;
      background: var(--bg-secondary);
      border-top: 1px solid var(--border);
    }

    .footer-left {
      display: flex;
      gap: 8px;
    }

    .footer-right {
      display: flex;
      gap: 8px;
    }

    .footer-btn {
      padding: 8px 16px;
      background: var(--bg-tertiary);
      border: 1px solid var(--border);
      border-radius: 4px;
      color: var(--text-primary);
      font-size: 13px;
      cursor: pointer;
      transition: all 0.2s;
    }

    .footer-btn:hover {
      background: var(--bg-hover);
    }

    .footer-btn.primary {
      background: var(--accent);
      border-color: var(--accent);
      color: white;
    }

    .footer-btn.primary:hover {
      background: var(--accent-hover);
    }

    .footer-btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    /* Rotate Controls */
    .rotate-controls {
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .rotate-input {
      width: 60px;
      padding: 6px 8px;
      background: var(--bg-tertiary);
      border: 1px solid var(--border);
      border-radius: 4px;
      color: var(--text-primary);
      font-size: 13px;
      text-align: center;
    }

    .rotate-input:focus {
      outline: none;
      border-color: var(--accent);
    }

    /* Info Box */
    .info-box {
      padding: 10px 12px;
      background: rgba(74, 158, 255, 0.1);
      border: 1px solid rgba(74, 158, 255, 0.3);
      border-radius: 4px;
      font-size: 12px;
      color: var(--accent);
      margin-bottom: 12px;
    }

    .workflow-guide-note {
      margin-top: 8px;
      margin-bottom: 0;
      line-height: 1.5;
      white-space: pre-line;
    }

    /* File List Panel (Batch Mode) */
    .file-list-section {
      max-height: 200px;
      overflow-y: auto;
      border-bottom: 1px solid var(--border);
    }

    .file-list-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 8px 16px;
      background: var(--bg-tertiary);
      border-bottom: 1px solid var(--border);
      position: sticky;
      top: 0;
      z-index: 10;
    }

    .file-list-title {
      font-size: 12px;
      font-weight: 600;
      color: var(--text-primary);
    }

    .file-list-count {
      font-size: 11px;
      color: var(--text-secondary);
    }

    .file-list-items {
      padding: 4px 0;
    }

    .file-list-item {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 6px 12px;
      font-size: 12px;
      cursor: pointer;
      transition: background 0.15s;
    }

    .file-list-item:hover {
      background: var(--bg-tertiary);
    }

    .file-list-item.active {
      background: rgba(74, 158, 255, 0.15);
    }

    .file-list-checkbox {
      width: 14px;
      height: 14px;
      cursor: pointer;
      accent-color: var(--accent);
    }

    .file-list-name {
      flex: 1;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
      color: var(--text-primary);
    }

    .file-list-status {
      font-size: 10px;
      padding: 2px 6px;
      border-radius: 8px;
      white-space: nowrap;
    }

    .file-list-status.pending {
      background: rgba(136, 136, 136, 0.2);
      color: var(--text-secondary);
    }

    .file-list-status.processing {
      background: rgba(74, 158, 255, 0.2);
      color: var(--accent);
    }

    .file-list-status.done {
      background: rgba(76, 175, 80, 0.2);
      color: var(--success);
    }

    .file-list-status.error {
      background: rgba(255, 107, 107, 0.2);
      color: var(--danger);
    }

    .file-list-actions {
      display: flex;
      gap: 4px;
      padding: 8px 16px;
      border-top: 1px solid var(--border);
    }

    .file-list-btn {
      flex: 1;
      padding: 6px 8px;
      background: var(--bg-tertiary);
      border: 1px solid var(--border);
      border-radius: 4px;
      color: var(--text-primary);
      font-size: 11px;
      cursor: pointer;
      transition: all 0.2s;
    }

    .file-list-btn:hover {
      background: var(--bg-hover);
    }

    .file-list-item.has-settings {
      border-left: 3px solid var(--success);
    }

    .file-list-settings-badge {
      font-size: 9px;
      padding: 1px 4px;
      background: var(--success);
      color: white;
      border-radius: 3px;
      margin-left: 4px;
    }

    /* Batch Progress Modal */
    .batch-progress-overlay {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.7);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 1000;
    }

    .batch-progress-modal {
      background: var(--bg-secondary);
      border-radius: 8px;
      padding: 24px;
      min-width: 320px;
      max-width: 400px;
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
    }

    .batch-progress-title {
      font-size: 16px;
      font-weight: 600;
      margin-bottom: 16px;
      color: var(--text-primary);
    }

    .batch-progress-bar {
      height: 8px;
      background: var(--bg-tertiary);
      border-radius: 4px;
      overflow: hidden;
      margin-bottom: 12px;
    }

    .batch-progress-fill {
      height: 100%;
      background: var(--accent);
      transition: width 0.3s ease;
    }

    .batch-progress-text {
      font-size: 13px;
      color: var(--text-secondary);
      text-align: center;
    }

    .batch-progress-current {
      font-size: 12px;
      color: var(--text-muted);
      margin-top: 8px;
      text-align: center;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }

    /* Export Dropdown */
    .export-dropdown {
      position: relative;
      display: inline-block;
    }

    .export-dropdown-menu {
      position: absolute;
      bottom: 100%;
      right: 0;
      background: var(--bg-secondary);
      border: 1px solid var(--border);
      border-radius: 4px;
      min-width: 180px;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
      display: none;
      margin-bottom: 4px;
      z-index: 100;
    }

    .export-dropdown-menu.show {
      display: block;
    }

    .export-dropdown-item {
      display: block;
      width: 100%;
      padding: 10px 12px;
      background: none;
      border: none;
      color: var(--text-primary);
      font-size: 13px;
      text-align: left;
      cursor: pointer;
      transition: background 0.15s;
    }

    .export-dropdown-item:hover {
      background: var(--bg-tertiary);
    }

    .export-dropdown-item:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    .export-dropdown-divider {
      height: 1px;
      background: var(--border);
      margin: 4px 0;
    }

    .export-format-section {
      padding: 10px 12px;
      border-bottom: 1px solid var(--border);
    }

    .export-format-label {
      font-size: 11px;
      color: var(--text-secondary);
      margin-bottom: 6px;
      text-transform: uppercase;
    }

    .export-format-toggle {
      display: flex;
      gap: 4px;
    }

    .export-format-toggle .format-btn {
      flex: 1;
      padding: 6px 12px;
      background: var(--bg-tertiary);
      border: 1px solid var(--border);
      color: var(--text-secondary);
      font-size: 12px;
      cursor: pointer;
      transition: all 0.15s;
    }

    .export-format-toggle .format-btn:first-child {
      border-radius: 4px 0 0 4px;
    }

    .export-format-toggle .format-btn:last-child {
      border-radius: 0 4px 4px 0;
    }

    .export-format-toggle .format-btn.active {
      background: var(--accent);
      border-color: var(--accent);
      color: white;
    }

    .export-quality-section {
      padding: 10px 12px;
      border-bottom: 1px solid var(--border);
      display: none;
    }

    .export-quality-section.show {
      display: block;
    }

    .export-quality-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 6px;
    }

    .export-quality-label {
      font-size: 11px;
      color: var(--text-secondary);
      text-transform: uppercase;
    }

    .export-quality-value {
      font-size: 12px;
      color: var(--text-primary);
    }

    .export-quality-slider {
      width: 100%;
      height: 4px;
      -webkit-appearance: none;
      appearance: none;
      background: var(--bg-tertiary);
      border-radius: 2px;
      outline: none;
    }

    .export-quality-slider::-webkit-slider-thumb {
      -webkit-appearance: none;
      appearance: none;
      width: 14px;
      height: 14px;
      background: var(--accent);
      border-radius: 50%;
      cursor: pointer;
    }

    .export-quality-slider::-moz-range-thumb {
      width: 14px;
      height: 14px;
      background: var(--accent);
      border-radius: 50%;
      cursor: pointer;
      border: none;
    }

    /* Responsive */
    @media (max-width: 900px) {
      body {
        font-family: -apple-system, BlinkMacSystemFont, "SF Pro Text", "SF Pro Display", "Inter", "Segoe UI", Roboto, sans-serif;
        background: linear-gradient(180deg, #1d1d1f 0%, #141416 100%);
      }

      button,
      input,
      select {
        -webkit-tap-highlight-color: transparent;
        touch-action: manipulation;
      }

      .app-header {
        position: sticky;
        top: 0;
        z-index: 60;
        padding: calc(10px + var(--safe-top)) calc(12px + var(--safe-right)) 10px calc(12px + var(--safe-left));
        background: rgba(37, 37, 37, 0.86);
        backdrop-filter: blur(18px) saturate(150%);
        border-bottom: 1px solid rgba(255, 255, 255, 0.08);
      }

      .app-title {
        font-size: 17px;
        letter-spacing: -0.02em;
      }

      .lang-selector {
        background: rgba(255, 255, 255, 0.04);
        border: 1px solid rgba(255, 255, 255, 0.08);
        border-radius: 12px;
        padding: 2px;
      }

      .lang-btn {
        min-height: 32px;
        min-width: 48px;
        padding: 6px 10px;
        border: none;
        border-radius: 9px;
      }

      .app-main {
        grid-template-columns: 1fr;
        grid-template-rows: minmax(220px, 1.08fr) minmax(0, 1fr);
        gap: 10px;
        padding: 10px calc(10px + var(--safe-right)) 10px calc(10px + var(--safe-left));
      }

      .preview-section {
        padding: 0;
        max-height: none;
        border: 1px solid rgba(255, 255, 255, 0.08);
        border-radius: 16px;
        background: rgba(29, 29, 31, 0.76);
      }

      .canvas-container {
        margin: 10px;
        border-radius: 14px;
        min-height: 220px;
      }

      .preview-toolbar {
        padding: 8px 10px 10px;
        gap: 8px;
        flex-wrap: nowrap;
        overflow-x: auto;
        overflow-y: hidden;
        overscroll-behavior-x: contain;
        -webkit-overflow-scrolling: touch;
        scrollbar-width: none;
      }

      .preview-toolbar::-webkit-scrollbar {
        display: none;
      }

      .status-badge,
      .toolbar-btn,
      .rotate-controls {
        flex-shrink: 0;
      }

      .status-badge {
        white-space: nowrap;
      }

      .toolbar-separator {
        display: none;
      }

      .toolbar-btn {
        min-height: 44px;
        padding: 10px 14px;
        border-radius: 12px;
        font-size: 14px;
        white-space: nowrap;
      }

      .rotate-controls {
        gap: 6px;
        padding: 4px 8px;
        border-radius: 12px;
        border: 1px solid rgba(255, 255, 255, 0.08);
        background: rgba(255, 255, 255, 0.03);
      }

      .rotate-input {
        width: 70px;
        height: 34px;
        font-size: 16px;
      }

      .histogram-container {
        margin: 0 10px 10px;
        border-radius: 12px;
      }

      .controls-panel {
        border: 1px solid rgba(255, 255, 255, 0.08);
        border-radius: 16px;
        max-height: none;
        background: rgba(29, 29, 31, 0.72);
        backdrop-filter: blur(14px) saturate(140%);
        overscroll-behavior: contain;
        -webkit-overflow-scrolling: touch;
      }

      .control-section {
        padding: 14px;
      }

      .section-title {
        font-size: 12px;
      }

      .film-type-btn,
      .film-base-btn,
      .file-list-btn,
      .curve-tab,
      .curve-preset-btn,
      .footer-btn {
        min-height: 40px;
      }

      .preset-select,
      .rotate-input,
      .slider-number-input,
      .file-list-btn,
      .footer-btn {
        font-size: 16px;
      }

      .preset-select {
        min-height: 44px;
      }

      .slider-input {
        height: 6px;
      }

      .slider-input::-webkit-slider-thumb {
        width: 18px;
        height: 18px;
      }

      .slider-input::-moz-range-thumb {
        width: 18px;
        height: 18px;
      }

      .slider-number-input {
        width: 84px;
        min-height: 36px;
      }

      .file-list-section {
        max-height: 34vh;
        -webkit-overflow-scrolling: touch;
      }

      .app-footer {
        position: sticky;
        bottom: 0;
        z-index: 60;
        flex-direction: column;
        align-items: stretch;
        gap: 8px;
        padding: 10px calc(10px + var(--safe-right)) calc(10px + var(--safe-bottom)) calc(10px + var(--safe-left));
        background: rgba(37, 37, 37, 0.9);
        backdrop-filter: blur(20px) saturate(160%);
        border-top: 1px solid rgba(255, 255, 255, 0.08);
      }

      .footer-left {
        width: 100%;
        display: grid;
        grid-template-columns: repeat(3, minmax(0, 1fr));
      }

      .footer-right {
        width: 100%;
        display: grid;
        grid-template-columns: repeat(2, minmax(0, 1fr));
      }

      .footer-btn {
        width: 100%;
        min-height: 44px;
        border-radius: 12px;
        font-size: 14px;
      }

      .footer-right .export-dropdown {
        width: 100%;
      }

      .footer-right .export-dropdown > .footer-btn {
        width: 100%;
      }

      .copyright {
        padding: 10px calc(10px + var(--safe-right)) calc(10px + var(--safe-bottom)) calc(10px + var(--safe-left));
        font-size: 12px;
      }
    }

    @media (max-width: 600px) {
      .app-header {
        padding-right: calc(10px + var(--safe-right));
        padding-left: calc(10px + var(--safe-left));
      }

      .app-title {
        font-size: 16px;
      }

      .lang-btn {
        min-width: 42px;
        padding: 5px 8px;
        font-size: 12px;
      }
    }

    /* Copyright Footer */
    .copyright {
      flex-shrink: 0;
      text-align: center;
      padding: 12px 16px;
      font-size: 13px;
      color: var(--text-secondary);
      background: var(--bg-secondary);
      border-top: 1px solid var(--border);
    }
    .copyright a {
      color: var(--accent);
      text-decoration: none;
    }
    .copyright a:hover {
      text-decoration: underline;
    }
    .copyright .github-link {
      display: inline-block;
      margin-left: 12px;
      vertical-align: middle;
      height: 28px;
    }
  </style>

  <!-- External Libraries -->
  <script type="module">
    import LibRaw from './index.js';
    window.LibRaw = LibRaw;
  </script>
  <script src="https://cdn.jsdelivr.net/npm/pako/dist/pako.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/upng-js@2.1.0/UPNG.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/utif@3.1.0/UTIF.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/jszip@3/dist/jszip.min.js"></script>
</head>

<body>
  <!-- Header -->
  <header class="app-header">
    <h1 class="app-title" data-i18n="title">Negative Converter</h1>
    <div class="lang-selector">
      <button class="lang-btn" data-lang="zh">中文</button>
      <button class="lang-btn" data-lang="en">EN</button>
      <button class="lang-btn" data-lang="ja">日本語</button>
    </div>
  </header>

  <!-- Main Content -->
  <main class="app-main">
    <!-- Preview Section -->
    <section class="preview-section">
      <div class="canvas-container" id="canvasContainer">
        <div class="upload-placeholder" id="uploadPlaceholder">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
            <path d="M4 16l4.586-4.586a2 2 0 012.828 0L16 16m-2-2l1.586-1.586a2 2 0 012.828 0L20 14m-6-6h.01M6 20h12a2 2 0 002-2V6a2 2 0 00-2-2H6a2 2 0 00-2 2v12a2 2 0 002 2z"/>
          </svg>
          <p data-i18n="dropHint">Drop image here or click to open</p>
          <button class="upload-btn" id="uploadBtn" data-i18n="selectFile">Select File</button>
          <button class="upload-btn" id="uploadFolderBtn" style="margin-left: 8px; background: var(--bg-tertiary); border: 1px solid var(--border);" data-i18n="selectFolder">Select Folder</button>
          <input type="file" id="fileInput" accept=".cr2,.nef,.arw,.dng,.raw,.rw2,.tif,.tiff,image/*" multiple>
          <input type="file" id="folderInput" accept=".cr2,.nef,.arw,.dng,.raw,.rw2,.tif,.tiff,image/*" webkitdirectory style="display: none;">
        </div>
        <canvas id="canvas" style="display: none;"></canvas>
        <canvas id="glCanvas" style="display: none;"></canvas>
        <div class="crop-overlay" id="cropOverlay"></div>
        <div class="loupe" id="loupe">
          <canvas id="loupeCanvas" width="155" height="155"></canvas>
          <div class="loupe-info" id="loupeInfo"></div>
        </div>
      </div>

      <!-- Toolbar -->
      <div class="preview-toolbar" id="previewToolbar" style="display: none;">
        <span class="status-badge step1" id="statusBadge" data-i18n="step1">Step 1: Crop</span>
        <div class="toolbar-separator"></div>
        <button class="toolbar-btn" id="rotateLeftBtn" title="Rotate Left">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M2.5 2v6h6M2.66 12a10 10 0 11.8 4"/></svg>
          <span>-90°</span>
        </button>
        <button class="toolbar-btn" id="rotateRightBtn" title="Rotate Right">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M21.5 2v6h-6M21.34 12a10 10 0 11-.8 4" transform="scale(-1,1) translate(-24,0)"/></svg>
          <span>+90°</span>
        </button>
        <button class="toolbar-btn" id="mirrorBtn" data-i18n="mirror" title="Mirror">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <path d="M12 4v16M4 8l4 4-4 4M20 8l-4 4 4 4"/>
          </svg>
          <span data-i18n="mirror">Mirror</span>
        </button>
        <div class="rotate-controls">
          <input type="number" class="rotate-input" id="rotateAngle" value="0" min="-180" max="180" step="0.1">
          <span>°</span>
          <button class="toolbar-btn" id="applyRotateBtn" data-i18n="applyRotate">Apply</button>
        </div>
        <div class="toolbar-separator"></div>
        <button class="toolbar-btn" id="cropBtn" data-i18n="crop">Crop</button>
        <button class="toolbar-btn" id="applyCropBtn" style="display: none;" data-i18n="applyCrop">Apply Crop</button>
        <button class="toolbar-btn" id="cancelCropBtn" style="display: none;" data-i18n="cancelCrop">Cancel</button>
        <div class="toolbar-separator" id="convertSeparator" style="display: none;"></div>
        <button class="toolbar-btn primary" id="convertBtn" style="display: none;" data-i18n="convert">Convert Negative</button>
        <button class="toolbar-btn primary" id="convertPositiveBtn" style="display: none;" data-i18n="convertPositive">Convert Positive</button>
      </div>

      <!-- Histogram -->
      <div class="histogram-container" id="histogramContainer" style="display: none;">
        <div class="histogram-label" data-i18n="histogram">Histogram</div>
        <canvas id="histogramCanvas"></canvas>
      </div>
    </section>

    <!-- Controls Panel -->
    <aside class="controls-panel" id="controlsPanel" style="display: none;">
      <!-- File List (Batch Mode) -->
      <div class="file-list-section" id="fileListSection" style="display: none;">
        <div class="file-list-header">
          <span class="file-list-title" data-i18n="fileList">File List</span>
          <span class="file-list-count" id="fileListCount">0 / 0</span>
        </div>
        <div class="file-list-items" id="fileListItems">
          <!-- File items dynamically added here -->
        </div>
        <div class="file-list-actions">
          <button class="file-list-btn" id="selectAllBtn" data-i18n="selectAll">All</button>
          <button class="file-list-btn" id="selectNoneBtn" data-i18n="selectNone">None</button>
          <button class="file-list-btn" id="addMoreFilesBtn" data-i18n="addFiles">Add</button>
          <button class="file-list-btn" id="clearFileListBtn" data-i18n="clearList">Clear</button>
        </div>
      </div>

      <!-- Workflow Guide -->
      <div class="control-section">
        <div class="section-header">
          <span class="section-title" data-i18n="workflow">Workflow</span>
        </div>
        <div class="workflow-steps" id="workflowSteps">
          <div class="workflow-step active" id="step1">
            <span class="step-number">1</span>
            <span data-i18n="stepCrop">Crop image (remove non-film areas)</span>
          </div>
          <div class="workflow-step" id="step2">
            <span class="step-number">2</span>
            <span data-i18n="stepBase">Sample film base (orange mask)</span>
          </div>
          <div class="workflow-step" id="step3">
            <span class="step-number">3</span>
            <span data-i18n="stepAdjust">Adjust colors and export</span>
          </div>
        </div>
        <div class="info-box workflow-guide-note" id="batchStep3GuideBox" data-i18n="batchStep3Guide" style="display: none;">
          Batch Step 3 Guide:
          1) Adjust current image.
          2) Click "Save Settings".
          3) Click the next file in File List.
          4) Repeat, then export all.
        </div>
      </div>

      <!-- Film Settings (Step 2) -->
      <div class="control-section" id="filmSettingsSection" style="display: none;">
        <div class="section-header">
          <span class="section-title" data-i18n="filmSettings">Film Settings</span>
        </div>
        <div class="section-content">
          <div class="film-type-toggle">
            <button class="film-type-btn active" data-type="color" data-i18n="colorFilm">Color</button>
            <button class="film-type-btn" data-type="bw" data-i18n="bwFilm">B&W</button>
            <button class="film-type-btn" data-type="positive" data-i18n="positiveFilm">Positive</button>
          </div>
          <select class="preset-select" id="filmPreset">
            <option value="generic_color" data-i18n="genericColor">Generic Color</option>
          </select>
          <div id="filmBaseControls">
            <div class="info-box" data-i18n="filmBaseInfo">Click on the orange film base area (unexposed edge) to sample the mask color</div>
            <div class="film-base-buttons">
              <button class="film-base-btn" id="sampleBaseBtn" data-i18n="sampleBase">Sample Film Base</button>
              <button class="film-base-btn" id="autoDetectBtn" data-i18n="autoDetect">Auto Detect</button>
            </div>
            <div class="film-base-preview" id="filmBasePreview" style="display: none;">
              <div class="film-base-color" id="filmBaseColor"></div>
              <div class="film-base-values" id="filmBaseValues">R: 0 G: 0 B: 0</div>
            </div>
          </div>
          <div class="info-box" id="positiveFilmInfo" data-i18n="positiveModeInfo" style="display: none;">Positive slide film mode does not require film base sampling.</div>
          <button class="toolbar-btn primary" id="applyConvertBtn" style="margin-top: 8px; width: 100%; justify-content: center;" data-i18n="applyConvert">Apply & Convert</button>
        </div>
      </div>

      <!-- White Balance (Step 3) -->
      <div class="control-section" id="whiteBalanceSection" style="display: none;">
        <div class="section-header" data-section="wb">
          <span class="section-title" data-i18n="whiteBalance">White Balance</span>
          <span class="section-toggle">▼</span>
        </div>
        <div class="section-content" id="wbSection">
          <div class="info-box" data-i18n="wbInfo">Click on a neutral gray area in the image, or adjust manually</div>
          <button class="film-base-btn" id="sampleWBBtn" data-i18n="sampleWB">Sample Gray Point</button>
          <div class="slider-control">
            <div class="slider-header">
              <span class="slider-label">R</span>
              <input type="number" class="slider-number-input" id="wbRValue" min="0.5" max="2" step="0.01" value="1.00">
            </div>
            <input type="range" class="slider-input" id="wbR" min="0.5" max="2" step="0.01" value="1">
          </div>
          <div class="slider-control">
            <div class="slider-header">
              <span class="slider-label">G</span>
              <input type="number" class="slider-number-input" id="wbGValue" min="0.5" max="2" step="0.01" value="1.00">
            </div>
            <input type="range" class="slider-input" id="wbG" min="0.5" max="2" step="0.01" value="1">
          </div>
          <div class="slider-control">
            <div class="slider-header">
              <span class="slider-label">B</span>
              <input type="number" class="slider-number-input" id="wbBValue" min="0.5" max="2" step="0.01" value="1.00">
            </div>
            <input type="range" class="slider-input" id="wbB" min="0.5" max="2" step="0.01" value="1">
          </div>
        </div>
      </div>

      <!-- Tone Adjustments (Step 3) -->
      <div class="control-section" id="toneSection" style="display: none;">
        <div class="section-header" data-section="tone">
          <span class="section-title" data-i18n="toneAdjustments">Tone</span>
          <span class="section-toggle">▼</span>
        </div>
        <div class="section-content" id="toneSectionContent">
          <div class="slider-control">
            <div class="slider-header">
              <span class="slider-label" data-i18n="exposure">Exposure</span>
              <div class="slider-value-group">
                <input type="number" class="slider-number-input" id="exposureValue" min="-3" max="3" step="0.1" value="0.0">
                <span class="slider-unit">EV</span>
              </div>
            </div>
            <input type="range" class="slider-input" id="exposure" min="-3" max="3" step="0.1" value="0">
          </div>
          <div class="slider-control">
            <div class="slider-header">
              <span class="slider-label" data-i18n="contrast">Contrast</span>
              <input type="number" class="slider-number-input" id="contrastValue" min="-100" max="100" step="1" value="0">
            </div>
            <input type="range" class="slider-input" id="contrast" min="-100" max="100" step="1" value="0">
          </div>
          <div class="slider-control">
            <div class="slider-header">
              <span class="slider-label" data-i18n="highlights">Highlights</span>
              <input type="number" class="slider-number-input" id="highlightsValue" min="-100" max="100" step="1" value="0">
            </div>
            <input type="range" class="slider-input" id="highlights" min="-100" max="100" step="1" value="0">
          </div>
          <div class="slider-control">
            <div class="slider-header">
              <span class="slider-label" data-i18n="shadows">Shadows</span>
              <input type="number" class="slider-number-input" id="shadowsValue" min="-100" max="100" step="1" value="0">
            </div>
            <input type="range" class="slider-input" id="shadows" min="-100" max="100" step="1" value="0">
          </div>
        </div>
      </div>

      <!-- Color Balance (Step 3) -->
      <div class="control-section" id="colorSection" style="display: none;">
        <div class="section-header" data-section="color">
          <span class="section-title" data-i18n="colorBalance">Color Balance</span>
          <span class="section-toggle">▼</span>
        </div>
        <div class="section-content" id="colorSectionContent">
          <div class="slider-control">
            <div class="slider-header">
              <span class="slider-label" data-i18n="temperature">Temperature</span>
              <input type="number" class="slider-number-input" id="temperatureValue" min="-100" max="100" step="1" value="0">
            </div>
            <input type="range" class="slider-input" id="temperature" min="-100" max="100" step="1" value="0">
          </div>
          <div class="slider-control">
            <div class="slider-header">
              <span class="slider-label" data-i18n="tint">Tint</span>
              <input type="number" class="slider-number-input" id="tintValue" min="-100" max="100" step="1" value="0">
            </div>
            <input type="range" class="slider-input" id="tint" min="-100" max="100" step="1" value="0">
          </div>
          <div class="slider-control">
            <div class="slider-header">
              <span class="slider-label" data-i18n="vibrance">Vibrance</span>
              <input type="number" class="slider-number-input" id="vibranceValue" min="-100" max="100" step="1" value="0">
            </div>
            <input type="range" class="slider-input" id="vibrance" min="-100" max="100" step="1" value="0">
          </div>
          <div class="slider-control">
            <div class="slider-header">
              <span class="slider-label" data-i18n="saturation">Saturation</span>
              <input type="number" class="slider-number-input" id="saturationValue" min="-100" max="100" step="1" value="0">
            </div>
            <input type="range" class="slider-input" id="saturation" min="-100" max="100" step="1" value="0">
          </div>
        </div>
      </div>

      <!-- CMY Adjustments (Step 3) -->
      <div class="control-section" id="cmySection" style="display: none;">
        <div class="section-header" data-section="cmy">
          <span class="section-title">CMY</span>
          <span class="section-toggle">▼</span>
        </div>
        <div class="section-content" id="cmySectionContent">
          <div class="slider-control">
            <div class="slider-header">
              <span class="slider-label">Cyan</span>
              <input type="number" class="slider-number-input" id="cyanValue" min="-100" max="100" step="1" value="0">
            </div>
            <input type="range" class="slider-input" id="cyan" min="-100" max="100" step="1" value="0">
          </div>
          <div class="slider-control">
            <div class="slider-header">
              <span class="slider-label">Magenta</span>
              <input type="number" class="slider-number-input" id="magentaValue" min="-100" max="100" step="1" value="0">
            </div>
            <input type="range" class="slider-input" id="magenta" min="-100" max="100" step="1" value="0">
          </div>
          <div class="slider-control">
            <div class="slider-header">
              <span class="slider-label">Yellow</span>
              <input type="number" class="slider-number-input" id="yellowValue" min="-100" max="100" step="1" value="0">
            </div>
            <input type="range" class="slider-input" id="yellow" min="-100" max="100" step="1" value="0">
          </div>
        </div>
      </div>

      <!-- Advanced (Curves) (Step 3) -->
      <div class="control-section" id="advancedSection" style="display: none;">
        <div class="section-header" data-section="advanced">
          <span class="section-title" data-i18n="advanced">Advanced</span>
          <span class="section-toggle collapsed">▼</span>
        </div>
        <div class="section-content collapsed" id="advancedSectionContent">
          <div class="curve-editor">
            <p class="curve-hint" data-i18n="curveHint">Click and drag to adjust the curve</p>
            <div class="curve-tabs">
              <button class="curve-tab r active" data-channel="r">R</button>
              <button class="curve-tab g" data-channel="g">G</button>
              <button class="curve-tab b" data-channel="b">B</button>
              <button class="curve-tab reset" id="resetCurveBtn" data-i18n="resetCurve">Reset</button>
            </div>
            <canvas class="curve-canvas" id="curveCanvas"></canvas>
            <div class="curve-presets">
              <button class="curve-preset-btn" data-preset="linear" data-i18n="linear">Linear</button>
              <button class="curve-preset-btn" data-preset="scurve" data-i18n="sCurve">S-Curve</button>
              <button class="curve-preset-btn" data-preset="log" data-i18n="log">Log</button>
            </div>
          </div>
        </div>
      </div>
    </aside>
  </main>

  <!-- Footer -->
  <footer class="app-footer" id="appFooter" style="display: none;">
    <div class="footer-left">
      <button class="footer-btn" id="newImageBtn" data-i18n="newImage">New Image</button>
      <button class="footer-btn" id="resetBtn" data-i18n="reset">Reset</button>
      <button class="footer-btn" id="startOverBtn" data-i18n="startOver">Start Over</button>
    </div>
    <div class="footer-right">
      <button class="footer-btn" id="saveSettingsBtn" style="display: none;" data-i18n="saveSettings">Save Settings</button>
      <div class="export-dropdown">
        <button class="footer-btn primary" id="exportBtn" data-i18n="exportPng">Export PNG</button>
        <div class="export-dropdown-menu" id="exportDropdownMenu">
          <div class="export-format-section">
            <div class="export-format-label" data-i18n="exportFormat">Export Format</div>
            <div class="export-format-toggle">
              <button class="format-btn active" data-format="png">PNG</button>
              <button class="format-btn" data-format="jpeg">JPEG</button>
            </div>
          </div>
          <div class="export-quality-section" id="exportQualitySection">
            <div class="export-quality-header">
              <span class="export-quality-label" data-i18n="jpegQuality">JPEG Quality</span>
              <span class="export-quality-value" id="exportQualityValue">92%</span>
            </div>
            <input type="range" class="export-quality-slider" id="exportQualitySlider" min="1" max="100" value="92">
          </div>
          <button class="export-dropdown-item" id="exportSingleBtn" data-i18n="exportCurrent">Export Current (PNG)</button>
          <div class="export-dropdown-divider"></div>
          <button class="export-dropdown-item" id="exportZipBtn" data-i18n="exportZip" disabled>Export All (ZIP)</button>
          <button class="export-dropdown-item" id="exportAllBtn" data-i18n="exportIndividual" disabled>Download All Individually</button>
        </div>
      </div>
    </div>
  </footer>

  <!-- Batch Progress Modal -->
  <div class="batch-progress-overlay" id="batchProgressOverlay" style="display: none;">
    <div class="batch-progress-modal">
      <div class="batch-progress-title" data-i18n="batchProcessing">Batch Processing...</div>
      <div class="batch-progress-bar">
        <div class="batch-progress-fill" id="batchProgressFill" style="width: 0%;"></div>
      </div>
      <div class="batch-progress-text" id="batchProgressText">0 / 0</div>
      <div class="batch-progress-current" id="batchProgressCurrent"></div>
    </div>
  </div>

  <div class="copyright">
    © 2025 Negative Converter. <a href="https://neoanaloglab.com" target="_blank">neoanaloglab.com</a> All rights reserved.
    <span class="github-link">
      <a class="github-button" href="https://github.com/lexluthor0304/NegativeConverter" data-icon="octicon-star" data-size="large" data-show-count="true" aria-label="Star lexluthor0304/NegativeConverter on GitHub">Star</a>
    </span>
  </div>
  <script async defer src="https://buttons.github.io/buttons.js"></script>

  <script>
    // ===========================================
    // Internationalization
    // ===========================================
    const i18n = {
      zh: {
        title: "负片转正片",
        dropHint: "拖放图片到此处或点击读取",
        selectFile: "选择文件",
        applyRotate: "应用",
        mirror: "镜像",
        crop: "裁剪",
        applyCrop: "应用裁剪",
        cancelCrop: "取消",
        convert: "转换负片",
        convertPositive: "转换正片",
        histogram: "直方图",
        loadError: "加载文件失败",
        rawUnsupported: "当前 Safari 版本不支持 RAW 解码，请升级 Safari（建议 iOS 16.4+）或先转为 TIFF/JPEG。",
        workflow: "工作流程",
        stepCrop: "裁剪图像（移除胶片外区域）",
        stepBase: "采样胶片基底（橙色色罩）",
        stepAdjust: "调整颜色并导出",
        step1: "第1步：裁剪",
        step2: "第2步：色罩",
        step3: "第3步：调整",
        filmSettings: "胶片设置",
        colorFilm: "彩色",
        bwFilm: "黑白",
        positiveFilm: "正片",
        genericColor: "通用彩色",
        genericBW: "通用黑白",
        genericPositive: "通用正片",
        filmBaseInfo: "点击图像边缘的橙色胶片基底区域来采样色罩颜色",
        positiveModeInfo: "正片模式无需采样胶片基底。",
        sampleBase: "采样胶片基底",
        autoDetect: "自动检测",
        applyConvert: "应用并转换",
        whiteBalance: "白平衡",
        wbInfo: "点击图像中应为中性灰的区域，或手动调整",
        sampleWB: "采样灰点",
        toneAdjustments: "色调调整",
        exposure: "曝光",
        contrast: "对比度",
        highlights: "高光",
        shadows: "阴影",
        colorBalance: "色彩平衡",
        temperature: "色温",
        tint: "色调",
        vibrance: "活力",
        saturation: "饱和度",
        advanced: "高级",
        linear: "线性",
        sCurve: "S曲线",
        log: "对数",
        curveHint: "点击添加控制点，拖动调整，双击删除",
        resetCurve: "重置",
        reset: "重置调整",
        startOver: "重新开始",
        newImage: "选择新图片",
        exportPng: "导出 PNG",
        colorFilms: "彩色负片",
        bwFilms: "黑白负片",
        positiveFilms: "正片",
        processing: "处理中...",
        selectFolder: "选择文件夹",
        fileList: "文件列表",
        selectAll: "全选",
        selectNone: "全不选",
        addFiles: "添加",
        clearList: "清空",
        batchProcess: "批量处理",
        batchProcessing: "批量处理中...",
        saveSettings: "保存设置",
        settingsSaved: "当前图片设置已保存。请在文件列表中点击下一张继续。",
        batchStep3Guide: "批处理第3步指南：\n1) 调整当前图片。\n2) 点击“保存设置”。\n3) 在文件列表中点击下一张。\n4) 对需要的图片重复以上步骤。\n5) 最后点击“批量导出 (ZIP)”或“逐个下载全部”。",
        exportCurrent: "导出当前图片 (PNG)",
        exportZip: "批量导出 (ZIP)",
        exportIndividual: "逐个下载全部",
        pending: "等待处理",
        processingStatus: "处理中",
        done: "已完成",
        error: "错误",
        configured: "已配置",
        customSettings: "已设置",
        autoDetect: "自动",
        finishProcessing: "请先完成当前图片的处理流程（到第3步）",
        exportFormat: "导出格式",
        jpegQuality: "JPEG 质量",
        exportJpeg: "导出 JPEG",
        exportCurrentJpeg: "导出当前图片 (JPEG)",
        exportZipJpeg: "批量导出 (ZIP/JPEG)"
      },
      en: {
        title: "Negative Converter",
        dropHint: "Drop image here or click to open",
        selectFile: "Select File",
        applyRotate: "Apply",
        mirror: "Mirror",
        crop: "Crop",
        applyCrop: "Apply Crop",
        cancelCrop: "Cancel",
        convert: "Convert Negative",
        convertPositive: "Convert Positive",
        histogram: "Histogram",
        loadError: "Error loading file",
        rawUnsupported: "RAW decode is not supported in this Safari version. Update Safari (iOS 16.4+) or convert to TIFF/JPEG first.",
        workflow: "Workflow",
        stepCrop: "Crop image (remove non-film areas)",
        stepBase: "Sample film base (orange mask)",
        stepAdjust: "Adjust colors and export",
        step1: "Step 1: Crop",
        step2: "Step 2: Mask",
        step3: "Step 3: Adjust",
        filmSettings: "Film Settings",
        colorFilm: "Color",
        bwFilm: "B&W",
        positiveFilm: "Positive",
        genericColor: "Generic Color",
        genericBW: "Generic B&W",
        genericPositive: "Generic Positive",
        filmBaseInfo: "Click on the orange film base area (unexposed edge) to sample the mask color",
        positiveModeInfo: "Positive slide film mode does not require film base sampling.",
        sampleBase: "Sample Film Base",
        autoDetect: "Auto Detect",
        applyConvert: "Apply & Convert",
        whiteBalance: "White Balance",
        wbInfo: "Click on a neutral gray area in the image, or adjust manually",
        sampleWB: "Sample Gray Point",
        toneAdjustments: "Tone",
        exposure: "Exposure",
        contrast: "Contrast",
        highlights: "Highlights",
        shadows: "Shadows",
        colorBalance: "Color Balance",
        temperature: "Temperature",
        tint: "Tint",
        vibrance: "Vibrance",
        saturation: "Saturation",
        advanced: "Advanced",
        linear: "Linear",
        sCurve: "S-Curve",
        log: "Log",
        curveHint: "Click to add point, drag to adjust, double-click to remove",
        resetCurve: "Reset",
        reset: "Reset Adjustments",
        startOver: "Start Over",
        newImage: "New Image",
        exportPng: "Export PNG",
        colorFilms: "Color Films",
        bwFilms: "B&W Films",
        positiveFilms: "Positive Slides",
        processing: "Processing...",
        selectFolder: "Select Folder",
        fileList: "File List",
        selectAll: "All",
        selectNone: "None",
        addFiles: "Add",
        clearList: "Clear",
        batchProcess: "Batch Process",
        batchProcessing: "Batch Processing...",
        saveSettings: "Save Settings",
        settingsSaved: "Settings saved for current image. Click the next file in File List to continue.",
        batchStep3Guide: "Batch Step 3 Guide:\n1) Adjust the current image.\n2) Click \"Save Settings\".\n3) Click the next file in File List.\n4) Repeat for each image you want.\n5) When finished, use \"Export All (ZIP)\" or \"Download All Individually\".",
        exportCurrent: "Export Current (PNG)",
        exportZip: "Export All (ZIP)",
        exportIndividual: "Download All Individually",
        pending: "Pending",
        processingStatus: "Processing",
        done: "Done",
        error: "Error",
        configured: "configured",
        customSettings: "Custom",
        autoDetect: "Auto",
        finishProcessing: "Please complete the workflow (step 3) before saving settings",
        exportFormat: "Export Format",
        jpegQuality: "JPEG Quality",
        exportJpeg: "Export JPEG",
        exportCurrentJpeg: "Export Current (JPEG)",
        exportZipJpeg: "Export All (ZIP/JPEG)"
      },
      ja: {
        title: "ネガポジ変換",
        dropHint: "画像をドロップまたはクリックして読み込み",
        selectFile: "ファイル選択",
        applyRotate: "適用",
        mirror: "ミラー",
        crop: "トリミング",
        applyCrop: "適用",
        cancelCrop: "キャンセル",
        convert: "ネガ変換",
        convertPositive: "ポジ変換",
        histogram: "ヒストグラム",
        loadError: "ファイルの読み込みに失敗しました",
        rawUnsupported: "この Safari バージョンでは RAW デコードに対応していません。Safari（iOS 16.4+ 推奨）へ更新するか、先に TIFF/JPEG に変換してください。",
        workflow: "ワークフロー",
        stepCrop: "画像をトリミング（フィルム外を除去）",
        stepBase: "フィルムベースを取得（オレンジマスク）",
        stepAdjust: "色調整とエクスポート",
        step1: "ステップ1：トリミング",
        step2: "ステップ2：マスク",
        step3: "ステップ3：調整",
        filmSettings: "フィルム設定",
        colorFilm: "カラー",
        bwFilm: "白黒",
        positiveFilm: "ポジ",
        genericColor: "汎用カラー",
        genericBW: "汎用白黒",
        genericPositive: "汎用ポジ",
        filmBaseInfo: "オレンジ色のフィルムベース部分をクリックしてマスク色を取得",
        positiveModeInfo: "ポジフィルムモードではフィルムベースのサンプリングは不要です。",
        sampleBase: "フィルムベースを取得",
        autoDetect: "自動検出",
        applyConvert: "適用して変換",
        whiteBalance: "ホワイトバランス",
        wbInfo: "画像内のニュートラルグレー部分をクリック、または手動調整",
        sampleWB: "グレーポイントを取得",
        toneAdjustments: "トーン調整",
        exposure: "露出",
        contrast: "コントラスト",
        highlights: "ハイライト",
        shadows: "シャドウ",
        colorBalance: "カラーバランス",
        temperature: "色温度",
        tint: "色合い",
        vibrance: "バイブランス",
        saturation: "彩度",
        advanced: "詳細",
        linear: "リニア",
        sCurve: "Sカーブ",
        log: "ログ",
        curveHint: "クリックでポイント追加、ドラッグで調整、ダブルクリックで削除",
        resetCurve: "リセット",
        reset: "調整をリセット",
        startOver: "最初から",
        newImage: "新しい画像",
        exportPng: "PNG出力",
        colorFilms: "カラーフィルム",
        bwFilms: "白黒フィルム",
        positiveFilms: "ポジフィルム",
        processing: "処理中...",
        selectFolder: "フォルダ選択",
        fileList: "ファイル一覧",
        selectAll: "全選択",
        selectNone: "全解除",
        addFiles: "追加",
        clearList: "クリア",
        batchProcess: "一括処理",
        batchProcessing: "一括処理中...",
        saveSettings: "設定を保存",
        settingsSaved: "現在の画像の設定を保存しました。次はファイル一覧で次の画像をクリックしてください。",
        batchStep3Guide: "一括処理ステップ3ガイド：\n1) 現在の画像を調整します。\n2) 「設定を保存」をクリックします。\n3) ファイル一覧で次の画像をクリックします。\n4) 必要な画像ぶん繰り返します。\n5) 最後に「一括出力 (ZIP)」または「すべて個別にダウンロード」を実行します。",
        exportCurrent: "現在の画像を出力 (PNG)",
        exportZip: "一括出力 (ZIP)",
        exportIndividual: "すべて個別にダウンロード",
        pending: "待機中",
        processingStatus: "処理中",
        done: "完了",
        error: "エラー",
        configured: "設定済",
        customSettings: "設定済",
        autoDetect: "自動",
        finishProcessing: "設定を保存する前にワークフロー（ステップ3）を完了してください",
        exportFormat: "出力形式",
        jpegQuality: "JPEG品質",
        exportJpeg: "JPEG出力",
        exportCurrentJpeg: "現在の画像を出力 (JPEG)",
        exportZipJpeg: "一括出力 (ZIP/JPEG)"
      }
    };

    let currentLang = 'en';

    function setLanguage(lang) {
      currentLang = lang;
      document.querySelectorAll('.lang-btn').forEach(btn => {
        btn.classList.toggle('active', btn.dataset.lang === lang);
      });
      document.querySelectorAll('[data-i18n]').forEach(el => {
        const key = el.dataset.i18n;
        if (i18n[lang][key]) {
          el.textContent = i18n[lang][key];
        }
      });
      document.querySelectorAll('[data-i18n-label]').forEach(el => {
        const key = el.dataset.i18nLabel;
        if (i18n[lang][key]) {
          el.label = i18n[lang][key];
        }
      });
    }

    // Detect language
    const browserLang = navigator.language.startsWith('ja') ? 'ja'
      : navigator.language.startsWith('zh') ? 'zh' : 'en';
    setLanguage(browserLang);

    // Language selector
    document.querySelectorAll('.lang-btn').forEach(btn => {
      btn.addEventListener('click', () => setLanguage(btn.dataset.lang));
    });

    // ===========================================
    // Film Presets
    // ===========================================
    const PRESET_DATA_URL = './presets/film_presets.json';
    const PRESET_TYPES = ['color', 'bw', 'positive'];
    const PRESET_GROUPS = [
      { type: 'color', labelKey: 'colorFilms', fallbackLabel: 'Color' },
      { type: 'bw', labelKey: 'bwFilms', fallbackLabel: 'B&W' },
      { type: 'positive', labelKey: 'positiveFilms', fallbackLabel: 'Positive' }
    ];
    const GENERIC_PRESET_I18N_KEYS = {
      generic_color: 'genericColor',
      generic_bw: 'genericBW',
      generic_positive: 'genericPositive'
    };
    const DEFAULT_PRESET_BY_TYPE = {
      color: 'generic_color',
      bw: 'generic_bw',
      positive: 'generic_positive'
    };
    const DEFAULT_FILM_PRESET_LIST = [
      {
        id: 'generic_color',
        name: 'Generic Color',
        brand: 'generic',
        type: 'color',
        status: 'active',
        baseColor: { r: 0.82, g: 0.55, b: 0.36 },
        characteristics: { warmth: 0, saturation: 0, contrast: 0 }
      },
      {
        id: 'generic_bw',
        name: 'Generic B&W',
        brand: 'generic',
        type: 'bw',
        status: 'active',
        contrast: 1.0,
        gamma: 1.0,
        bw: { gamma: 1.0 },
        characteristics: { warmth: 0, saturation: 0, contrast: 0 }
      },
      {
        id: 'generic_positive',
        name: 'Generic Positive',
        brand: 'generic',
        type: 'positive',
        status: 'active',
        characteristics: { warmth: 0, saturation: 0.1, contrast: 0.1 }
      }
    ];

    let FILM_PRESETS = {};
    let FILM_PRESET_LIST = [];
    let FILM_PRESET_ALIASES = {};

    function sanitizePresetType(type) {
      return PRESET_TYPES.includes(type) ? type : 'color';
    }

    function clampUnit(value, fallback) {
      const n = Number(value);
      if (Number.isFinite(n)) return Math.max(0, Math.min(1, n));
      return fallback;
    }

    function normalizePreset(rawPreset) {
      if (!rawPreset || typeof rawPreset !== 'object') return null;
      if (typeof rawPreset.id !== 'string' || !rawPreset.id) return null;

      const type = sanitizePresetType(rawPreset.type);
      const status = rawPreset.status === 'deprecated' ? 'deprecated' : 'active';
      const characteristics = rawPreset.characteristics || {};
      const preset = {
        id: rawPreset.id,
        name: rawPreset.name || rawPreset.id,
        brand: rawPreset.brand || 'generic',
        type,
        status,
        characteristics: {
          warmth: Number.isFinite(characteristics.warmth) ? characteristics.warmth : 0,
          saturation: Number.isFinite(characteristics.saturation) ? characteristics.saturation : 0,
          contrast: Number.isFinite(characteristics.contrast) ? characteristics.contrast : 0
        }
      };

      if (type === 'color') {
        const baseColor = rawPreset.baseColor || {};
        preset.baseColor = {
          r: clampUnit(baseColor.r, 0.82),
          g: clampUnit(baseColor.g, 0.55),
          b: clampUnit(baseColor.b, 0.36)
        };
      }

      if (type === 'bw') {
        const gammaFromNested = rawPreset.bw && Number.isFinite(rawPreset.bw.gamma)
          ? rawPreset.bw.gamma
          : undefined;
        const gamma = Number.isFinite(rawPreset.gamma) ? rawPreset.gamma
          : (gammaFromNested !== undefined ? gammaFromNested : 1.0);
        const contrast = Number.isFinite(rawPreset.contrast) ? rawPreset.contrast : 1.0;
        preset.gamma = gamma;
        preset.contrast = contrast;
        preset.bw = { gamma };
      }

      if (rawPreset.sourceMeta && typeof rawPreset.sourceMeta === 'object') {
        preset.sourceMeta = rawPreset.sourceMeta;
      }

      return preset;
    }

    function buildPresetMap(presetList) {
      const map = {};
      for (const preset of presetList) {
        map[preset.id] = preset;
      }
      return map;
    }

    function applyPresetDataset(dataset) {
      if (!dataset || !Array.isArray(dataset.presets)) return false;
      const list = dataset.presets
        .map(normalizePreset)
        .filter(Boolean);
      if (!list.length) return false;

      FILM_PRESET_LIST = list;
      FILM_PRESETS = buildPresetMap(list);
      FILM_PRESET_ALIASES = (dataset.aliases && typeof dataset.aliases === 'object')
        ? { ...dataset.aliases }
        : {};
      return true;
    }

    function initPresetFallbacks() {
      FILM_PRESET_LIST = DEFAULT_FILM_PRESET_LIST
        .map(normalizePreset)
        .filter(Boolean);
      FILM_PRESETS = buildPresetMap(FILM_PRESET_LIST);
      FILM_PRESET_ALIASES = {};
    }

    function resolvePresetId(presetId) {
      if (typeof presetId !== 'string' || !presetId) return null;
      if (FILM_PRESETS[presetId]) return presetId;
      const aliasTarget = FILM_PRESET_ALIASES[presetId];
      if (aliasTarget && FILM_PRESETS[aliasTarget]) return aliasTarget;
      return null;
    }

    function getDefaultPresetForType(type) {
      const safeType = sanitizePresetType(type);
      const preferredId = DEFAULT_PRESET_BY_TYPE[safeType];
      if (preferredId && FILM_PRESETS[preferredId]) return preferredId;

      const firstActive = FILM_PRESET_LIST.find((preset) => (
        preset.type === safeType && preset.status !== 'deprecated'
      ));
      return firstActive ? firstActive.id : (DEFAULT_PRESET_BY_TYPE.color || 'generic_color');
    }

    function getPresetOrFallback(presetId, fallbackType = 'color') {
      const resolved = resolvePresetId(presetId);
      if (resolved) return FILM_PRESETS[resolved];
      const fallbackId = getDefaultPresetForType(fallbackType);
      return FILM_PRESETS[fallbackId] || FILM_PRESETS.generic_color || null;
    }

    function getBwPresetParams(preset) {
      const safePreset = preset || {};
      const contrast = Number.isFinite(safePreset.contrast) ? safePreset.contrast : 1.0;
      const gamma = Number.isFinite(safePreset.gamma)
        ? safePreset.gamma
        : (safePreset.bw && Number.isFinite(safePreset.bw.gamma) ? safePreset.bw.gamma : 1.0);
      return { contrast, gamma };
    }

    function renderPresetOptions(selectedPresetId = state ? state.filmPreset : null) {
      const presetSelect = document.getElementById('filmPreset');
      if (!presetSelect) return;

      presetSelect.innerHTML = '';
      for (const group of PRESET_GROUPS) {
        const presets = FILM_PRESET_LIST.filter((preset) => (
          preset.type === group.type && preset.status !== 'deprecated'
        ));
        if (!presets.length) continue;

        const optgroup = document.createElement('optgroup');
        optgroup.setAttribute('data-i18n-label', group.labelKey);
        optgroup.label = (i18n[currentLang] && i18n[currentLang][group.labelKey]) || group.fallbackLabel;

        for (const preset of presets) {
          const option = document.createElement('option');
          option.value = preset.id;
          option.textContent = preset.name;
          const i18nKey = GENERIC_PRESET_I18N_KEYS[preset.id];
          if (i18nKey) option.setAttribute('data-i18n', i18nKey);
          optgroup.appendChild(option);
        }
        presetSelect.appendChild(optgroup);
      }

      const resolvedSelection = resolvePresetId(selectedPresetId);
      const fallbackSelection = getDefaultPresetForType(state ? state.filmType : 'color');
      const nextSelection = resolvedSelection || fallbackSelection;
      if (nextSelection && presetSelect.querySelector(`option[value="${nextSelection}"]`)) {
        presetSelect.value = nextSelection;
      } else if (presetSelect.options.length) {
        presetSelect.value = presetSelect.options[0].value;
      }

      if (state && presetSelect.value) {
        state.filmPreset = presetSelect.value;
      }
    }

    async function loadPresetDataset() {
      initPresetFallbacks();
      try {
        const response = await fetch(PRESET_DATA_URL, { cache: 'no-store' });
        if (!response.ok) {
          throw new Error(`Preset dataset request failed: ${response.status}`);
        }
        const payload = await response.json();
        if (!applyPresetDataset(payload)) {
          throw new Error('Preset dataset is invalid.');
        }
      } catch (err) {
        console.warn('Using fallback preset dataset.', err);
      }
      renderPresetOptions(state ? state.filmPreset : null);
      if (typeof setLanguage === 'function') setLanguage(currentLang);
    }

    initPresetFallbacks();

    // ===========================================
    // Application State
    // ===========================================
    const state = {
      // Workflow state
      currentStep: 1,  // 1=crop, 2=film base, 3=adjust

      // Image data
      originalImageData: null,      // Raw loaded image (negative, untouched)
      croppedImageData: null,       // After cropping (still negative)
      processedImageData: null,     // After negative conversion
      displayImageData: null,       // After all adjustments
      previewSourceImageData: null, // Downscaled source for preview renders
      histogramSourceImageData: null, // Further downscaled source for histogram updates
      webglSourceImageData: null,   // Downscaled source for WebGL preview renders

      // Film settings
      filmType: 'color',
      filmPreset: 'generic_color',
      filmBase: { r: 210, g: 140, b: 90 },
      filmBaseSet: false,

      // White balance multipliers
      wbR: 1.0,
      wbG: 1.0,
      wbB: 1.0,

      // Tone adjustments
      exposure: 0,
      contrast: 0,
      highlights: 0,
      shadows: 0,

      // Color adjustments
      temperature: 0,
      tint: 0,
      vibrance: 0,
      saturation: 0,

      // CMY
      cyan: 0,
      magenta: 0,
      yellow: 0,

      // Curves (256-value lookup tables)
      curves: { r: null, g: null, b: null },
      // Control points for each channel [{x, y}, ...] sorted by x
      curvePoints: {
        r: [{ x: 0, y: 0 }, { x: 255, y: 255 }],
        g: [{ x: 0, y: 0 }, { x: 255, y: 255 }],
        b: [{ x: 0, y: 0 }, { x: 255, y: 255 }]
      },

      // UI state
      cropping: false,
      cropStart: null,
      croppingActive: false,
      samplingMode: null,  // null, 'filmBase', 'whiteBalance'
      rotation: 0,

      // Batch mode state
      batchMode: false,
      // fileQueue item: {file, selected, status, error, settings: null | {...}}
      // settings = null means use auto-detect for film base
      fileQueue: [],
      currentFileIndex: 0,
      // Saved crop region for current image (used when saving settings)
      cropRegion: null,

      // Export settings
      exportFormat: 'png',  // 'png' or 'jpeg'
      jpegQuality: 92,      // 1-100

      // Render state
      lastRenderQuality: 'full' // 'full' | 'preview' | 'gl'
    };

    // Initialize curves
    function initCurves(markDirty = false) {
      state.curves.r = new Uint8Array(256);
      state.curves.g = new Uint8Array(256);
      state.curves.b = new Uint8Array(256);
      // Reset control points to linear
      state.curvePoints.r = [{ x: 0, y: 0 }, { x: 255, y: 255 }];
      state.curvePoints.g = [{ x: 0, y: 0 }, { x: 255, y: 255 }];
      state.curvePoints.b = [{ x: 0, y: 0 }, { x: 255, y: 255 }];
      // Fill curves with linear values
      for (let i = 0; i < 256; i++) {
        state.curves.r[i] = i;
        state.curves.g[i] = i;
        state.curves.b[i] = i;
      }

      if (markDirty && webglState.gl) webglState.curveDirty = true;
    }
    initCurves(false);

    // ===========================================
    // Canvas & Context
    // ===========================================
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d', { willReadFrequently: true });
    const glCanvas = document.getElementById('glCanvas');
    const canvasContainer = document.getElementById('canvasContainer');
    const histogramCanvas = document.getElementById('histogramCanvas');
    const histogramCtx = histogramCanvas.getContext('2d');
    const HISTOGRAM_MAX_SAMPLES = 24_576;
    const HISTOGRAM_UPDATE_INTERVAL_MS = 260;
    const curveCanvas = document.getElementById('curveCanvas');
    const curveCtx = curveCanvas.getContext('2d');
    const loupe = document.getElementById('loupe');
    const loupeCanvas = document.getElementById('loupeCanvas');
    const loupeCtx = loupeCanvas.getContext('2d');
    const loupeInfo = document.getElementById('loupeInfo');

    const loupeSrcCanvas = document.createElement('canvas');
    const loupeSrcCtx = loupeSrcCanvas.getContext('2d', { willReadFrequently: true });

    let transformCanvas = document.createElement('canvas');
    let transformCtx = transformCanvas.getContext('2d');

    // ===========================================
    // Workflow Management
    // ===========================================
    function updateBatchStep3GuideVisibility() {
      const guide = document.getElementById('batchStep3GuideBox');
      if (!guide) return;
      guide.style.display = (state.batchMode && state.currentStep >= 3) ? 'block' : 'none';
    }

    function updateWorkflowUI() {
      const steps = ['step1', 'step2', 'step3'];
      const badge = document.getElementById('statusBadge');

      steps.forEach((stepId, idx) => {
        const stepEl = document.getElementById(stepId);
        stepEl.classList.remove('active', 'completed');
        if (idx + 1 < state.currentStep) {
          stepEl.classList.add('completed');
        } else if (idx + 1 === state.currentStep) {
          stepEl.classList.add('active');
        }
      });

      // Update badge
      badge.className = 'status-badge step' + state.currentStep;
      badge.setAttribute('data-i18n', 'step' + state.currentStep);
      badge.textContent = i18n[currentLang]['step' + state.currentStep];

      // Show/hide sections based on step
      document.getElementById('filmSettingsSection').style.display =
        state.currentStep >= 2 ? 'block' : 'none';

      const step3Sections = ['whiteBalanceSection', 'toneSection', 'colorSection', 'cmySection', 'advancedSection'];
      step3Sections.forEach(id => {
        document.getElementById(id).style.display = state.currentStep >= 3 ? 'block' : 'none';
      });

      // Show convert button after cropping is done
      document.getElementById('convertSeparator').style.display =
        state.currentStep === 1 ? 'inline-block' : 'none';
      document.getElementById('convertBtn').style.display =
        state.currentStep === 1 ? 'inline-flex' : 'none';
      document.getElementById('convertPositiveBtn').style.display =
        state.currentStep === 1 ? 'inline-flex' : 'none';

      updateBatchStep3GuideVisibility();
    }

    function goToStep(step) {
      state.currentStep = step;
      updateWorkflowUI();
      updateCanvasVisibility();
    }

    // ===========================================
    // Core Negative Processing Algorithm
    // ===========================================
    function sampleFilmBase(imageData, x, y, radius = 10) {
      const { width, height, data } = imageData;
      let rSum = 0, gSum = 0, bSum = 0, count = 0;

      const startX = Math.max(0, x - radius);
      const endX = Math.min(width - 1, x + radius);
      const startY = Math.max(0, y - radius);
      const endY = Math.min(height - 1, y + radius);

      for (let py = startY; py <= endY; py++) {
        for (let px = startX; px <= endX; px++) {
          const idx = (py * width + px) * 4;
          rSum += data[idx];
          gSum += data[idx + 1];
          bSum += data[idx + 2];
          count++;
        }
      }

      return {
        r: Math.round(rSum / count),
        g: Math.round(gSum / count),
        b: Math.round(bSum / count)
      };
    }

    function autoDetectFilmBase(imageData) {
      const { width, height, data } = imageData;
      const edgeSize = Math.min(50, Math.floor(Math.min(width, height) * 0.05));

      let candidates = [];
      const regions = [
        { x: width / 2, y: edgeSize / 2 },
        { x: width / 2, y: height - edgeSize / 2 },
        { x: edgeSize / 2, y: height / 2 },
        { x: width - edgeSize / 2, y: height / 2 },
        { x: edgeSize / 2, y: edgeSize / 2 },
        { x: width - edgeSize / 2, y: edgeSize / 2 },
        { x: edgeSize / 2, y: height - edgeSize / 2 },
        { x: width - edgeSize / 2, y: height - edgeSize / 2 }
      ];

      for (const region of regions) {
        const sample = sampleFilmBase(imageData, Math.floor(region.x), Math.floor(region.y), edgeSize);
        const brightness = (sample.r + sample.g + sample.b) / 3;
        candidates.push({ ...sample, brightness });
      }

      candidates.sort((a, b) => b.brightness - a.brightness);
      return { r: candidates[0].r, g: candidates[0].g, b: candidates[0].b };
    }

    function convertColorNegative(imageData, filmBase) {
      const { width, height, data } = imageData;
      const output = new ImageData(new Uint8ClampedArray(data.length), width, height);
      const outData = output.data;

      const baseR = filmBase.r / 255;
      const baseG = filmBase.g / 255;
      const baseB = filmBase.b / 255;
      const eps = 0.001;

      const normalized = new Float32Array(data.length);

      for (let i = 0; i < data.length; i += 4) {
        let r = data[i] / 255;
        let g = data[i + 1] / 255;
        let b = data[i + 2] / 255;

        r = r / Math.max(baseR, eps);
        g = g / Math.max(baseG, eps);
        b = b / Math.max(baseB, eps);

        r = Math.min(r, 2);
        g = Math.min(g, 2);
        b = Math.min(b, 2);

        r = 1 / Math.max(r, eps);
        g = 1 / Math.max(g, eps);
        b = 1 / Math.max(b, eps);

        normalized[i] = r;
        normalized[i + 1] = g;
        normalized[i + 2] = b;
        normalized[i + 3] = 1;
      }

      let rMin = Infinity, rMax = -Infinity;
      let gMin = Infinity, gMax = -Infinity;
      let bMin = Infinity, bMax = -Infinity;

      for (let i = 0; i < normalized.length; i += 4) {
        rMin = Math.min(rMin, normalized[i]);
        rMax = Math.max(rMax, normalized[i]);
        gMin = Math.min(gMin, normalized[i + 1]);
        gMax = Math.max(gMax, normalized[i + 1]);
        bMin = Math.min(bMin, normalized[i + 2]);
        bMax = Math.max(bMax, normalized[i + 2]);
      }

      const rHist = new Float32Array(1000);
      const gHist = new Float32Array(1000);
      const bHist = new Float32Array(1000);

      for (let i = 0; i < normalized.length; i += 4) {
        const rIdx = Math.min(999, Math.floor((normalized[i] - rMin) / (rMax - rMin + 0.001) * 999));
        const gIdx = Math.min(999, Math.floor((normalized[i + 1] - gMin) / (gMax - gMin + 0.001) * 999));
        const bIdx = Math.min(999, Math.floor((normalized[i + 2] - bMin) / (bMax - bMin + 0.001) * 999));
        rHist[rIdx]++;
        gHist[gIdx]++;
        bHist[bIdx]++;
      }

      const pixelCount = width * height;
      function findPercentile(hist, target) {
        let sum = 0;
        for (let i = 0; i < hist.length; i++) {
          sum += hist[i];
          if (sum >= target) return i / 999;
        }
        return 1;
      }

      const rLow = rMin + (rMax - rMin) * findPercentile(rHist, pixelCount * 0.02);
      const rHigh = rMin + (rMax - rMin) * findPercentile(rHist, pixelCount * 0.98);
      const gLow = gMin + (gMax - gMin) * findPercentile(gHist, pixelCount * 0.02);
      const gHigh = gMin + (gMax - gMin) * findPercentile(gHist, pixelCount * 0.98);
      const bLow = bMin + (bMax - bMin) * findPercentile(bHist, pixelCount * 0.02);
      const bHigh = bMin + (bMax - bMin) * findPercentile(bHist, pixelCount * 0.98);

      for (let i = 0; i < normalized.length; i += 4) {
        let r = (normalized[i] - rLow) / (rHigh - rLow + 0.001);
        let g = (normalized[i + 1] - gLow) / (gHigh - gLow + 0.001);
        let b = (normalized[i + 2] - bLow) / (bHigh - bLow + 0.001);

        const gamma = 1.1;
        r = Math.pow(Math.max(0, Math.min(1, r)), gamma);
        g = Math.pow(Math.max(0, Math.min(1, g)), gamma);
        b = Math.pow(Math.max(0, Math.min(1, b)), gamma);

        outData[i] = Math.round(r * 255);
        outData[i + 1] = Math.round(g * 255);
        outData[i + 2] = Math.round(b * 255);
        outData[i + 3] = 255;
      }

      return output;
    }

    function convertBWNegative(imageData, options = {}) {
      const { width, height, data } = imageData;
      const output = new ImageData(new Uint8ClampedArray(data.length), width, height);
      const outData = output.data;

      const contrast = options.contrast || 1.0;
      const gamma = options.gamma || 1.0;

      const grayValues = new Float32Array(width * height);

      for (let i = 0; i < data.length; i += 4) {
        const gray = (data[i] * 0.299 + data[i + 1] * 0.587 + data[i + 2] * 0.114) / 255;
        grayValues[i / 4] = 1 - gray;
      }

      const sorted = Float32Array.from(grayValues).sort();
      const p2 = sorted[Math.floor(sorted.length * 0.02)];
      const p98 = sorted[Math.floor(sorted.length * 0.98)];

      for (let i = 0; i < grayValues.length; i++) {
        let v = (grayValues[i] - p2) / (p98 - p2 + 0.001);
        v = Math.max(0, Math.min(1, v));
        v = ((v - 0.5) * contrast) + 0.5;
        v = Math.max(0, Math.min(1, v));
        v = Math.pow(v, gamma);

        const byte = Math.round(v * 255);
        const idx = i * 4;
        outData[idx] = byte;
        outData[idx + 1] = byte;
        outData[idx + 2] = byte;
        outData[idx + 3] = 255;
      }

      return output;
    }

    function convertPositiveFilm(imageData, options = {}) {
      const { width, height, data } = imageData;
      const output = new ImageData(new Uint8ClampedArray(data.length), width, height);
      const outData = output.data;
      const pixelCount = width * height;

      const clipPercent = Math.max(0, Math.min(0.1, options.clipPercent ?? 0.01));
      const lowTarget = pixelCount * clipPercent;
      const highTarget = pixelCount * (1 - clipPercent);

      const rHist = new Uint32Array(256);
      const gHist = new Uint32Array(256);
      const bHist = new Uint32Array(256);

      for (let i = 0; i < data.length; i += 4) {
        rHist[data[i]]++;
        gHist[data[i + 1]]++;
        bHist[data[i + 2]]++;
      }

      function histogramPercentile(hist, target) {
        let sum = 0;
        for (let i = 0; i < hist.length; i++) {
          sum += hist[i];
          if (sum >= target) return i;
        }
        return hist.length - 1;
      }

      const rLow = histogramPercentile(rHist, lowTarget);
      const gLow = histogramPercentile(gHist, lowTarget);
      const bLow = histogramPercentile(bHist, lowTarget);
      const rHigh = histogramPercentile(rHist, highTarget);
      const gHigh = histogramPercentile(gHist, highTarget);
      const bHigh = histogramPercentile(bHist, highTarget);

      const rScale = 255 / Math.max(1, rHigh - rLow);
      const gScale = 255 / Math.max(1, gHigh - gLow);
      const bScale = 255 / Math.max(1, bHigh - bLow);

      for (let i = 0; i < data.length; i += 4) {
        let r = (data[i] - rLow) * rScale;
        let g = (data[i + 1] - gLow) * gScale;
        let b = (data[i + 2] - bLow) * bScale;

        if (r < 0) r = 0; else if (r > 255) r = 255;
        if (g < 0) g = 0; else if (g > 255) g = 255;
        if (b < 0) b = 0; else if (b > 255) b = 255;

        outData[i] = (r + 0.5) | 0;
        outData[i + 1] = (g + 0.5) | 0;
        outData[i + 2] = (b + 0.5) | 0;
        outData[i + 3] = 255;
      }

      return output;
    }

    // ===========================================
    // Pixel Adjustments (Optimized)
    // ===========================================
    function ensureImageDataBuffer(buffer, width, height) {
      if (buffer && buffer.width === width && buffer.height === height) return buffer;
      return new ImageData(new Uint8ClampedArray(width * height * 4), width, height);
    }

    function hue2rgb(p, q, t) {
      if (t < 0) t += 1;
      if (t > 1) t -= 1;
      if (t < 1 / 6) return p + (q - p) * 6 * t;
      if (t < 1 / 2) return q;
      if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;
      return p;
    }

    const channelLutR = new Uint8Array(256);
    const channelLutG = new Uint8Array(256);
    const channelLutB = new Uint8Array(256);

    function buildChannelLuts({
      lutR,
      lutG,
      lutB,
      curveR,
      curveG,
      curveB,
      rMult,
      gMult,
      bMult,
      contrastFactor,
      doContrast,
      doTempTint,
      tempRMult,
      tintGMult,
      tempBMult,
      doCMY,
      cmyRShift,
      cmyGShift,
      cmyBShift
    }) {
      for (let v = 0; v < 256; v++) {
        let r = v * rMult;
        let g = v * gMult;
        let b = v * bMult;

        if (doContrast) {
          r = (r - 127.5) * contrastFactor + 127.5;
          g = (g - 127.5) * contrastFactor + 127.5;
          b = (b - 127.5) * contrastFactor + 127.5;
        }

        if (doTempTint) {
          r *= tempRMult;
          g *= tintGMult;
          b *= tempBMult;
        }

        if (r < 0) r = 0; else if (r > 255) r = 255;
        if (g < 0) g = 0; else if (g > 255) g = 255;
        if (b < 0) b = 0; else if (b > 255) b = 255;

        if (doCMY) {
          r -= cmyRShift;
          g -= cmyGShift;
          b -= cmyBShift;

          if (r < 0) r = 0; else if (r > 255) r = 255;
          if (g < 0) g = 0; else if (g > 255) g = 255;
          if (b < 0) b = 0; else if (b > 255) b = 255;
        }

        lutR[v] = curveR[(r + 0.5) | 0];
        lutG[v] = curveG[(g + 0.5) | 0];
        lutB[v] = curveB[(b + 0.5) | 0];
      }
    }

    function applyAdjustmentsToBuffer(imageData, settings, output, quality = 'full') {
      const { data } = imageData;
      const outData = output.data;

      const preset = getPresetOrFallback(settings.filmPreset, settings.filmType || 'color');
      const presetChars = (preset && preset.characteristics) ? preset.characteristics : {};

      const exposureMult = Math.pow(2, settings.exposure);
      const contrastFactor = 1 + ((settings.contrast + (presetChars.contrast || 0) * 100) / 100);
      const tempFactor = (settings.temperature + (presetChars.warmth || 0) * 100) / 100;
      const tintFactor = settings.tint / 100;
      const satFactor = 1 + ((settings.saturation + (presetChars.saturation || 0) * 100) / 100);
      const vibFactor = settings.vibrance / 100;
      const highlightsFactor = settings.highlights / 100;
      const shadowsFactor = settings.shadows / 100;

      const rMult = settings.wbR * exposureMult;
      const gMult = settings.wbG * exposureMult;
      const bMult = settings.wbB * exposureMult;

      const tempRMult = 1 + tempFactor * 0.3;
      const tempBMult = 1 - tempFactor * 0.3;
      const tintGMult = 1 + tintFactor * 0.3;

      const cmyRShift = settings.cyan * 2.55;
      const cmyGShift = settings.magenta * 2.55;
      const cmyBShift = settings.yellow * 2.55;

      const curveR = settings.curves.r;
      const curveG = settings.curves.g;
      const curveB = settings.curves.b;

      const doContrast = contrastFactor !== 1;
      const doHighlights = highlightsFactor !== 0;
      const doShadows = shadowsFactor !== 0;
      const doTempTint = tempFactor !== 0 || tintFactor !== 0;
      const doHsl = satFactor !== 1 || vibFactor !== 0;
      const doCMY = cmyRShift !== 0 || cmyGShift !== 0 || cmyBShift !== 0;

      const lumaScale = 2 / 255;

      // Fast path: when adjustments are per-channel only, precompute LUTs once and do 3 lookups per pixel.
      if (!doHighlights && !doShadows && !doHsl) {
        buildChannelLuts({
          lutR: channelLutR,
          lutG: channelLutG,
          lutB: channelLutB,
          curveR,
          curveG,
          curveB,
          rMult,
          gMult,
          bMult,
          contrastFactor,
          doContrast,
          doTempTint,
          tempRMult,
          tintGMult,
          tempBMult,
          doCMY,
          cmyRShift,
          cmyGShift,
          cmyBShift
        });

        for (let i = 0; i < data.length; i += 4) {
          outData[i] = channelLutR[data[i]];
          outData[i + 1] = channelLutG[data[i + 1]];
          outData[i + 2] = channelLutB[data[i + 2]];
          outData[i + 3] = 255;
        }
        return;
      }

      for (let i = 0; i < data.length; i += 4) {
        let r = data[i] * rMult;
        let g = data[i + 1] * gMult;
        let b = data[i + 2] * bMult;

        if (doContrast) {
          r = (r - 127.5) * contrastFactor + 127.5;
          g = (g - 127.5) * contrastFactor + 127.5;
          b = (b - 127.5) * contrastFactor + 127.5;
        }

        if (doHighlights || doShadows) {
          const luma = (r * 0.299 + g * 0.587 + b * 0.114);
          if (doHighlights && luma > 127.5) {
            const mult = 1 + highlightsFactor * (luma - 127.5) * lumaScale;
            r *= mult; g *= mult; b *= mult;
          }
          if (doShadows && luma < 127.5) {
            const mult = 1 + shadowsFactor * (127.5 - luma) * lumaScale;
            r *= mult; g *= mult; b *= mult;
          }
        }

        if (doTempTint) {
          r *= tempRMult;
          b *= tempBMult;
          g *= tintGMult;
        }

        if (r < 0) r = 0; else if (r > 255) r = 255;
        if (g < 0) g = 0; else if (g > 255) g = 255;
        if (b < 0) b = 0; else if (b > 255) b = 255;

        // The old pipeline always rounded here (via an HSL round-trip),
        // so keep rounding even when saturation/vibrance is neutral.
        if (!doHsl) {
          r = (r + 0.5) | 0;
          g = (g + 0.5) | 0;
          b = (b + 0.5) | 0;
        }

        if (doHsl) {
          if (quality === 'preview') {
            // Fast approximation in RGB space (much cheaper than HSL), used only for interactive previews.
            const max = r > g ? (r > b ? r : b) : (g > b ? g : b);
            const min = r < g ? (r < b ? r : b) : (g < b ? g : b);

            // Per-pixel saturation measure (HSV saturation) to modulate vibrance.
            const hsvSat = max <= 0 ? 0 : (max - min) / max;
            let vibScale = 1;
            if (vibFactor >= 0) vibScale = 1 + vibFactor * (1 - hsvSat);
            else vibScale = 1 + vibFactor;

            const scale = satFactor * vibScale;
            const gray = (r * 0.299 + g * 0.587 + b * 0.114);

            r = gray + (r - gray) * scale;
            g = gray + (g - gray) * scale;
            b = gray + (b - gray) * scale;

            if (r < 0) r = 0; else if (r > 255) r = 255;
            if (g < 0) g = 0; else if (g > 255) g = 255;
            if (b < 0) b = 0; else if (b > 255) b = 255;

            r = (r + 0.5) | 0;
            g = (g + 0.5) | 0;
            b = (b + 0.5) | 0;
          } else {
          let rn = r / 255;
          let gn = g / 255;
          let bn = b / 255;

          const max = rn > gn ? (rn > bn ? rn : bn) : (gn > bn ? gn : bn);
          const min = rn < gn ? (rn < bn ? rn : bn) : (gn < bn ? gn : bn);
          let h = 0;
          let s = 0;
          const l = (max + min) / 2;

          if (max !== min) {
            const d = max - min;
            s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
            if (max === rn) h = (gn - bn) / d + (gn < bn ? 6 : 0);
            else if (max === gn) h = (bn - rn) / d + 2;
            else h = (rn - gn) / d + 4;
            h /= 6;
          }

          // Saturation + vibrance adjustments (same semantics as the original HSL approach)
          s *= satFactor;
          if (vibFactor >= 0) s += (1 - s) * vibFactor;
          else s *= (1 + vibFactor);
          if (s < 0) s = 0; else if (s > 1) s = 1;

          if (s === 0) {
            const v = Math.round(l * 255);
            r = v; g = v; b = v;
          } else {
            const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
            const p = 2 * l - q;
            rn = hue2rgb(p, q, h + 1 / 3);
            gn = hue2rgb(p, q, h);
            bn = hue2rgb(p, q, h - 1 / 3);
            r = Math.round(rn * 255);
            g = Math.round(gn * 255);
            b = Math.round(bn * 255);
          }
          }
        }

        if (doCMY) {
          r -= cmyRShift;
          g -= cmyGShift;
          b -= cmyBShift;

          if (r < 0) r = 0; else if (r > 255) r = 255;
          if (g < 0) g = 0; else if (g > 255) g = 255;
          if (b < 0) b = 0; else if (b > 255) b = 255;
        }

        r = curveR[(r + 0.5) | 0];
        g = curveG[(g + 0.5) | 0];
        b = curveB[(b + 0.5) | 0];

        outData[i] = r;
        outData[i + 1] = g;
        outData[i + 2] = b;
        outData[i + 3] = 255;
      }
    }

    function buildPreviewSourceImageData(imageData) {
      const { width, height, data } = imageData;
      const totalPixels = width * height;
      // Keep interactive preview responsive on slower machines.
      const maxPixels = 250_000;

      if (totalPixels <= maxPixels) return imageData;

      const step = Math.ceil(Math.sqrt(totalPixels / maxPixels));
      const outW = Math.max(1, Math.floor(width / step));
      const outH = Math.max(1, Math.floor(height / step));

      const out = new ImageData(new Uint8ClampedArray(outW * outH * 4), outW, outH);
      const outData = out.data;

      for (let y = 0; y < outH; y++) {
        const sy = Math.min(height - 1, y * step);
        for (let x = 0; x < outW; x++) {
          const sx = Math.min(width - 1, x * step);
          const srcIdx = (sy * width + sx) * 4;
          const dstIdx = (y * outW + x) * 4;
          outData[dstIdx] = data[srcIdx];
          outData[dstIdx + 1] = data[srcIdx + 1];
          outData[dstIdx + 2] = data[srcIdx + 2];
          outData[dstIdx + 3] = 255;
        }
      }

      return out;
    }

    function buildHistogramSourceImageData(imageData) {
      if (!imageData) return null;

      const { width, height, data } = imageData;
      const totalPixels = width * height;
      const maxPixels = HISTOGRAM_MAX_SAMPLES;

      if (totalPixels <= maxPixels) return imageData;

      const step = Math.ceil(Math.sqrt(totalPixels / maxPixels));
      const outW = Math.max(1, Math.floor(width / step));
      const outH = Math.max(1, Math.floor(height / step));

      const out = new ImageData(new Uint8ClampedArray(outW * outH * 4), outW, outH);
      const outData = out.data;

      for (let y = 0; y < outH; y++) {
        const sy = Math.min(height - 1, y * step);
        for (let x = 0; x < outW; x++) {
          const sx = Math.min(width - 1, x * step);
          const srcIdx = (sy * width + sx) * 4;
          const dstIdx = (y * outW + x) * 4;
          outData[dstIdx] = data[srcIdx];
          outData[dstIdx + 1] = data[srcIdx + 1];
          outData[dstIdx + 2] = data[srcIdx + 2];
          outData[dstIdx + 3] = 255;
        }
      }

      return out;
    }

    function buildWebglSourceImageData(imageData, maxDim = 2048) {
      if (!imageData) return null;
      const { width, height, data } = imageData;
      const scale = Math.max(width / maxDim, height / maxDim, 1);
      const step = Math.ceil(scale);
      if (step <= 1) return imageData;

      const outW = Math.max(1, Math.floor(width / step));
      const outH = Math.max(1, Math.floor(height / step));
      const out = new ImageData(new Uint8ClampedArray(outW * outH * 4), outW, outH);
      const outData = out.data;

      for (let y = 0; y < outH; y++) {
        const sy = Math.min(height - 1, y * step);
        for (let x = 0; x < outW; x++) {
          const sx = Math.min(width - 1, x * step);
          const srcIdx = (sy * width + sx) * 4;
          const dstIdx = (y * outW + x) * 4;
          outData[dstIdx] = data[srcIdx];
          outData[dstIdx + 1] = data[srcIdx + 1];
          outData[dstIdx + 2] = data[srcIdx + 2];
          outData[dstIdx + 3] = 255;
        }
      }

      return out;
    }

    // ===========================================
    // Histogram (Lightroom-style)
    // ===========================================
    const HISTOGRAM_BINS = 256;
    const histogramR = new Uint32Array(HISTOGRAM_BINS);
    const histogramG = new Uint32Array(HISTOGRAM_BINS);
    const histogramB = new Uint32Array(HISTOGRAM_BINS);
    const histogramL = new Uint32Array(HISTOGRAM_BINS);
    const histogramSmoothR = new Float32Array(HISTOGRAM_BINS);
    const histogramSmoothG = new Float32Array(HISTOGRAM_BINS);
    const histogramSmoothB = new Float32Array(HISTOGRAM_BINS);
    const histogramSmoothL = new Float32Array(HISTOGRAM_BINS);
    const histogramX = new Float32Array(HISTOGRAM_BINS);
    let histogramXWidth = 0;

    function smoothHistogram(src, dst) {
      dst[0] = (src[0] * 4 + src[1] * 2 + src[2]) / 7;
      for (let i = 1; i < 255; i++) {
        dst[i] = (src[i - 1] + src[i] * 2 + src[i + 1]) * 0.25;
      }
      dst[255] = (src[253] + src[254] * 2 + src[255] * 4) / 7;
    }

    function ensureHistogramX(width) {
      if (histogramXWidth === width) return;
      const scale = (width - 1) / 255;
      for (let i = 0; i < HISTOGRAM_BINS; i++) {
        histogramX[i] = i * scale;
      }
      histogramXWidth = width;
    }

    function renderHistogram(imageData) {
      if (!imageData) return;

      const baseW = histogramCanvas.offsetWidth || histogramCanvas.clientWidth;
      const baseH = histogramCanvas.offsetHeight || histogramCanvas.clientHeight;
      if (baseW <= 0 || baseH <= 0) return;

      const dpr = window.devicePixelRatio || 1;
      const cw = histogramCanvas.width = Math.max(1, Math.round(baseW * dpr));
      const ch = histogramCanvas.height = Math.max(1, Math.round(baseH * dpr));
      ensureHistogramX(cw);

      histogramR.fill(0);
      histogramG.fill(0);
      histogramB.fill(0);
      histogramL.fill(0);

      const { data } = imageData;
      const totalPixels = data.length >> 2;
      const sampleStep = Math.max(1, Math.ceil(totalPixels / HISTOGRAM_MAX_SAMPLES));
      const sampleStride = sampleStep << 2;
      let sampleCount = 0;

      for (let i = 0; i < data.length; i += sampleStride) {
        const r = data[i];
        const g = data[i + 1];
        const b = data[i + 2];
        histogramR[r]++;
        histogramG[g]++;
        histogramB[b]++;
        histogramL[(r * 77 + g * 150 + b * 29) >> 8]++;
        sampleCount++;
      }
      if (sampleCount === 0) return;

      smoothHistogram(histogramR, histogramSmoothR);
      smoothHistogram(histogramG, histogramSmoothG);
      smoothHistogram(histogramB, histogramSmoothB);
      smoothHistogram(histogramL, histogramSmoothL);

      let maxVal = 0;
      for (let i = 0; i < HISTOGRAM_BINS; i++) {
        if (histogramSmoothR[i] > maxVal) maxVal = histogramSmoothR[i];
        if (histogramSmoothG[i] > maxVal) maxVal = histogramSmoothG[i];
        if (histogramSmoothB[i] > maxVal) maxVal = histogramSmoothB[i];
        if (histogramSmoothL[i] > maxVal) maxVal = histogramSmoothL[i];
      }
      if (maxVal <= 0) return;

      const logScale = (ch - dpr * 3) / Math.log1p(maxVal);
      const toY = (value) => ch - Math.log1p(value) * logScale - dpr;

      const bg = histogramCtx.createLinearGradient(0, 0, 0, ch);
      bg.addColorStop(0, '#1b1b1b');
      bg.addColorStop(1, '#0f0f0f');
      histogramCtx.fillStyle = bg;
      histogramCtx.fillRect(0, 0, cw, ch);

      histogramCtx.strokeStyle = 'rgba(255, 255, 255, 0.08)';
      histogramCtx.lineWidth = Math.max(1, dpr * 0.8);
      for (let i = 1; i < 5; i++) {
        const x = (cw * i) / 5;
        histogramCtx.beginPath();
        histogramCtx.moveTo(x, dpr * 2);
        histogramCtx.lineTo(x, ch - dpr * 2);
        histogramCtx.stroke();
      }

      function drawHistogramCurve(values, fillColor, strokeColor, composite) {
        histogramCtx.globalCompositeOperation = composite;
        histogramCtx.beginPath();
        histogramCtx.moveTo(0, ch - dpr);
        for (let i = 0; i < HISTOGRAM_BINS; i++) {
          histogramCtx.lineTo(histogramX[i], toY(values[i]));
        }
        histogramCtx.lineTo(cw - 1, ch - dpr);
        histogramCtx.closePath();
        histogramCtx.fillStyle = fillColor;
        histogramCtx.fill();

        histogramCtx.beginPath();
        histogramCtx.moveTo(0, toY(values[0]));
        for (let i = 1; i < HISTOGRAM_BINS; i++) {
          histogramCtx.lineTo(histogramX[i], toY(values[i]));
        }
        histogramCtx.strokeStyle = strokeColor;
        histogramCtx.lineWidth = Math.max(1, dpr * 0.9);
        histogramCtx.stroke();
      }

      drawHistogramCurve(histogramSmoothL, 'rgba(228, 228, 228, 0.22)', 'rgba(245, 245, 245, 0.42)', 'source-over');
      drawHistogramCurve(histogramSmoothR, 'rgba(255, 90, 90, 0.20)', 'rgba(255, 110, 110, 0.70)', 'lighter');
      drawHistogramCurve(histogramSmoothG, 'rgba(90, 230, 120, 0.20)', 'rgba(120, 245, 145, 0.70)', 'lighter');
      drawHistogramCurve(histogramSmoothB, 'rgba(110, 180, 255, 0.20)', 'rgba(135, 200, 255, 0.72)', 'lighter');
      histogramCtx.globalCompositeOperation = 'source-over';

      const shadowClipRatio = (histogramL[0] + histogramL[1] + histogramL[2]) / sampleCount;
      const highlightClipRatio = (histogramL[253] + histogramL[254] + histogramL[255]) / sampleCount;
      const indicatorSize = Math.max(6, Math.round(7 * dpr));
      const indicatorMargin = Math.max(3, Math.round(4 * dpr));

      if (shadowClipRatio > 0.008) {
        histogramCtx.fillStyle = '#5da9ff';
        histogramCtx.beginPath();
        histogramCtx.moveTo(indicatorMargin, indicatorMargin);
        histogramCtx.lineTo(indicatorMargin + indicatorSize, indicatorMargin);
        histogramCtx.lineTo(indicatorMargin, indicatorMargin + indicatorSize);
        histogramCtx.closePath();
        histogramCtx.fill();
      }

      if (highlightClipRatio > 0.008) {
        histogramCtx.fillStyle = '#ff6f6f';
        histogramCtx.beginPath();
        histogramCtx.moveTo(cw - indicatorMargin, indicatorMargin);
        histogramCtx.lineTo(cw - indicatorMargin - indicatorSize, indicatorMargin);
        histogramCtx.lineTo(cw - indicatorMargin, indicatorMargin + indicatorSize);
        histogramCtx.closePath();
        histogramCtx.fill();
      }
    }

    // ===========================================
    // Curve Editor (Lightroom-style with control points)
    // ===========================================
    let currentCurveChannel = 'r';
    let draggingPoint = null;
    let hoveredPoint = null;

    // Monotonic cubic spline interpolation
    function computeSpline(points) {
      const n = points.length;
      if (n < 2) return (x) => x;

      // Sort points by x
      points = [...points].sort((a, b) => a.x - b.x);

      const xs = points.map(p => p.x);
      const ys = points.map(p => p.y);

      // Calculate slopes
      const dxs = [], dys = [], ms = [];
      for (let i = 0; i < n - 1; i++) {
        dxs.push(xs[i + 1] - xs[i]);
        dys.push(ys[i + 1] - ys[i]);
        ms.push(dys[i] / dxs[i]);
      }

      // Calculate degree-1 coefficients
      const c1s = [ms[0]];
      for (let i = 0; i < dxs.length - 1; i++) {
        const m = ms[i], mNext = ms[i + 1];
        if (m * mNext <= 0) {
          c1s.push(0);
        } else {
          const dx = dxs[i], dxNext = dxs[i + 1], common = dx + dxNext;
          c1s.push(3 * common / ((common + dxNext) / m + (common + dx) / mNext));
        }
      }
      c1s.push(ms[ms.length - 1]);

      // Calculate degree-2 and degree-3 coefficients
      const c2s = [], c3s = [];
      for (let i = 0; i < c1s.length - 1; i++) {
        const c1 = c1s[i], m = ms[i], invDx = 1 / dxs[i], common = c1 + c1s[i + 1] - 2 * m;
        c2s.push((m - c1 - common) * invDx);
        c3s.push(common * invDx * invDx);
      }

      // Return interpolation function
      return function(x) {
        let i = xs.length - 1;
        if (x <= xs[0]) return ys[0];
        if (x >= xs[n - 1]) return ys[n - 1];

        // Binary search
        let low = 0, high = c3s.length - 1;
        while (low <= high) {
          const mid = Math.floor((low + high) / 2);
          if (xs[mid] < x) low = mid + 1;
          else high = mid - 1;
        }
        i = Math.max(0, high);

        const diff = x - xs[i];
        return ys[i] + c1s[i] * diff + c2s[i] * diff * diff + c3s[i] * diff * diff * diff;
      };
    }

    // Update the 256-value curve from control points
    function updateCurveFromPoints(channel) {
      const points = state.curvePoints[channel];
      const curve = state.curves[channel];
      const spline = computeSpline(points);

      for (let i = 0; i < 256; i++) {
        curve[i] = Math.max(0, Math.min(255, Math.round(spline(i))));
      }

      if (webglState.gl) webglState.curveDirty = true;
    }

    function renderCurve() {
      const cw = curveCanvas.width = curveCanvas.offsetWidth * 2;
      const ch = curveCanvas.height = curveCanvas.offsetHeight * 2;

      curveCtx.fillStyle = '#111';
      curveCtx.fillRect(0, 0, cw, ch);

      // Grid lines
      curveCtx.strokeStyle = '#333';
      curveCtx.lineWidth = 1;
      for (let i = 0; i <= 4; i++) {
        const x = (i / 4) * cw;
        const y = (i / 4) * ch;
        curveCtx.beginPath();
        curveCtx.moveTo(x, 0);
        curveCtx.lineTo(x, ch);
        curveCtx.stroke();
        curveCtx.beginPath();
        curveCtx.moveTo(0, y);
        curveCtx.lineTo(cw, y);
        curveCtx.stroke();
      }

      // Diagonal reference line
      curveCtx.strokeStyle = '#444';
      curveCtx.beginPath();
      curveCtx.moveTo(0, ch);
      curveCtx.lineTo(cw, 0);
      curveCtx.stroke();

      // Draw the curve
      const colors = { r: '#ff6b6b', g: '#69db7c', b: '#74c0fc' };
      curveCtx.strokeStyle = colors[currentCurveChannel];
      curveCtx.lineWidth = 2;
      curveCtx.beginPath();

      const curve = state.curves[currentCurveChannel];
      for (let i = 0; i < 256; i++) {
        const x = (i / 255) * cw;
        const y = ch - (curve[i] / 255) * ch;
        if (i === 0) curveCtx.moveTo(x, y);
        else curveCtx.lineTo(x, y);
      }
      curveCtx.stroke();

      // Draw control points
      const points = state.curvePoints[currentCurveChannel];
      points.forEach((point, index) => {
        const px = (point.x / 255) * cw;
        const py = ch - (point.y / 255) * ch;
        const isHovered = hoveredPoint === index;
        const isDragging = draggingPoint === index;

        // Point circle
        curveCtx.beginPath();
        curveCtx.arc(px, py, isHovered || isDragging ? 8 : 6, 0, Math.PI * 2);
        curveCtx.fillStyle = isDragging ? '#fff' : (isHovered ? colors[currentCurveChannel] : '#222');
        curveCtx.fill();
        curveCtx.strokeStyle = colors[currentCurveChannel];
        curveCtx.lineWidth = 2;
        curveCtx.stroke();
      });
    }

    function setCurvePreset(preset) {
      let points;
      switch (preset) {
        case 'linear':
          points = [{ x: 0, y: 0 }, { x: 255, y: 255 }];
          break;
        case 'scurve':
          points = [{ x: 0, y: 0 }, { x: 64, y: 48 }, { x: 192, y: 208 }, { x: 255, y: 255 }];
          break;
        case 'log':
          points = [{ x: 0, y: 0 }, { x: 64, y: 128 }, { x: 128, y: 192 }, { x: 255, y: 255 }];
          break;
        default:
          points = [{ x: 0, y: 0 }, { x: 255, y: 255 }];
      }
      state.curvePoints[currentCurveChannel] = points;
      updateCurveFromPoints(currentCurveChannel);
      renderCurve();
      scheduleFullUpdate();
    }

    document.querySelectorAll('.curve-tab').forEach(tab => {
      tab.addEventListener('click', () => {
        document.querySelectorAll('.curve-tab').forEach(t => t.classList.remove('active'));
        tab.classList.add('active');
        currentCurveChannel = tab.dataset.channel;
        draggingPoint = null;
        hoveredPoint = null;
        renderCurve();
      });
    });

    document.querySelectorAll('.curve-preset-btn').forEach(btn => {
      btn.addEventListener('click', () => setCurvePreset(btn.dataset.preset));
    });

    document.getElementById('resetCurveBtn').addEventListener('click', () => {
      // Reset ALL channels, not just the current one
      ['r', 'g', 'b'].forEach(channel => {
        state.curvePoints[channel] = [{ x: 0, y: 0 }, { x: 255, y: 255 }];
        updateCurveFromPoints(channel);
      });
      renderCurve();
      scheduleFullUpdate();
    });

    // Get canvas position from mouse event
    function getCurvePosition(e) {
      const rect = curveCanvas.getBoundingClientRect();
      const scaleX = curveCanvas.width / rect.width;
      const scaleY = curveCanvas.height / rect.height;
      const canvasX = (e.clientX - rect.left) * scaleX;
      const canvasY = (e.clientY - rect.top) * scaleY;
      return {
        x: Math.max(0, Math.min(255, Math.round((canvasX / curveCanvas.width) * 255))),
        y: Math.max(0, Math.min(255, 255 - Math.round((canvasY / curveCanvas.height) * 255))),
        canvasX,
        canvasY
      };
    }

    // Find point near position
    function findNearPoint(canvasX, canvasY, threshold = 15) {
      const points = state.curvePoints[currentCurveChannel];
      const cw = curveCanvas.width;
      const ch = curveCanvas.height;

      for (let i = 0; i < points.length; i++) {
        const px = (points[i].x / 255) * cw;
        const py = ch - (points[i].y / 255) * ch;
        const dist = Math.sqrt((canvasX - px) ** 2 + (canvasY - py) ** 2);
        if (dist < threshold) return i;
      }
      return -1;
    }

    curveCanvas.addEventListener('mousedown', (e) => {
      const pos = getCurvePosition(e);
      const nearPoint = findNearPoint(pos.canvasX, pos.canvasY);

      if (nearPoint >= 0) {
        // Start dragging existing point
        draggingPoint = nearPoint;
      } else {
        // Add new point
        const points = state.curvePoints[currentCurveChannel];
        const newPoint = { x: pos.x, y: pos.y };

        // Insert in sorted order
        let insertIndex = points.findIndex(p => p.x > pos.x);
        if (insertIndex === -1) insertIndex = points.length;
        points.splice(insertIndex, 0, newPoint);

        draggingPoint = insertIndex;
        updateCurveFromPoints(currentCurveChannel);
      }
      renderCurve();
    });

    curveCanvas.addEventListener('mousemove', (e) => {
      const pos = getCurvePosition(e);

      if (draggingPoint !== null) {
        const points = state.curvePoints[currentCurveChannel];
        const point = points[draggingPoint];

        // Endpoints can only move vertically
        if (draggingPoint === 0) {
          point.y = pos.y;
        } else if (draggingPoint === points.length - 1) {
          point.y = pos.y;
        } else {
          // Middle points: constrain x between neighbors
          const prevX = points[draggingPoint - 1].x + 1;
          const nextX = points[draggingPoint + 1].x - 1;
          point.x = Math.max(prevX, Math.min(nextX, pos.x));
          point.y = pos.y;
        }

        updateCurveFromPoints(currentCurveChannel);
        renderCurve();
        schedulePreviewUpdate();
      } else {
        // Update hover state
        const nearPoint = findNearPoint(pos.canvasX, pos.canvasY);
        if (nearPoint !== hoveredPoint) {
          hoveredPoint = nearPoint;
          renderCurve();
        }
        curveCanvas.style.cursor = nearPoint >= 0 ? 'grab' : 'crosshair';
      }
    });

    curveCanvas.addEventListener('mouseup', () => {
      if (draggingPoint !== null) {
        draggingPoint = null;
        scheduleFullUpdate();
      }
    });

    curveCanvas.addEventListener('mouseleave', () => {
      if (draggingPoint !== null) {
        draggingPoint = null;
        scheduleFullUpdate();
      }
      hoveredPoint = null;
      renderCurve();
    });

    // Double-click to remove point (except endpoints)
    curveCanvas.addEventListener('dblclick', (e) => {
      const pos = getCurvePosition(e);
      const nearPoint = findNearPoint(pos.canvasX, pos.canvasY);

      if (nearPoint > 0 && nearPoint < state.curvePoints[currentCurveChannel].length - 1) {
        state.curvePoints[currentCurveChannel].splice(nearPoint, 1);
        updateCurveFromPoints(currentCurveChannel);
        renderCurve();
        scheduleFullUpdate();
      }
    });

    // Touch-friendly pointer support for iOS Safari. Keep mouse path above unchanged for PC.
    let activeCurvePointerId = null;

    curveCanvas.addEventListener('pointerdown', (e) => {
      if (e.pointerType === 'mouse') return;
      e.preventDefault();

      const pos = getCurvePosition(e);
      const nearPoint = findNearPoint(pos.canvasX, pos.canvasY);

      if (nearPoint >= 0) {
        draggingPoint = nearPoint;
      } else {
        const points = state.curvePoints[currentCurveChannel];
        const newPoint = { x: pos.x, y: pos.y };
        let insertIndex = points.findIndex(p => p.x > pos.x);
        if (insertIndex === -1) insertIndex = points.length;
        points.splice(insertIndex, 0, newPoint);
        draggingPoint = insertIndex;
        updateCurveFromPoints(currentCurveChannel);
      }

      activeCurvePointerId = e.pointerId;
      curveCanvas.setPointerCapture(e.pointerId);
      renderCurve();
    }, { passive: false });

    curveCanvas.addEventListener('pointermove', (e) => {
      if (e.pointerType === 'mouse') return;
      if (activeCurvePointerId !== e.pointerId || draggingPoint === null) return;
      e.preventDefault();

      const pos = getCurvePosition(e);
      const points = state.curvePoints[currentCurveChannel];
      const point = points[draggingPoint];

      if (draggingPoint === 0 || draggingPoint === points.length - 1) {
        point.y = pos.y;
      } else {
        const prevX = points[draggingPoint - 1].x + 1;
        const nextX = points[draggingPoint + 1].x - 1;
        point.x = Math.max(prevX, Math.min(nextX, pos.x));
        point.y = pos.y;
      }

      updateCurveFromPoints(currentCurveChannel);
      renderCurve();
      schedulePreviewUpdate();
    }, { passive: false });

    function finishCurvePointerDrag(pointerId) {
      if (activeCurvePointerId !== pointerId) return;
      if (draggingPoint !== null) {
        draggingPoint = null;
        scheduleFullUpdate();
      }
      if (curveCanvas.hasPointerCapture(pointerId)) {
        curveCanvas.releasePointerCapture(pointerId);
      }
      activeCurvePointerId = null;
    }

    curveCanvas.addEventListener('pointerup', (e) => {
      if (e.pointerType === 'mouse') return;
      finishCurvePointerDrag(e.pointerId);
    });

    curveCanvas.addEventListener('pointercancel', (e) => {
      if (e.pointerType === 'mouse') return;
      finishCurvePointerDrag(e.pointerId);
    });

    // ===========================================
    // Image Processing Pipeline
    // ===========================================
    // WebGL is used to keep Step 3 adjustments responsive (WB/Tone/CMY/Curves) on large scans.
    // CPU rendering is still used for fallback + batch export.

    const webglState = {
      gl: null,
      program: null,
      quadBuffer: null,
      sourceTex: null,
      curveTex: null,
      curveDirty: true,
      sourceDirty: true,
      sourceSize: { w: 0, h: 0 },
      maxTextureSize: 0,
      handlersAttached: false,
      locations: {
        aPos: null,
        uImage: null,
        uCurve: null,
        uWb: null,
        uExposure: null,
        uContrast: null,
        uHighlights: null,
        uShadows: null,
        uTemp: null,
        uTint: null,
        uSat: null,
        uVib: null,
        uCmy: null
      }
    };

    const webglCurveRgba = new Uint8Array(256 * 4);

    function compileShader(gl, type, source) {
      const shader = gl.createShader(type);
      gl.shaderSource(shader, source);
      gl.compileShader(shader);
      if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
        const info = gl.getShaderInfoLog(shader) || 'Unknown shader compile error';
        gl.deleteShader(shader);
        throw new Error(info);
      }
      return shader;
    }

    function createProgram(gl, vsSource, fsSource) {
      const vs = compileShader(gl, gl.VERTEX_SHADER, vsSource);
      const fs = compileShader(gl, gl.FRAGMENT_SHADER, fsSource);
      const program = gl.createProgram();
      gl.attachShader(program, vs);
      gl.attachShader(program, fs);
      gl.linkProgram(program);
      gl.deleteShader(vs);
      gl.deleteShader(fs);
      if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
        const info = gl.getProgramInfoLog(program) || 'Unknown program link error';
        gl.deleteProgram(program);
        throw new Error(info);
      }
      return program;
    }

    function initWebGLRenderer() {
      if (webglState.gl) return true;

      let gl = null;
      try {
        gl = glCanvas.getContext('webgl', {
          alpha: false,
          depth: false,
          stencil: false,
          antialias: false,
          preserveDrawingBuffer: false,
          premultipliedAlpha: false
        });
      } catch {
        gl = null;
      }

      if (!gl) return false;

      const vsSource = `
        attribute vec2 a_pos;
        varying vec2 v_uv;
        void main() {
          v_uv = (a_pos + 1.0) * 0.5;
          gl_Position = vec4(a_pos, 0.0, 1.0);
        }
      `;

      const fsSource = `
        #ifdef GL_FRAGMENT_PRECISION_HIGH
        precision highp float;
        #else
        precision mediump float;
        #endif
        varying vec2 v_uv;
        uniform sampler2D u_image;
        uniform sampler2D u_curve;

        uniform vec3 u_wb;
        uniform float u_exposure;
        uniform float u_contrast;
        uniform float u_highlights;
        uniform float u_shadows;
        uniform float u_temp;
        uniform float u_tint;
        uniform float u_sat;
        uniform float u_vib;
        uniform vec3 u_cmy;

        float hue2rgb(float p, float q, float t) {
          if (t < 0.0) t += 1.0;
          if (t > 1.0) t -= 1.0;
          if (t < 1.0 / 6.0) return p + (q - p) * 6.0 * t;
          if (t < 1.0 / 2.0) return q;
          if (t < 2.0 / 3.0) return p + (q - p) * (2.0 / 3.0 - t) * 6.0;
          return p;
        }

        vec3 rgbToHsl(vec3 c) {
          float r = c.r, g = c.g, b = c.b;
          float maxc = max(r, max(g, b));
          float minc = min(r, min(g, b));
          float h = 0.0;
          float s = 0.0;
          float l = (maxc + minc) * 0.5;

          if (maxc != minc) {
            float d = maxc - minc;
            s = l > 0.5 ? d / (2.0 - maxc - minc) : d / (maxc + minc);

            if (maxc == r) {
              h = (g - b) / d + (g < b ? 6.0 : 0.0);
            } else if (maxc == g) {
              h = (b - r) / d + 2.0;
            } else {
              h = (r - g) / d + 4.0;
            }
            h /= 6.0;
          }

          return vec3(h, s, l);
        }

        vec3 hslToRgb(float h, float s, float l) {
          float r, g, b;
          if (s == 0.0) {
            r = g = b = l;
          } else {
            float q = l < 0.5 ? l * (1.0 + s) : l + s - l * s;
            float p = 2.0 * l - q;
            r = hue2rgb(p, q, h + 1.0 / 3.0);
            g = hue2rgb(p, q, h);
            b = hue2rgb(p, q, h - 1.0 / 3.0);
          }
          return vec3(r, g, b);
        }

        vec3 applyCurves(vec3 c) {
          float rIdx = floor(c.r * 255.0 + 0.5);
          float gIdx = floor(c.g * 255.0 + 0.5);
          float bIdx = floor(c.b * 255.0 + 0.5);
          vec4 cr = texture2D(u_curve, vec2((rIdx + 0.5) / 256.0, 0.5));
          vec4 cg = texture2D(u_curve, vec2((gIdx + 0.5) / 256.0, 0.5));
          vec4 cb = texture2D(u_curve, vec2((bIdx + 0.5) / 256.0, 0.5));
          return vec3(cr.r, cg.g, cb.b);
        }

        void main() {
          vec3 c = texture2D(u_image, v_uv).rgb;

          float exposureMult = pow(2.0, u_exposure);
          c *= u_wb * exposureMult;

          c = (c - 0.5) * u_contrast + 0.5;

          float luma = dot(c, vec3(0.299, 0.587, 0.114));
          if (u_highlights != 0.0 && luma > 0.5) {
            float mult = 1.0 + u_highlights * (luma - 0.5) * 2.0;
            c *= mult;
          }
          if (u_shadows != 0.0 && luma < 0.5) {
            float mult = 1.0 + u_shadows * (0.5 - luma) * 2.0;
            c *= mult;
          }

          c.r *= (1.0 + u_temp * 0.3);
          c.b *= (1.0 - u_temp * 0.3);
          c.g *= (1.0 + u_tint * 0.3);
          c = clamp(c, 0.0, 1.0);

          if (u_sat != 1.0 || u_vib != 0.0) {
            vec3 hsl = rgbToHsl(c);
            float s = hsl.y * u_sat;
            if (u_vib >= 0.0) {
              s += (1.0 - s) * u_vib;
            } else {
              s *= (1.0 + u_vib);
            }
            hsl.y = clamp(s, 0.0, 1.0);
            c = hslToRgb(hsl.x, hsl.y, hsl.z);
          }

          vec3 cmy = vec3(1.0) - c;
          cmy = clamp(cmy + u_cmy, 0.0, 1.0);
          c = vec3(1.0) - cmy;

          c = applyCurves(c);

          gl_FragColor = vec4(c, 1.0);
        }
      `;

      try {
        webglState.program = createProgram(gl, vsSource, fsSource);
      } catch (err) {
        console.warn('WebGL shader init failed:', err);
        return false;
      }

      webglState.gl = gl;
      webglState.maxTextureSize = gl.getParameter(gl.MAX_TEXTURE_SIZE) || 0;

      if (!webglState.handlersAttached) {
        glCanvas.addEventListener('webglcontextlost', (e) => {
          e.preventDefault();
          // Mark renderer as unavailable; fall back to CPU.
          webglState.gl = null;
          webglState.program = null;
          webglState.quadBuffer = null;
          webglState.sourceTex = null;
          webglState.curveTex = null;
          webglState.sourceSize = { w: 0, h: 0 };
          webglState.maxTextureSize = 0;
          webglState.curveDirty = true;
          webglState.sourceDirty = true;
          updateCanvasVisibility();
          schedulePreviewUpdate();
        }, false);

        glCanvas.addEventListener('webglcontextrestored', () => {
          // Resources are lost; re-init lazily on next render.
          webglState.gl = null;
          webglState.program = null;
          webglState.quadBuffer = null;
          webglState.sourceTex = null;
          webglState.curveTex = null;
          webglState.sourceSize = { w: 0, h: 0 };
          webglState.maxTextureSize = 0;
          webglState.curveDirty = true;
          webglState.sourceDirty = true;
          schedulePreviewUpdate();
        }, false);

        webglState.handlersAttached = true;
      }

      // Full-screen quad
      webglState.quadBuffer = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, webglState.quadBuffer);
      gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
        -1, -1,
         1, -1,
        -1,  1,
         1,  1
      ]), gl.STATIC_DRAW);

      gl.useProgram(webglState.program);

      webglState.locations.aPos = gl.getAttribLocation(webglState.program, 'a_pos');
      webglState.locations.uImage = gl.getUniformLocation(webglState.program, 'u_image');
      webglState.locations.uCurve = gl.getUniformLocation(webglState.program, 'u_curve');
      webglState.locations.uWb = gl.getUniformLocation(webglState.program, 'u_wb');
      webglState.locations.uExposure = gl.getUniformLocation(webglState.program, 'u_exposure');
      webglState.locations.uContrast = gl.getUniformLocation(webglState.program, 'u_contrast');
      webglState.locations.uHighlights = gl.getUniformLocation(webglState.program, 'u_highlights');
      webglState.locations.uShadows = gl.getUniformLocation(webglState.program, 'u_shadows');
      webglState.locations.uTemp = gl.getUniformLocation(webglState.program, 'u_temp');
      webglState.locations.uTint = gl.getUniformLocation(webglState.program, 'u_tint');
      webglState.locations.uSat = gl.getUniformLocation(webglState.program, 'u_sat');
      webglState.locations.uVib = gl.getUniformLocation(webglState.program, 'u_vib');
      webglState.locations.uCmy = gl.getUniformLocation(webglState.program, 'u_cmy');

      // Textures
      webglState.sourceTex = gl.createTexture();
      gl.bindTexture(gl.TEXTURE_2D, webglState.sourceTex);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);

      webglState.curveTex = gl.createTexture();
      gl.bindTexture(gl.TEXTURE_2D, webglState.curveTex);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);

      // Bind samplers
      gl.uniform1i(webglState.locations.uImage, 0);
      gl.uniform1i(webglState.locations.uCurve, 1);

      gl.disable(gl.DEPTH_TEST);
      gl.disable(gl.BLEND);

      webglState.curveDirty = true;
      webglState.sourceDirty = true;

      return true;
    }

    function isWebGLActive() {
      return !!webglState.gl && state.currentStep >= 3 && !!state.processedImageData;
    }

    function resizeWebGLCanvas() {
      if (!webglState.gl) return;
      const rect = glCanvas.getBoundingClientRect();
      if (rect.width <= 0 || rect.height <= 0) return;

      const dpr = window.devicePixelRatio || 1;
      let targetW = Math.max(1, Math.round(rect.width * dpr));
      let targetH = Math.max(1, Math.round(rect.height * dpr));

      // Limit interactive draw resolution to keep things smooth on very large displays.
      const maxDim = 2048;
      const maxCurrent = Math.max(targetW, targetH);
      if (maxCurrent > maxDim) {
        const scale = maxDim / maxCurrent;
        targetW = Math.max(1, Math.floor(targetW * scale));
        targetH = Math.max(1, Math.floor(targetH * scale));
      }

      if (glCanvas.width !== targetW) glCanvas.width = targetW;
      if (glCanvas.height !== targetH) glCanvas.height = targetH;
    }

    function getWebglSourceImageData() {
      const full = state.processedImageData;
      if (!full) return null;

      const maxTex = webglState.maxTextureSize || 0;
      const targetMaxDim = Math.min(2048, maxTex || 2048);

      let src = state.webglSourceImageData;
      if (!src || src.width !== Math.min(src.width, targetMaxDim) || src.height !== Math.min(src.height, targetMaxDim)) {
        // If cached source is missing or too large for the current device, rebuild from full-res.
        src = buildWebglSourceImageData(full, targetMaxDim);
        state.webglSourceImageData = src;
      }

      // Safety: if the result still doesn't fit (very old GPUs), force it down.
      if (maxTex && (src.width > maxTex || src.height > maxTex)) {
        src = buildWebglSourceImageData(full, maxTex);
        state.webglSourceImageData = src;
      }

      return src;
    }

    function webglUploadSource(imageData) {
      if (!webglState.gl) return;
      if (!imageData) return;

      const gl = webglState.gl;
      gl.activeTexture(gl.TEXTURE0);
      gl.bindTexture(gl.TEXTURE_2D, webglState.sourceTex);
      gl.pixelStorei(gl.UNPACK_ALIGNMENT, 1);
      gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
      gl.texImage2D(
        gl.TEXTURE_2D,
        0,
        gl.RGBA,
        imageData.width,
        imageData.height,
        0,
        gl.RGBA,
        gl.UNSIGNED_BYTE,
        imageData.data
      );
      webglState.sourceSize.w = imageData.width;
      webglState.sourceSize.h = imageData.height;
      webglState.sourceDirty = false;
    }

    function webglUploadCurves() {
      if (!webglState.gl) return;
      const gl = webglState.gl;

      for (let i = 0; i < 256; i++) {
        const idx = i * 4;
        webglCurveRgba[idx] = state.curves.r[i];
        webglCurveRgba[idx + 1] = state.curves.g[i];
        webglCurveRgba[idx + 2] = state.curves.b[i];
        webglCurveRgba[idx + 3] = 255;
      }

      gl.activeTexture(gl.TEXTURE1);
      gl.bindTexture(gl.TEXTURE_2D, webglState.curveTex);
      gl.pixelStorei(gl.UNPACK_ALIGNMENT, 1);
      gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);
      gl.texImage2D(
        gl.TEXTURE_2D,
        0,
        gl.RGBA,
        256,
        1,
        0,
        gl.RGBA,
        gl.UNSIGNED_BYTE,
        webglCurveRgba
      );

      webglState.curveDirty = false;
    }

    function webglSetUniforms() {
      const gl = webglState.gl;
      if (!gl) return;

      const preset = getPresetOrFallback(state.filmPreset, state.filmType);
      const presetChars = (preset && preset.characteristics) ? preset.characteristics : {};

      const exposure = state.exposure;
      const contrast = 1 + ((state.contrast + (presetChars.contrast || 0) * 100) / 100);
      const highlights = state.highlights / 100;
      const shadows = state.shadows / 100;
      const tempFactor = (state.temperature + (presetChars.warmth || 0) * 100) / 100;
      const tintFactor = state.tint / 100;
      const satFactor = 1 + ((state.saturation + (presetChars.saturation || 0) * 100) / 100);
      const vibFactor = state.vibrance / 100;

      gl.uniform3f(webglState.locations.uWb, state.wbR, state.wbG, state.wbB);
      gl.uniform1f(webglState.locations.uExposure, exposure);
      gl.uniform1f(webglState.locations.uContrast, contrast);
      gl.uniform1f(webglState.locations.uHighlights, highlights);
      gl.uniform1f(webglState.locations.uShadows, shadows);
      gl.uniform1f(webglState.locations.uTemp, tempFactor);
      gl.uniform1f(webglState.locations.uTint, tintFactor);
      gl.uniform1f(webglState.locations.uSat, satFactor);
      gl.uniform1f(webglState.locations.uVib, vibFactor);
      gl.uniform3f(webglState.locations.uCmy, state.cyan / 100, state.magenta / 100, state.yellow / 100);
    }

    function renderWebGL() {
      if (!webglState.gl || !state.processedImageData) return;

      resizeWebGLCanvas();

      const gl = webglState.gl;
      gl.viewport(0, 0, glCanvas.width, glCanvas.height);
      gl.useProgram(webglState.program);

      // Uploads if needed
      const source = getWebglSourceImageData();
      if (!source) return;
      if (webglState.sourceDirty || webglState.sourceSize.w !== source.width || webglState.sourceSize.h !== source.height) {
        webglUploadSource(source);
      }
      if (webglState.curveDirty) {
        webglUploadCurves();
      }

      // Bind geometry
      gl.bindBuffer(gl.ARRAY_BUFFER, webglState.quadBuffer);
      gl.enableVertexAttribArray(webglState.locations.aPos);
      gl.vertexAttribPointer(webglState.locations.aPos, 2, gl.FLOAT, false, 0, 0);

      // Bind textures
      gl.activeTexture(gl.TEXTURE0);
      gl.bindTexture(gl.TEXTURE_2D, webglState.sourceTex);
      gl.activeTexture(gl.TEXTURE1);
      gl.bindTexture(gl.TEXTURE_2D, webglState.curveTex);

      webglSetUniforms();

      gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
    }

    function updateCanvasVisibility() {
      const showGL = isWebGLActive();
      glCanvas.style.display = showGL ? 'block' : 'none';
      canvas.style.display = showGL ? 'none' : 'block';
      if (showGL) renderWebGL();
    }

    let updateScheduled = false;
    let fullUpdateTimer = null;

    const previewCanvas = document.createElement('canvas');
    const previewCtx = previewCanvas.getContext('2d', { willReadFrequently: true });
    let fullAdjustedBuffer = null;
    let previewAdjustedBuffer = null;
    let histogramAdjustedBuffer = null;
    let lastHistogramUpdateTime = 0;

    function renderHistogramForWebGL(force = false) {
      if (!state.processedImageData) return;
      const now = performance.now();
      if (!force && (now - lastHistogramUpdateTime) < HISTOGRAM_UPDATE_INTERVAL_MS) return;

      const source = state.histogramSourceImageData || state.previewSourceImageData || state.processedImageData;
      histogramAdjustedBuffer = ensureImageDataBuffer(histogramAdjustedBuffer, source.width, source.height);
      applyAdjustmentsToBuffer(source, state, histogramAdjustedBuffer, 'preview');
      renderHistogram(histogramAdjustedBuffer);
      lastHistogramUpdateTime = now;
    }

    function schedulePreviewUpdate() {
      if (!updateScheduled) {
        updateScheduled = true;
        requestAnimationFrame(() => {
          updatePreview();
          updateScheduled = false;
        });
      }
    }

    function scheduleFullUpdate() {
      if (fullUpdateTimer) clearTimeout(fullUpdateTimer);
      // Full-res CPU rendering can be expensive on large scans; debounce aggressively.
      fullUpdateTimer = setTimeout(() => {
        updateFull();
        fullUpdateTimer = null;
      }, 1200);
    }

    function updatePreview() {
      if (!state.processedImageData) return;

      // Prefer GPU rendering in Step 3 when available.
      if (state.currentStep >= 3 && initWebGLRenderer()) {
        updateCanvasVisibility();
        renderWebGL();
        renderHistogramForWebGL(false);
        state.lastRenderQuality = 'gl';
        return;
      }

      updatePreviewCpu();
    }

    function updatePreviewCpu() {
      if (!state.processedImageData) return;

      const source = state.previewSourceImageData || state.processedImageData;
      previewAdjustedBuffer = ensureImageDataBuffer(previewAdjustedBuffer, source.width, source.height);
      applyAdjustmentsToBuffer(source, state, previewAdjustedBuffer, 'preview');

      if (source !== state.processedImageData) {
        if (previewCanvas.width !== source.width) previewCanvas.width = source.width;
        if (previewCanvas.height !== source.height) previewCanvas.height = source.height;
        previewCtx.putImageData(previewAdjustedBuffer, 0, 0);

        ctx.imageSmoothingEnabled = true;
        ctx.drawImage(previewCanvas, 0, 0, canvas.width, canvas.height);
        state.lastRenderQuality = 'preview';
      } else {
        ctx.putImageData(previewAdjustedBuffer, 0, 0);
        state.displayImageData = previewAdjustedBuffer;
        state.lastRenderQuality = 'full';
      }
      // Histogram updates are deferred to full renders for responsiveness.
    }

    function updateFull() {
      if (!state.processedImageData) return;

      // Prefer GPU rendering in Step 3 when available.
      if (state.currentStep >= 3 && initWebGLRenderer()) {
        updateCanvasVisibility();
        renderWebGL();
        renderHistogramForWebGL(true);
        state.lastRenderQuality = 'gl';
        return;
      }

      updateFullCpu();
    }

    function updateFullCpu() {
      if (!state.processedImageData) return;

      const source = state.processedImageData;
      fullAdjustedBuffer = ensureImageDataBuffer(fullAdjustedBuffer, source.width, source.height);
      applyAdjustmentsToBuffer(source, state, fullAdjustedBuffer, 'full');
      state.displayImageData = fullAdjustedBuffer;
      ctx.putImageData(fullAdjustedBuffer, 0, 0);
      renderHistogram(fullAdjustedBuffer);

      transformCanvas.width = canvas.width;
      transformCanvas.height = canvas.height;
      transformCtx.putImageData(fullAdjustedBuffer, 0, 0);
      state.lastRenderQuality = 'full';
    }

    function ensureFullRender() {
      if (!state.processedImageData) return;
      // Always compute full-res on CPU for export/batch correctness.
      updateFullCpu();
    }

    function processNegative() {
      const sourceData = state.croppedImageData || state.originalImageData;
      if (!sourceData) return;

      let processed;
      const preset = getPresetOrFallback(state.filmPreset, state.filmType);
      const presetType = (preset && preset.type) ? preset.type : state.filmType;

      if (state.filmType === 'positive' || presetType === 'positive') {
        processed = convertPositiveFilm(sourceData);
      } else if (state.filmType === 'bw' || presetType === 'bw') {
        const bwParams = getBwPresetParams(preset);
        processed = convertBWNegative(sourceData, {
          contrast: bwParams.contrast,
          gamma: bwParams.gamma
        });
      } else {
        processed = convertColorNegative(sourceData, state.filmBase);
      }

      state.processedImageData = processed;
      state.previewSourceImageData = buildPreviewSourceImageData(processed);
      state.histogramSourceImageData = buildHistogramSourceImageData(state.previewSourceImageData || processed);
      state.webglSourceImageData = buildWebglSourceImageData(processed);
      if (initWebGLRenderer()) {
        webglState.sourceDirty = true;
        webglState.curveDirty = true;
      }
      canvas.width = processed.width;
      canvas.height = processed.height;
      goToStep(3);
      updateFull();
    }

    // ===========================================
    // Canvas Display
    // ===========================================
    function adjustCanvasDisplay(w, h) {
      const container = document.getElementById('canvasContainer');
      const maxWidth = container.clientWidth - 20;
      const maxHeight = container.clientHeight - 20;
      const scale = Math.min(maxWidth / w, maxHeight / h, 1);
      const cssW = (w * scale) + 'px';
      const cssH = (h * scale) + 'px';
      canvas.style.width = cssW;
      canvas.style.height = cssH;
      glCanvas.style.width = cssW;
      glCanvas.style.height = cssH;
      if (isWebGLActive()) resizeWebGLCanvas();
    }

    function displayNegative(imageData) {
      canvas.width = imageData.width;
      canvas.height = imageData.height;
      ctx.putImageData(imageData, 0, 0);
      adjustCanvasDisplay(imageData.width, imageData.height);

      transformCanvas.width = imageData.width;
      transformCanvas.height = imageData.height;
      transformCtx.putImageData(imageData, 0, 0);
    }

    // ===========================================
    // File Loading
    // ===========================================
    async function loadFile(file) {
      const placeholder = document.getElementById('uploadPlaceholder');
      placeholder.innerHTML = `<p>${i18n[currentLang].processing}</p>`;
      const fileName = file.name.toLowerCase();
      const isRawLikeFile = ['.cr2', '.nef', '.arw', '.dng', '.raw', '.rw2', '.tif', '.tiff'].some(ext => fileName.endsWith(ext));

      try {
        const arrayBuffer = await file.arrayBuffer();

        let imageData;

        if (isRawLikeFile) {
          imageData = await loadRawFile(arrayBuffer, fileName);
        } else if (file.type === 'image/png') {
          imageData = loadPngFile(arrayBuffer);
        } else {
          imageData = await loadStandardImage(file);
        }

        if (imageData) {
          state.originalImageData = imageData;
          state.croppedImageData = null;
          state.processedImageData = null;
          state.displayImageData = null;
          state.previewSourceImageData = null;
          state.histogramSourceImageData = null;
          state.webglSourceImageData = null;
          state.lastRenderQuality = 'full';
          state.filmBaseSet = false;
          if (webglState.gl) {
            webglState.sourceDirty = true;
            webglState.sourceSize = { w: 0, h: 0 };
          }

          displayNegative(imageData);
          showImageUI();
          goToStep(1);
        }
      } catch (err) {
        console.error('Error loading file:', err);
        const text = String(err?.message || err || '');
        const isRawSupportIssue = isRawLikeFile && /module worker|worker|webassembly|wasm/i.test(text);
        const message = isRawSupportIssue
          ? (i18n[currentLang].rawUnsupported || 'RAW decode is not supported in this Safari version. Update Safari or convert to TIFF/JPEG first.')
          : (i18n[currentLang].loadError || 'Error loading file');
        placeholder.innerHTML = `<p style="color: var(--danger);">${message}</p>`;
      }
    }

    async function loadRawFile(buffer, fileName) {
      // Handle TIF/TIFF files directly with UTIF.js
      if (fileName.endsWith('.tif') || fileName.endsWith('.tiff')) {
        try {
          const ifds = UTIF.decode(buffer);
          UTIF.decodeImage(buffer, ifds[0]);
          const rgba = UTIF.toRGBA8(ifds[0]);
          return new ImageData(new Uint8ClampedArray(rgba), ifds[0].width, ifds[0].height);
        } catch (err) {
          console.error('UTIF.js failed for TIFF:', err);
          throw err;
        }
      }

      // Handle iPhone DNG (ProRaw) with UTIF.js
      if (fileName.endsWith('.dng')) {
        const textSnippet = new TextDecoder().decode(buffer.slice(0, 1000));
        if (textSnippet.includes('iPhone')) {
          try {
            const ifds = UTIF.decode(buffer);
            UTIF.decodeImage(buffer, ifds[0]);
            const rgba = UTIF.toRGBA8(ifds[0]);
            return new ImageData(new Uint8ClampedArray(rgba), ifds[0].width, ifds[0].height);
          } catch (err) {
            console.error('UTIF.js failed:', err);
          }
        }
      }

      let raw;
      try {
        raw = new LibRaw();
      } catch (err) {
        throw new Error(`module worker not supported: ${err?.message || err}`);
      }
      await raw.open(new Uint8Array(buffer), {
        noInterpolation: false,
        useAutoWb: true,
        useCameraWb: true,
        useCameraMatrix: 3,
        outputColor: 1,
        outputBps: 8
      });

      const result = await raw.imageData();
      const { width, height, data: rgbData } = result;

      const pixelCount = width * height;
      const rgbaData = new Uint8ClampedArray(pixelCount * 4);
      for (let i = 0; i < pixelCount; i++) {
        rgbaData[i * 4] = rgbData[i * 3];
        rgbaData[i * 4 + 1] = rgbData[i * 3 + 1];
        rgbaData[i * 4 + 2] = rgbData[i * 3 + 2];
        rgbaData[i * 4 + 3] = 255;
      }

      return new ImageData(rgbaData, width, height);
    }

    function loadPngFile(buffer) {
      const decoded = UPNG.decode(buffer);
      const { width, height, ctype, depth, data } = decoded;

      const channelCount = (ctype & 2 ? 3 : 1) + (ctype & 4 ? 1 : 0);
      const pixelCount = width * height;

      let raw16 = new Uint16Array(pixelCount * channelCount);
      if (depth <= 8) {
        for (let i = 0; i < raw16.length; i++) raw16[i] = data[i] * 257;
      } else {
        for (let i = 0; i < raw16.length; i++) raw16[i] = (data[2 * i] << 8) | data[2 * i + 1];
      }

      const final8 = new Uint8ClampedArray(pixelCount * 4);
      for (let i = 0; i < pixelCount; i++) {
        const idx16 = i * channelCount;
        const idx8 = i * 4;
        final8[idx8] = raw16[idx16] >>> 8;
        if (channelCount >= 3) {
          final8[idx8 + 1] = raw16[idx16 + 1] >>> 8;
          final8[idx8 + 2] = raw16[idx16 + 2] >>> 8;
        } else {
          final8[idx8 + 1] = final8[idx8];
          final8[idx8 + 2] = final8[idx8];
        }
        final8[idx8 + 3] = channelCount === 4 ? (raw16[idx16 + 3] >>> 8) : 255;
      }

      return new ImageData(final8, width, height);
    }

    async function loadStandardImage(file) {
      return new Promise((resolve, reject) => {
        const img = new Image();
        img.onload = () => {
          const tempCanvas = document.createElement('canvas');
          tempCanvas.width = img.width;
          tempCanvas.height = img.height;
          const tempCtx = tempCanvas.getContext('2d');
          tempCtx.drawImage(img, 0, 0);
          resolve(tempCtx.getImageData(0, 0, img.width, img.height));
        };
        img.onerror = reject;
        img.src = URL.createObjectURL(file);
      });
    }

    function showImageUI() {
      document.getElementById('uploadPlaceholder').style.display = 'none';
      document.getElementById('previewToolbar').style.display = 'flex';
      document.getElementById('histogramContainer').style.display = 'block';
      document.getElementById('controlsPanel').style.display = 'flex';
      document.getElementById('appFooter').style.display = 'flex';

      updateCanvasVisibility();
      adjustCanvasDisplay(canvas.width, canvas.height);
    }

    // ===========================================
    // Film Base Sampling
    // ===========================================
    function requiresFilmBase(preset = getPresetOrFallback(state.filmPreset, state.filmType)) {
      return (preset?.type || state.filmType) === 'color';
    }

    function updateFilmModeUI() {
      const filmBaseControls = document.getElementById('filmBaseControls');
      const positiveFilmInfo = document.getElementById('positiveFilmInfo');
      const showFilmBase = requiresFilmBase();

      filmBaseControls.style.display = showFilmBase ? 'block' : 'none';
      positiveFilmInfo.style.display = showFilmBase ? 'none' : 'block';

      if (!showFilmBase) {
        if (state.samplingMode === 'filmBase') {
          state.samplingMode = null;
          document.getElementById('sampleBaseBtn').classList.remove('active');
          canvas.style.cursor = 'default';
          glCanvas.style.cursor = 'default';
          hideLoupe();
        }
        document.getElementById('filmBasePreview').style.display = 'none';
        return;
      }

      updateFilmBasePreview();
    }

    function updateFilmBasePreview() {
      const preview = document.getElementById('filmBasePreview');
      const colorBox = document.getElementById('filmBaseColor');
      const values = document.getElementById('filmBaseValues');

      if (!requiresFilmBase()) {
        preview.style.display = 'none';
        return;
      }

      if (state.filmBaseSet) {
        preview.style.display = 'flex';
        colorBox.style.backgroundColor = `rgb(${state.filmBase.r}, ${state.filmBase.g}, ${state.filmBase.b})`;
        values.textContent = `R: ${state.filmBase.r} G: ${state.filmBase.g} B: ${state.filmBase.b}`;
      } else {
        preview.style.display = 'none';
      }
    }

    document.getElementById('sampleBaseBtn').addEventListener('click', () => {
      if (!requiresFilmBase()) return;
      state.samplingMode = 'filmBase';
      document.getElementById('sampleBaseBtn').classList.add('active');
      canvas.style.cursor = 'crosshair';
      glCanvas.style.cursor = 'crosshair';
    });

    document.getElementById('autoDetectBtn').addEventListener('click', () => {
      if (!requiresFilmBase()) return;
      const sourceData = state.croppedImageData || state.originalImageData;
      if (!sourceData) return;
      state.filmBase = autoDetectFilmBase(sourceData);
      state.filmBaseSet = true;
      updateFilmBasePreview();
    });

    document.getElementById('applyConvertBtn').addEventListener('click', () => {
      if (requiresFilmBase() && !state.filmBaseSet) {
        // Auto detect if not set
        const sourceData = state.croppedImageData || state.originalImageData;
        state.filmBase = autoDetectFilmBase(sourceData);
        state.filmBaseSet = true;
        updateFilmBasePreview();
      }
      processNegative();
    });

    // ===========================================
    // White Balance Sampling
    // ===========================================
    document.getElementById('sampleWBBtn').addEventListener('click', () => {
      state.samplingMode = 'whiteBalance';
      document.getElementById('sampleWBBtn').classList.add('active');
      canvas.style.cursor = 'crosshair';
      glCanvas.style.cursor = 'crosshair';
    });

    // ===========================================
    // Sampling Loupe (Magnifier)
    // ===========================================
    const LOUPE_PATCH_SIZE = 31;
    const LOUPE_HALF = (LOUPE_PATCH_SIZE - 1) / 2;
    const loupePatchData = new Uint8ClampedArray(LOUPE_PATCH_SIZE * LOUPE_PATCH_SIZE * 4);
    const loupePatch = new ImageData(loupePatchData, LOUPE_PATCH_SIZE, LOUPE_PATCH_SIZE);
    const loupePatchAdjustedData = new Uint8ClampedArray(LOUPE_PATCH_SIZE * LOUPE_PATCH_SIZE * 4);
    const loupePatchAdjusted = new ImageData(loupePatchAdjustedData, LOUPE_PATCH_SIZE, LOUPE_PATCH_SIZE);

    loupeSrcCanvas.width = LOUPE_PATCH_SIZE;
    loupeSrcCanvas.height = LOUPE_PATCH_SIZE;

    let loupeRaf = 0;
    let loupePending = null;

    function clampBetween(v, min, max) {
      if (v < min) return min;
      if (v > max) return max;
      return v;
    }

    function showLoupe() {
      loupe.style.display = 'block';
    }

    function hideLoupe() {
      if (loupeRaf) cancelAnimationFrame(loupeRaf);
      loupeRaf = 0;
      loupePending = null;
      loupe.style.display = 'none';
      loupeInfo.textContent = '';
    }

    function positionLoupe(clientX, clientY) {
      const containerRect = canvasContainer.getBoundingClientRect();
      const loupeRect = loupe.getBoundingClientRect();

      const offset = 18;
      const margin = 6;
      let left = clientX - containerRect.left + offset;
      let top = clientY - containerRect.top + offset;

      if (left + loupeRect.width + margin > containerRect.width) {
        left = clientX - containerRect.left - loupeRect.width - offset;
      }
      if (top + loupeRect.height + margin > containerRect.height) {
        top = clientY - containerRect.top - loupeRect.height - offset;
      }

      const maxLeft = Math.max(margin, containerRect.width - loupeRect.width - margin);
      const maxTop = Math.max(margin, containerRect.height - loupeRect.height - margin);
      loupe.style.left = clampBetween(left, margin, maxLeft) + 'px';
      loupe.style.top = clampBetween(top, margin, maxTop) + 'px';
    }

    function fillLoupePatchFromSource(sourceData, cx, cy) {
      const { width, height, data } = sourceData;
      let dstIdx = 0;
      for (let py = 0; py < LOUPE_PATCH_SIZE; py++) {
        const sy = clampBetween(cy + py - LOUPE_HALF, 0, height - 1);
        const row = sy * width * 4;
        for (let px = 0; px < LOUPE_PATCH_SIZE; px++) {
          const sx = clampBetween(cx + px - LOUPE_HALF, 0, width - 1);
          const srcIdx = row + sx * 4;
          loupePatchData[dstIdx] = data[srcIdx];
          loupePatchData[dstIdx + 1] = data[srcIdx + 1];
          loupePatchData[dstIdx + 2] = data[srcIdx + 2];
          loupePatchData[dstIdx + 3] = 255;
          dstIdx += 4;
        }
      }
    }

    function drawLoupeOverlay() {
      const pixelSize = loupeCanvas.width / LOUPE_PATCH_SIZE;
      const center = LOUPE_HALF * pixelSize + pixelSize / 2;
      const centerPixel = LOUPE_HALF * pixelSize;

	      // Center pixel outline
	      loupeCtx.lineWidth = 2;
	      loupeCtx.strokeStyle = 'rgba(0, 0, 0, 0.9)';
	      loupeCtx.strokeRect(centerPixel, centerPixel, pixelSize, pixelSize);
	      loupeCtx.lineWidth = 1;
	      loupeCtx.strokeStyle = 'rgba(255, 255, 255, 0.95)';
	      loupeCtx.strokeRect(centerPixel + 0.5, centerPixel + 0.5, pixelSize - 1, pixelSize - 1);

      // Crosshair (with outline for contrast)
      loupeCtx.lineCap = 'butt';
      loupeCtx.beginPath();
      loupeCtx.lineWidth = 3;
      loupeCtx.strokeStyle = 'rgba(0, 0, 0, 0.85)';
      loupeCtx.moveTo(center, 0);
      loupeCtx.lineTo(center, loupeCanvas.height);
      loupeCtx.moveTo(0, center);
      loupeCtx.lineTo(loupeCanvas.width, center);
      loupeCtx.stroke();

      loupeCtx.beginPath();
      loupeCtx.lineWidth = 1;
      loupeCtx.strokeStyle = 'rgba(255, 255, 255, 0.95)';
      loupeCtx.moveTo(center, 0);
      loupeCtx.lineTo(center, loupeCanvas.height);
      loupeCtx.moveTo(0, center);
      loupeCtx.lineTo(loupeCanvas.width, center);
      loupeCtx.stroke();
    }

    function updateLoupe() {
      loupeRaf = 0;
      const pending = loupePending;
      loupePending = null;

      if (!pending || !state.samplingMode || state.cropping) {
        hideLoupe();
        return;
      }

      const target = pending.target;
      const rect = target.getBoundingClientRect();
      if (rect.width <= 0 || rect.height <= 0) {
        hideLoupe();
        return;
      }

      const relX = (pending.clientX - rect.left) / rect.width;
      const relY = (pending.clientY - rect.top) / rect.height;
      if (relX < 0 || relX > 1 || relY < 0 || relY > 1) {
        hideLoupe();
        return;
      }

      let sourceData = null;
      const showAdjusted = state.samplingMode === 'whiteBalance';
      if (state.samplingMode === 'filmBase') {
        sourceData = state.croppedImageData || state.originalImageData;
      } else if (state.samplingMode === 'whiteBalance') {
        sourceData = state.processedImageData;
      }
      if (!sourceData) {
        hideLoupe();
        return;
      }

      const cx = clampBetween(Math.floor(relX * sourceData.width), 0, sourceData.width - 1);
      const cy = clampBetween(Math.floor(relY * sourceData.height), 0, sourceData.height - 1);

      fillLoupePatchFromSource(sourceData, cx, cy);

      let centerR = 0, centerG = 0, centerB = 0;
      const centerIdx = (LOUPE_HALF * LOUPE_PATCH_SIZE + LOUPE_HALF) * 4;

      if (showAdjusted) {
        applyAdjustmentsToBuffer(loupePatch, state, loupePatchAdjusted, 'full');
        loupeSrcCtx.putImageData(loupePatchAdjusted, 0, 0);
        centerR = loupePatchAdjustedData[centerIdx];
        centerG = loupePatchAdjustedData[centerIdx + 1];
        centerB = loupePatchAdjustedData[centerIdx + 2];
      } else {
        loupeSrcCtx.putImageData(loupePatch, 0, 0);
        centerR = loupePatchData[centerIdx];
        centerG = loupePatchData[centerIdx + 1];
        centerB = loupePatchData[centerIdx + 2];
      }

      loupeCtx.imageSmoothingEnabled = false;
      loupeCtx.clearRect(0, 0, loupeCanvas.width, loupeCanvas.height);
      loupeCtx.drawImage(loupeSrcCanvas, 0, 0, loupeCanvas.width, loupeCanvas.height);
      drawLoupeOverlay();

      loupeInfo.textContent = `x ${cx}  y ${cy}   RGB ${centerR} ${centerG} ${centerB}`;

      showLoupe();
      positionLoupe(pending.clientX, pending.clientY);
    }

    function handleLoupePointer(e) {
      if (!state.samplingMode || state.cropping) {
        hideLoupe();
        return;
      }

      loupePending = {
        clientX: e.clientX,
        clientY: e.clientY,
        target: e.currentTarget
      };

      if (!loupeRaf) {
        loupeRaf = requestAnimationFrame(updateLoupe);
      }
    }

    [canvas, glCanvas].forEach(el => {
      el.addEventListener('pointermove', handleLoupePointer);
      el.addEventListener('pointerdown', handleLoupePointer);
      el.addEventListener('pointerleave', hideLoupe);
      el.addEventListener('pointercancel', hideLoupe);
    });

    // ===========================================
    // Canvas Click Handler (Sampling)
    // ===========================================
    function handleSamplingClick(e) {
      if (state.cropping) return;
      if (!state.samplingMode) return;

      const target = e.currentTarget;
      const rect = target.getBoundingClientRect();
      if (rect.width <= 0 || rect.height <= 0) return;

      const relX = (e.clientX - rect.left) / rect.width;
      const relY = (e.clientY - rect.top) / rect.height;
      if (relX < 0 || relX > 1 || relY < 0 || relY > 1) return;

      if (state.samplingMode === 'filmBase') {
        const sourceData = state.croppedImageData || state.originalImageData;
        if (!sourceData) return;

        const x = Math.floor(relX * sourceData.width);
        const y = Math.floor(relY * sourceData.height);

        state.filmBase = sampleFilmBase(sourceData, x, y, 10);
        state.filmBaseSet = true;
        state.samplingMode = null;
        document.getElementById('sampleBaseBtn').classList.remove('active');
        canvas.style.cursor = 'default';
        glCanvas.style.cursor = 'default';
        hideLoupe();
        updateFilmBasePreview();
      } else if (state.samplingMode === 'whiteBalance') {
        // Sample from processed image (post-inversion)
        if (!state.processedImageData) return;

        const x = Math.floor(relX * state.processedImageData.width);
        const y = Math.floor(relY * state.processedImageData.height);

        const sample = sampleFilmBase(state.processedImageData, x, y, 5);
        const gray = (sample.r + sample.g + sample.b) / 3;

        // Calculate multipliers to make sampled point neutral
        state.wbR = sample.r > 0 ? gray / sample.r : 1;
        state.wbG = sample.g > 0 ? gray / sample.g : 1;
        state.wbB = sample.b > 0 ? gray / sample.b : 1;

        // Normalize so G=1
        const norm = state.wbG;
        state.wbR /= norm;
        state.wbG = 1;
        state.wbB /= norm;

        state.samplingMode = null;
        document.getElementById('sampleWBBtn').classList.remove('active');
        canvas.style.cursor = 'default';
        glCanvas.style.cursor = 'default';
        hideLoupe();
        updateWBSliders();
        updateFull();
      }
    }

    canvas.addEventListener('click', handleSamplingClick);
    glCanvas.addEventListener('click', handleSamplingClick);

    // ===========================================
    // Film Type & Preset Selection
    // ===========================================
    function setFilmTypeButtons(type) {
      document.querySelectorAll('.film-type-btn').forEach(btn => {
        btn.classList.toggle('active', btn.dataset.type === type);
      });
    }

    document.querySelectorAll('.film-type-btn').forEach(btn => {
      btn.addEventListener('click', () => {
        state.filmType = btn.dataset.type;

        const defaultPreset = getDefaultPresetForType(state.filmType);
        state.filmPreset = defaultPreset;
        renderPresetOptions(state.filmPreset);
        setFilmTypeButtons(state.filmType);
        updateFilmModeUI();

        schedulePreviewUpdate();
      });
    });

    document.getElementById('filmPreset').addEventListener('change', (e) => {
      const preset = getPresetOrFallback(e.target.value, state.filmType);
      if (!preset) return;
      state.filmPreset = preset.id;
      state.filmType = preset.type;
      if (e.target.value !== state.filmPreset) {
        e.target.value = state.filmPreset;
      }
      setFilmTypeButtons(state.filmType);
      updateFilmModeUI();

      schedulePreviewUpdate();
    });

    setFilmTypeButtons(state.filmType);
    updateFilmModeUI();

    loadPresetDataset()
      .then(() => {
        const preset = getPresetOrFallback(state.filmPreset, state.filmType);
        if (!preset) return;
        state.filmPreset = preset.id;
        state.filmType = preset.type;
        setFilmTypeButtons(state.filmType);
        const presetSelect = document.getElementById('filmPreset');
        if (presetSelect && presetSelect.value !== state.filmPreset) {
          presetSelect.value = state.filmPreset;
        }
        updateFilmModeUI();
      })
      .catch((err) => {
        console.warn('Preset initialization failed.', err);
      });

    // ===========================================
    // Slider Controls
    // ===========================================
    const sliderBindings = [];
    const sliderBindingMap = new Map();

    function getStepDecimals(step) {
      const text = String(step);
      if (text.includes('e-')) {
        const exp = Number.parseInt(text.split('e-')[1], 10);
        return Number.isFinite(exp) ? exp : 0;
      }
      const dotIndex = text.indexOf('.');
      return dotIndex >= 0 ? (text.length - dotIndex - 1) : 0;
    }

    function normalizeSliderValue(value, min, max, step, decimals) {
      if (!Number.isFinite(value)) return min;

      let nextValue = Math.min(max, Math.max(min, value));
      if (Number.isFinite(step) && step > 0) {
        nextValue = min + (Math.round((nextValue - min) / step) * step);
      }
      return Number(nextValue.toFixed(decimals));
    }

    function formatSliderValue(value, decimals) {
      return decimals > 0 ? value.toFixed(decimals) : String(Math.round(value));
    }

    function setupSlider(id, stateKey, options = {}) {
      const slider = document.getElementById(id);
      const valueInput = document.getElementById(id + 'Value');
      if (!slider || !valueInput) return;

      const min = Number.parseFloat(slider.min);
      const max = Number.parseFloat(slider.max);
      const step = Number.parseFloat(slider.step || '1');
      const decimals = Number.isInteger(options.decimals) ? options.decimals : getStepDecimals(step);
      const format = options.format || ((value) => formatSliderValue(value, decimals));
      const normalize = (rawValue) => normalizeSliderValue(rawValue, min, max, step, decimals);

      const syncUI = (value) => {
        slider.value = String(value);
        valueInput.value = format(value);
      };

      const applyValue = (rawValue, commitFull = false) => {
        const value = normalize(rawValue);
        state[stateKey] = value;
        syncUI(value);
        schedulePreviewUpdate();
        if (commitFull) scheduleFullUpdate();
      };

      slider.addEventListener('input', () => {
        applyValue(Number.parseFloat(slider.value), false);
      });

      slider.addEventListener('change', () => {
        applyValue(Number.parseFloat(slider.value), true);
      });

      valueInput.addEventListener('input', () => {
        const parsed = Number.parseFloat(valueInput.value);
        if (!Number.isFinite(parsed)) return;
        const value = normalize(parsed);
        state[stateKey] = value;
        slider.value = String(value);
        schedulePreviewUpdate();
      });

      const commitFromInput = () => {
        const parsed = Number.parseFloat(valueInput.value);
        const sourceValue = Number.isFinite(parsed) ? parsed : state[stateKey];
        applyValue(sourceValue, true);
      };

      valueInput.addEventListener('blur', commitFromInput);
      valueInput.addEventListener('keydown', (event) => {
        if (event.key === 'Enter') {
          event.preventDefault();
          commitFromInput();
        }
      });

      const binding = { id, stateKey, slider, valueInput, normalize, format };
      sliderBindings.push(binding);
      sliderBindingMap.set(id, binding);
      syncUI(normalize(state[stateKey]));
    }

    function syncSliderFromState(id) {
      const binding = sliderBindingMap.get(id);
      if (!binding) return;
      const value = binding.normalize(Number.parseFloat(state[binding.stateKey]));
      state[binding.stateKey] = value;
      binding.slider.value = String(value);
      binding.valueInput.value = binding.format(value);
    }

    function syncAllSlidersFromState() {
      sliderBindings.forEach(binding => syncSliderFromState(binding.id));
    }

    function updateWBSliders() {
      ['wbR', 'wbG', 'wbB'].forEach(syncSliderFromState);
    }

    setupSlider('wbR', 'wbR', { decimals: 2 });
    setupSlider('wbG', 'wbG', { decimals: 2 });
    setupSlider('wbB', 'wbB', { decimals: 2 });
    setupSlider('exposure', 'exposure', { decimals: 1 });
    setupSlider('contrast', 'contrast');
    setupSlider('highlights', 'highlights');
    setupSlider('shadows', 'shadows');
    setupSlider('temperature', 'temperature');
    setupSlider('tint', 'tint');
    setupSlider('vibrance', 'vibrance');
    setupSlider('saturation', 'saturation');
    setupSlider('cyan', 'cyan');
    setupSlider('magenta', 'magenta');
    setupSlider('yellow', 'yellow');

    // ===========================================
    // Section Toggle
    // ===========================================
    document.querySelectorAll('.section-header').forEach(header => {
      header.addEventListener('click', () => {
        const toggle = header.querySelector('.section-toggle');
        const section = header.dataset.section;
        if (!section) return;

        const content = document.getElementById(section + 'SectionContent') ||
                       document.getElementById(section + 'Section');
        if (content && toggle) {
          toggle.classList.toggle('collapsed');
          content.classList.toggle('collapsed');
        }
      });
    });

    // ===========================================
    // Rotation
    // ===========================================
    function applyRotation(angle) {
      const sourceData = state.croppedImageData || state.originalImageData;
      if (!sourceData) return;

      const rad = angle * Math.PI / 180;
      const w = canvas.width;
      const h = canvas.height;
      const cos = Math.abs(Math.cos(rad));
      const sin = Math.abs(Math.sin(rad));
      const newW = Math.ceil(w * cos + h * sin);
      const newH = Math.ceil(w * sin + h * cos);

      const offCanvas = document.createElement('canvas');
      offCanvas.width = newW;
      offCanvas.height = newH;
      const offCtx = offCanvas.getContext('2d');

      offCtx.translate(newW / 2, newH / 2);
      offCtx.rotate(rad);
      offCtx.drawImage(canvas, -w / 2, -h / 2);

      canvas.width = newW;
      canvas.height = newH;
      ctx.drawImage(offCanvas, 0, 0);

      const newImageData = ctx.getImageData(0, 0, newW, newH);

      if (state.croppedImageData) {
        state.croppedImageData = newImageData;
      } else {
        state.originalImageData = newImageData;
      }

      transformCanvas.width = newW;
      transformCanvas.height = newH;
      transformCtx.drawImage(offCanvas, 0, 0);

      adjustCanvasDisplay(newW, newH);
    }

    function applyMirror() {
      const sourceData = state.croppedImageData || state.originalImageData;
      if (!sourceData) return;

      const w = canvas.width;
      const h = canvas.height;
      const offCanvas = document.createElement('canvas');
      offCanvas.width = w;
      offCanvas.height = h;
      const offCtx = offCanvas.getContext('2d');

      offCtx.translate(w, 0);
      offCtx.scale(-1, 1);
      offCtx.drawImage(canvas, 0, 0);

      ctx.clearRect(0, 0, w, h);
      ctx.drawImage(offCanvas, 0, 0);

      const newImageData = ctx.getImageData(0, 0, w, h);
      if (state.croppedImageData) {
        state.croppedImageData = newImageData;
      } else {
        state.originalImageData = newImageData;
      }

      transformCanvas.width = w;
      transformCanvas.height = h;
      transformCtx.drawImage(offCanvas, 0, 0);
      adjustCanvasDisplay(w, h);
    }

    document.getElementById('rotateLeftBtn').addEventListener('click', () => applyRotation(-90));
    document.getElementById('rotateRightBtn').addEventListener('click', () => applyRotation(90));
    document.getElementById('mirrorBtn').addEventListener('click', () => applyMirror());

    document.getElementById('applyRotateBtn').addEventListener('click', () => {
      const angle = parseFloat(document.getElementById('rotateAngle').value) || 0;
      if (angle !== 0) {
        applyRotation(angle);
        document.getElementById('rotateAngle').value = 0;
      }
    });

    // ===========================================
    // Cropping
    // ===========================================
    const cropOverlay = document.getElementById('cropOverlay');

    document.getElementById('cropBtn').addEventListener('click', () => {
      state.cropping = true;
      state.croppingActive = false;
      state.cropStart = null;
      activeCropPointerId = null;
      cropOverlay.style.display = 'block';
      cropOverlay.style.left = '0';
      cropOverlay.style.top = '0';
      cropOverlay.style.width = '0';
      cropOverlay.style.height = '0';
      canvasContainer.style.touchAction = 'none';

      document.getElementById('cropBtn').style.display = 'none';
      document.getElementById('applyCropBtn').style.display = 'inline-flex';
      document.getElementById('cancelCropBtn').style.display = 'inline-flex';
    });

    let activeCropPointerId = null;

    function startCropDrag(clientX, clientY) {
      if (!state.cropping) return;

      const rect = canvas.getBoundingClientRect();
      const scaleX = canvas.width / rect.width;
      const scaleY = canvas.height / rect.height;

      state.cropStart = {
        x: (clientX - rect.left) * scaleX,
        y: (clientY - rect.top) * scaleY
      };
      state.croppingActive = true;
    }

    function updateCropDrag(clientX, clientY) {
      if (!state.cropping || !state.croppingActive || !state.cropStart) return;

      const canvasRect = canvas.getBoundingClientRect();
      const containerRect = canvasContainer.getBoundingClientRect();

      const offsetX = canvasRect.left - containerRect.left;
      const offsetY = canvasRect.top - containerRect.top;

      const scaleX = canvas.width / canvasRect.width;
      const scaleY = canvas.height / canvasRect.height;

      const current = {
        x: (clientX - canvasRect.left) * scaleX,
        y: (clientY - canvasRect.top) * scaleY
      };

      const left = Math.min(state.cropStart.x, current.x);
      const top = Math.min(state.cropStart.y, current.y);
      const width = Math.abs(current.x - state.cropStart.x);
      const height = Math.abs(current.y - state.cropStart.y);

      const leftDisp = left / scaleX + offsetX;
      const topDisp = top / scaleY + offsetY;
      const widthDisp = width / scaleX;
      const heightDisp = height / scaleY;

      cropOverlay.style.left = leftDisp + 'px';
      cropOverlay.style.top = topDisp + 'px';
      cropOverlay.style.width = widthDisp + 'px';
      cropOverlay.style.height = heightDisp + 'px';
    }

    function finishCropDrag() {
      if (!state.cropping) return;
      state.croppingActive = false;
    }

    canvasContainer.addEventListener('mousedown', (e) => {
      startCropDrag(e.clientX, e.clientY);
    });

    canvasContainer.addEventListener('mousemove', (e) => {
      updateCropDrag(e.clientX, e.clientY);
    });

    canvasContainer.addEventListener('mouseup', finishCropDrag);
    canvasContainer.addEventListener('mouseleave', finishCropDrag);

    canvasContainer.addEventListener('pointerdown', (e) => {
      if (e.pointerType === 'mouse' || !state.cropping) return;
      e.preventDefault();
      activeCropPointerId = e.pointerId;
      canvasContainer.setPointerCapture(e.pointerId);
      startCropDrag(e.clientX, e.clientY);
    }, { passive: false });

    canvasContainer.addEventListener('pointermove', (e) => {
      if (e.pointerType === 'mouse') return;
      if (!state.cropping || activeCropPointerId !== e.pointerId) return;
      e.preventDefault();
      updateCropDrag(e.clientX, e.clientY);
    }, { passive: false });

    function finishCropPointer(e) {
      if (e.pointerType === 'mouse') return;
      if (activeCropPointerId !== e.pointerId) return;
      finishCropDrag();
      if (canvasContainer.hasPointerCapture(e.pointerId)) {
        canvasContainer.releasePointerCapture(e.pointerId);
      }
      activeCropPointerId = null;
    }

    canvasContainer.addEventListener('pointerup', finishCropPointer);
    canvasContainer.addEventListener('pointercancel', finishCropPointer);

    document.getElementById('cancelCropBtn').addEventListener('click', () => {
      state.cropping = false;
      state.croppingActive = false;
      state.cropStart = null;
      activeCropPointerId = null;
      cropOverlay.style.display = 'none';
      canvasContainer.style.touchAction = '';
      document.getElementById('cropBtn').style.display = 'inline-flex';
      document.getElementById('applyCropBtn').style.display = 'none';
      document.getElementById('cancelCropBtn').style.display = 'none';
    });

    document.getElementById('applyCropBtn').addEventListener('click', () => {
      const canvasRect = canvas.getBoundingClientRect();
      const containerRect = canvasContainer.getBoundingClientRect();

      // Calculate canvas offset within container (due to flexbox centering)
      const offsetX = canvasRect.left - containerRect.left;
      const offsetY = canvasRect.top - containerRect.top;

      const scaleX = canvas.width / canvasRect.width;
      const scaleY = canvas.height / canvasRect.height;

      // Subtract offset before converting to canvas coordinates
      const left = Math.floor((parseFloat(cropOverlay.style.left) - offsetX) * scaleX);
      const top = Math.floor((parseFloat(cropOverlay.style.top) - offsetY) * scaleY);
      const width = Math.floor(parseFloat(cropOverlay.style.width) * scaleX);
      const height = Math.floor(parseFloat(cropOverlay.style.height) * scaleY);

      if (width <= 0 || height <= 0) return;

      // Save crop region for batch processing
      state.cropRegion = { left, top, width, height };

      const sourceData = state.croppedImageData || state.originalImageData;
      const croppedData = new ImageData(
        new Uint8ClampedArray(width * height * 4),
        width,
        height
      );

      for (let y = 0; y < height; y++) {
        for (let x = 0; x < width; x++) {
          const srcIdx = ((top + y) * sourceData.width + left + x) * 4;
          const dstIdx = (y * width + x) * 4;
          croppedData.data[dstIdx] = sourceData.data[srcIdx];
          croppedData.data[dstIdx + 1] = sourceData.data[srcIdx + 1];
          croppedData.data[dstIdx + 2] = sourceData.data[srcIdx + 2];
          croppedData.data[dstIdx + 3] = 255;
        }
      }

      state.croppedImageData = croppedData;
      displayNegative(croppedData);

      state.cropping = false;
      state.croppingActive = false;
      state.cropStart = null;
      activeCropPointerId = null;
      cropOverlay.style.display = 'none';
      canvasContainer.style.touchAction = '';
      document.getElementById('cropBtn').style.display = 'inline-flex';
      document.getElementById('applyCropBtn').style.display = 'none';
      document.getElementById('cancelCropBtn').style.display = 'none';
    });

    // Convert button (skip to step 2)
    document.getElementById('convertBtn').addEventListener('click', () => {
      goToStep(2);
    });

    // Convert positive button (skip to step 2 with positive mode selected)
    document.getElementById('convertPositiveBtn').addEventListener('click', () => {
      state.filmType = 'positive';
      state.filmPreset = getDefaultPresetForType('positive');
      renderPresetOptions(state.filmPreset);
      setFilmTypeButtons(state.filmType);
      updateFilmModeUI();
      goToStep(2);
    });

    // ===========================================
    // Reset & Start Over
    // ===========================================
    document.getElementById('resetBtn').addEventListener('click', () => {
      // Reset adjustments only
      state.exposure = 0;
      state.contrast = 0;
      state.highlights = 0;
      state.shadows = 0;
      state.temperature = 0;
      state.tint = 0;
      state.vibrance = 0;
      state.saturation = 0;
      state.cyan = 0;
      state.magenta = 0;
      state.yellow = 0;
      state.wbR = 1;
      state.wbG = 1;
      state.wbB = 1;

      updateSlidersFromState();
      initCurves(true);
      renderCurve();
      updateFull();
    });

    document.getElementById('startOverBtn').addEventListener('click', () => {
      if (state.originalImageData) {
        state.croppedImageData = null;
        state.processedImageData = null;
        state.displayImageData = null;
        state.previewSourceImageData = null;
        state.histogramSourceImageData = null;
        state.webglSourceImageData = null;
        state.filmBaseSet = false;
        state.lastRenderQuality = 'full';
        if (webglState.gl) {
          webglState.sourceDirty = true;
          webglState.sourceSize = { w: 0, h: 0 };
        }
        if (fullUpdateTimer) {
          clearTimeout(fullUpdateTimer);
          fullUpdateTimer = null;
        }
        displayNegative(state.originalImageData);
        goToStep(1);
        document.getElementById('resetBtn').click();
      }
    });

    document.getElementById('newImageBtn').addEventListener('click', () => {
      // Reset all state
      state.originalImageData = null;
      state.croppedImageData = null;
      state.processedImageData = null;
      state.displayImageData = null;
      state.previewSourceImageData = null;
      state.histogramSourceImageData = null;
      state.webglSourceImageData = null;
      state.filmBaseSet = false;
      state.currentStep = 1;
      state.lastRenderQuality = 'full';
      fullAdjustedBuffer = null;
      previewAdjustedBuffer = null;
      if (webglState.gl) {
        webglState.sourceDirty = true;
        webglState.sourceSize = { w: 0, h: 0 };
      }
      if (fullUpdateTimer) {
        clearTimeout(fullUpdateTimer);
        fullUpdateTimer = null;
      }

      // Reset UI
      canvas.style.display = 'none';
      glCanvas.style.display = 'none';
      document.getElementById('uploadPlaceholder').style.display = 'flex';
      document.getElementById('previewToolbar').style.display = 'none';
      document.getElementById('histogramContainer').style.display = 'none';
      document.getElementById('controlsPanel').style.display = 'none';
      document.getElementById('appFooter').style.display = 'none';

      // Reset adjustments
      document.getElementById('resetBtn').click();

      // Trigger file selection
      fileInput.value = '';
      fileInput.click();
    });

    // ===========================================
    // Export
    // ===========================================
    const exportBtn = document.getElementById('exportBtn');
    const exportDropdownMenu = document.getElementById('exportDropdownMenu');

    // Toggle dropdown on main export button click
    exportBtn.addEventListener('click', (e) => {
      e.stopPropagation();
      exportDropdownMenu.classList.toggle('show');
    });

    // Prevent dropdown from closing when clicking inside it (for format settings)
    exportDropdownMenu.addEventListener('click', (e) => {
      // Only stop propagation if clicking on format settings, not export buttons
      if (e.target.closest('.export-format-section') || e.target.closest('.export-quality-section')) {
        e.stopPropagation();
      }
    });

    // Close dropdown when clicking elsewhere
    document.addEventListener('click', () => {
      exportDropdownMenu.classList.remove('show');
    });

    function exportSingle() {
      ensureFullRender();

      const format = state.exportFormat;
      const ext = format === 'jpeg' ? '.jpg' : '.png';
      const mimeType = format === 'jpeg' ? 'image/jpeg' : 'image/png';
      const quality = format === 'jpeg' ? state.jpegQuality / 100 : undefined;

      const dataURL = canvas.toDataURL(mimeType, quality);
      const link = document.createElement('a');
      const fileName = state.fileQueue.length > 0 && state.fileQueue[state.currentFileIndex]
        ? state.fileQueue[state.currentFileIndex].file.name.replace(/\.[^.]+$/, '_converted' + ext)
        : 'converted_negative' + ext;
      link.download = fileName;
      link.href = dataURL;
      link.click();
    }

    document.getElementById('exportSingleBtn').addEventListener('click', exportSingle);

    document.getElementById('exportZipBtn').addEventListener('click', async () => {
      await exportBatchAsZip();
    });

    document.getElementById('exportAllBtn').addEventListener('click', async () => {
      await exportBatchIndividually();
    });

    // Format toggle buttons
    document.querySelectorAll('.format-btn').forEach(btn => {
      btn.addEventListener('click', () => {
        document.querySelectorAll('.format-btn').forEach(b => b.classList.remove('active'));
        btn.classList.add('active');
        state.exportFormat = btn.dataset.format;
        updateExportUI();
      });
    });

    // Quality slider
    document.getElementById('exportQualitySlider').addEventListener('input', (e) => {
      state.jpegQuality = parseInt(e.target.value);
      document.getElementById('exportQualityValue').textContent = state.jpegQuality + '%';
    });

    function updateExportUI() {
      const isJpeg = state.exportFormat === 'jpeg';
      const qualitySection = document.getElementById('exportQualitySection');
      qualitySection.classList.toggle('show', isJpeg);

      // Update export button text
      const exportBtn = document.getElementById('exportBtn');
      exportBtn.textContent = i18n[currentLang][isJpeg ? 'exportJpeg' : 'exportPng'];
      exportBtn.setAttribute('data-i18n', isJpeg ? 'exportJpeg' : 'exportPng');

      // Update export current button text
      const exportSingleBtn = document.getElementById('exportSingleBtn');
      exportSingleBtn.textContent = i18n[currentLang][isJpeg ? 'exportCurrentJpeg' : 'exportCurrent'];
      exportSingleBtn.setAttribute('data-i18n', isJpeg ? 'exportCurrentJpeg' : 'exportCurrent');
    }

    // ===========================================
    // Batch Processing
    // ===========================================
    function extractCurrentSettings() {
      return {
        cropRegion: state.cropRegion,
        filmType: state.filmType,
        filmPreset: state.filmPreset,
        filmBase: { ...state.filmBase },
        exposure: state.exposure,
        contrast: state.contrast,
        highlights: state.highlights,
        shadows: state.shadows,
        temperature: state.temperature,
        tint: state.tint,
        vibrance: state.vibrance,
        saturation: state.saturation,
        cyan: state.cyan,
        magenta: state.magenta,
        yellow: state.yellow,
        wbR: state.wbR,
        wbG: state.wbG,
        wbB: state.wbB,
        curvePoints: {
          r: state.curvePoints.r.map(p => ({ ...p })),
          g: state.curvePoints.g.map(p => ({ ...p })),
          b: state.curvePoints.b.map(p => ({ ...p }))
        },
        curves: {
          r: new Uint8Array(state.curves.r),
          g: new Uint8Array(state.curves.g),
          b: new Uint8Array(state.curves.b)
        }
      };
    }

    function applyAdjustmentsWithSettings(imageData, settings) {
      const output = new ImageData(new Uint8ClampedArray(imageData.data.length), imageData.width, imageData.height);
      applyAdjustmentsToBuffer(imageData, settings, output, 'full');
      return output;
    }

    function cropImageData(imageData, cropRegion) {
      const { left, top, width, height } = cropRegion;
      const croppedData = new ImageData(
        new Uint8ClampedArray(width * height * 4),
        width,
        height
      );

      for (let y = 0; y < height; y++) {
        for (let x = 0; x < width; x++) {
          const srcIdx = ((top + y) * imageData.width + left + x) * 4;
          const dstIdx = (y * width + x) * 4;
          croppedData.data[dstIdx] = imageData.data[srcIdx];
          croppedData.data[dstIdx + 1] = imageData.data[srcIdx + 1];
          croppedData.data[dstIdx + 2] = imageData.data[srcIdx + 2];
          croppedData.data[dstIdx + 3] = 255;
        }
      }

      return croppedData;
    }

    async function loadFileToImageData(file) {
      const arrayBuffer = await file.arrayBuffer();
      const fileName = file.name.toLowerCase();

      if (['.cr2', '.nef', '.arw', '.dng', '.raw', '.rw2', '.tif', '.tiff'].some(ext => fileName.endsWith(ext))) {
        return await loadRawFile(arrayBuffer, fileName);
      } else if (file.type === 'image/png') {
        return loadPngFile(arrayBuffer);
      } else {
        return await loadStandardImage(file);
      }
    }

    async function imageDataToBlob(imageData, format = null, quality = null) {
      format = format || state.exportFormat;
      quality = quality !== null ? quality : state.jpegQuality;

      const tempCanvas = document.createElement('canvas');
      tempCanvas.width = imageData.width;
      tempCanvas.height = imageData.height;
      const tempCtx = tempCanvas.getContext('2d');
      tempCtx.putImageData(imageData, 0, 0);

      return new Promise(resolve => {
        if (format === 'jpeg') {
          tempCanvas.toBlob(resolve, 'image/jpeg', quality / 100);
        } else {
          tempCanvas.toBlob(resolve, 'image/png');
        }
      });
    }

    function updateBatchProgress(current, total, fileName) {
      const percent = Math.round((current / total) * 100);
      document.getElementById('batchProgressFill').style.width = percent + '%';
      document.getElementById('batchProgressText').textContent = `${current} / ${total}`;
      document.getElementById('batchProgressCurrent').textContent = fileName || '';
    }

    function showBatchProgress(show) {
      document.getElementById('batchProgressOverlay').style.display = show ? 'flex' : 'none';
    }

    // Process a single file with given settings (streaming - no memory accumulation)
    async function processOneFile(file, settings) {
      const imageData = await loadFileToImageData(file);

      let workingData = imageData;
      if (settings.cropRegion) {
        workingData = cropImageData(imageData, settings.cropRegion);
      }

      let processed;
      const preset = getPresetOrFallback(settings.filmPreset, settings.filmType);
      const presetType = (preset && preset.type) ? preset.type : settings.filmType;
      if (settings.filmType === 'positive' || presetType === 'positive') {
        processed = convertPositiveFilm(workingData);
      } else if (settings.filmType === 'bw' || presetType === 'bw') {
        const bwParams = getBwPresetParams(preset);
        processed = convertBWNegative(workingData, {
          contrast: bwParams.contrast,
          gamma: bwParams.gamma
        });
      } else {
        processed = convertColorNegative(workingData, settings.filmBase);
      }

      return applyAdjustmentsWithSettings(processed, settings);
    }

    // Get selected files for batch processing
    function getSelectedFiles() {
      return state.fileQueue
        .map((item, index) => ({ item, index }))
        .filter(({ item }) => item.selected);
    }

    // Create default settings with auto-detected film base
    function createDefaultSettings(imageData) {
      const filmBase = autoDetectFilmBase(imageData);
      return {
        cropRegion: null,
        filmType: 'color',
        filmPreset: 'generic_color',
        filmBase: filmBase,
        exposure: 0,
        contrast: 0,
        highlights: 0,
        shadows: 0,
        temperature: 0,
        tint: 0,
        vibrance: 0,
        saturation: 0,
        cyan: 0,
        magenta: 0,
        yellow: 0,
        wbR: 1,
        wbG: 1,
        wbB: 1,
        curvePoints: {
          r: [{ x: 0, y: 0 }, { x: 255, y: 255 }],
          g: [{ x: 0, y: 0 }, { x: 255, y: 255 }],
          b: [{ x: 0, y: 0 }, { x: 255, y: 255 }]
        },
        curves: {
          r: new Uint8Array(256).map((_, i) => i),
          g: new Uint8Array(256).map((_, i) => i),
          b: new Uint8Array(256).map((_, i) => i)
        }
      };
    }

    // Process a file with its own settings or auto-detect
    async function processFileWithSettings(file, savedSettings) {
      // Load the image
      const imageData = await loadFileToImageData(file);

      // Use saved settings or create default with auto-detect
      const settings = savedSettings || createDefaultSettings(imageData);

      // Apply crop if set
      let workingData = imageData;
      if (settings.cropRegion) {
        workingData = cropImageData(imageData, settings.cropRegion);
      }

      // Convert negative
      let processed;
      const preset = getPresetOrFallback(settings.filmPreset, settings.filmType);
      const presetType = (preset && preset.type) ? preset.type : settings.filmType;
      if (settings.filmType === 'positive' || presetType === 'positive') {
        processed = convertPositiveFilm(workingData);
      } else if (settings.filmType === 'bw' || presetType === 'bw') {
        const bwParams = getBwPresetParams(preset);
        processed = convertBWNegative(workingData, {
          contrast: bwParams.contrast,
          gamma: bwParams.gamma
        });
      } else {
        processed = convertColorNegative(workingData, settings.filmBase);
      }

      // Apply adjustments
      return applyAdjustmentsWithSettings(processed, settings);
    }

    // Streaming ZIP export: process → add to zip → free memory → next
    async function exportBatchAsZip() {
      const selectedFiles = getSelectedFiles();
      if (selectedFiles.length < 1) return;

      const zip = new JSZip();
      let processedCount = 0;

      showBatchProgress(true);

      try {
        for (const { item, index } of selectedFiles) {
          item.status = 'processing';
          updateFileListUI();
          processedCount++;
          updateBatchProgress(processedCount, selectedFiles.length, item.file.name);

          try {
            let blob;
            // If this is the current file and it's displayed, use displayed data
            if (index === state.currentFileIndex && state.currentStep >= 3) {
              ensureFullRender();
              blob = await imageDataToBlob(state.displayImageData);
            } else {
              // Process with saved settings or auto-detect
              const adjusted = await processFileWithSettings(item.file, item.settings);
              blob = await imageDataToBlob(adjusted);
            }

            const ext = state.exportFormat === 'jpeg' ? '.jpg' : '.png';
            const name = item.file.name.replace(/\.[^.]+$/, '_converted' + ext);
            zip.file(name, blob);
            item.status = 'done';
          } catch (err) {
            console.error(`Error processing ${item.file.name}:`, err);
            item.status = 'error';
            item.error = err.message;
          }

          updateFileListUI();
          await new Promise(r => setTimeout(r, 10));
        }

        updateBatchProgress(selectedFiles.length, selectedFiles.length, 'Creating ZIP...');
        const zipBlob = await zip.generateAsync({
          type: 'blob',
          compression: 'DEFLATE',
          compressionOptions: { level: 6 }
        });

        const link = document.createElement('a');
        link.download = 'converted_negatives.zip';
        link.href = URL.createObjectURL(zipBlob);
        link.click();
        URL.revokeObjectURL(link.href);
      } finally {
        showBatchProgress(false);
      }
    }

    // Streaming individual download: process → download → free → next
    async function exportBatchIndividually() {
      const selectedFiles = getSelectedFiles();
      if (selectedFiles.length < 1) return;

      let processedCount = 0;

      showBatchProgress(true);

      try {
        for (const { item, index } of selectedFiles) {
          item.status = 'processing';
          updateFileListUI();
          processedCount++;
          updateBatchProgress(processedCount, selectedFiles.length, item.file.name);

          try {
            let blob;
            if (index === state.currentFileIndex && state.currentStep >= 3) {
              ensureFullRender();
              blob = await imageDataToBlob(state.displayImageData);
            } else {
              const adjusted = await processFileWithSettings(item.file, item.settings);
              blob = await imageDataToBlob(adjusted);
            }

            const ext = state.exportFormat === 'jpeg' ? '.jpg' : '.png';
            const name = item.file.name.replace(/\.[^.]+$/, '_converted' + ext);
            const link = document.createElement('a');
            link.download = name;
            link.href = URL.createObjectURL(blob);
            link.click();
            URL.revokeObjectURL(link.href);

            item.status = 'done';
          } catch (err) {
            console.error(`Error processing ${item.file.name}:`, err);
            item.status = 'error';
          }

          updateFileListUI();
          await new Promise(r => setTimeout(r, 200));
        }
      } finally {
        showBatchProgress(false);
      }
    }

    // ===========================================
    // File List UI
    // ===========================================
    function updateFileListUI() {
      const container = document.getElementById('fileListItems');
      const countEl = document.getElementById('fileListCount');
      const selectedCount = state.fileQueue.filter(f => f.selected).length;
      const settingsCount = state.fileQueue.filter(f => f.settings).length;

      // Show: selected/total (settings saved count)
      countEl.textContent = `${selectedCount}/${state.fileQueue.length} (${settingsCount} ${i18n[currentLang].configured || 'configured'})`;
      container.innerHTML = '';

      state.fileQueue.forEach((item, index) => {
        const el = document.createElement('div');
        el.className = 'file-list-item';
        if (index === state.currentFileIndex) el.classList.add('active');
        if (item.settings) el.classList.add('has-settings');

        const statusClass = item.status;
        const statusText = i18n[currentLang][item.status === 'processing' ? 'processingStatus' : item.status] || item.status;
        const settingsBadge = item.settings ? `<span class="file-list-settings-badge">${i18n[currentLang].customSettings || 'Custom'}</span>` : '';

        el.innerHTML = `
          <input type="checkbox" class="file-list-checkbox" ${item.selected ? 'checked' : ''} data-index="${index}">
          <span class="file-list-name">${item.file.name}${settingsBadge}</span>
          <span class="file-list-status ${statusClass}">${statusText}</span>
        `;

        // Checkbox toggle
        el.querySelector('.file-list-checkbox').addEventListener('click', (e) => {
          e.stopPropagation();
          state.fileQueue[index].selected = e.target.checked;
          updateFileListUI();
          updateExportButtons();
        });

        // Click on item to view/edit
        el.addEventListener('click', (e) => {
          if (e.target.classList.contains('file-list-checkbox')) return;
          switchToFile(index);
        });

        container.appendChild(el);
      });

      // Show/hide save settings button based on batch mode
      document.getElementById('saveSettingsBtn').style.display = state.batchMode ? 'inline-flex' : 'none';
      updateBatchStep3GuideVisibility();
    }

    async function switchToFile(index) {
      if (index < 0 || index >= state.fileQueue.length) return;
      if (index === state.currentFileIndex) return;

      state.currentFileIndex = index;
      const fileItem = state.fileQueue[index];

      // Load the file
      await loadFile(fileItem.file);

      // If this file has saved settings, restore them
      if (fileItem.settings) {
        restoreSettings(fileItem.settings);
      }

      updateFileListUI();
    }

    // Save current settings to the current file's queue entry
    function saveCurrentFileSettings() {
      if (state.currentFileIndex < 0 || state.currentFileIndex >= state.fileQueue.length) return;

      const settings = extractCurrentSettings();
      state.fileQueue[state.currentFileIndex].settings = settings;

      updateFileListUI();
      alert(i18n[currentLang].settingsSaved || 'Settings saved for current image');
    }

    // Restore settings from a saved settings object
    function restoreSettings(settings) {
      if (!settings) return;

      // Restore crop region
      state.cropRegion = settings.cropRegion;

      // Restore film settings
      state.filmType = sanitizePresetType(settings.filmType || 'color');
      state.filmPreset = resolvePresetId(settings.filmPreset) || getDefaultPresetForType(state.filmType);
      state.filmBase = { ...settings.filmBase };
      state.filmBaseSet = true;

      // Restore adjustments
      state.exposure = settings.exposure;
      state.contrast = settings.contrast;
      state.highlights = settings.highlights;
      state.shadows = settings.shadows;
      state.temperature = settings.temperature;
      state.tint = settings.tint;
      state.vibrance = settings.vibrance;
      state.saturation = settings.saturation;
      state.cyan = settings.cyan;
      state.magenta = settings.magenta;
      state.yellow = settings.yellow;
      state.wbR = settings.wbR;
      state.wbG = settings.wbG;
      state.wbB = settings.wbB;

      // Restore curves
      state.curvePoints = {
        r: settings.curvePoints.r.map(p => ({ ...p })),
        g: settings.curvePoints.g.map(p => ({ ...p })),
        b: settings.curvePoints.b.map(p => ({ ...p }))
      };
      ['r', 'g', 'b'].forEach(ch => updateCurveFromPoints(ch));

      // Update UI to reflect restored settings
      updateSlidersFromState();
      renderCurve();
    }

    // Update all slider UI elements from state
    function updateSlidersFromState() {
      syncAllSlidersFromState();

      // Update film type buttons
      const preset = getPresetOrFallback(state.filmPreset, state.filmType);
      state.filmPreset = preset ? preset.id : getDefaultPresetForType(state.filmType);
      if (preset && state.filmType !== preset.type) {
        state.filmType = preset.type;
      }
      renderPresetOptions(state.filmPreset);
      setFilmTypeButtons(state.filmType);
      updateFilmModeUI();
    }

    function updateExportButtons() {
      // Enable batch export when there are selected files
      const selectedCount = state.fileQueue.filter(f => f.selected).length;
      document.getElementById('exportZipBtn').disabled = selectedCount < 1;
      document.getElementById('exportAllBtn').disabled = selectedCount < 1;
    }

    function showBatchUI(show) {
      document.getElementById('fileListSection').style.display = show ? 'block' : 'none';
      updateBatchStep3GuideVisibility();
    }

    // Select all button
    document.getElementById('selectAllBtn').addEventListener('click', () => {
      state.fileQueue.forEach(item => item.selected = true);
      updateFileListUI();
      updateExportButtons();
    });

    // Select none button
    document.getElementById('selectNoneBtn').addEventListener('click', () => {
      state.fileQueue.forEach(item => item.selected = false);
      updateFileListUI();
      updateExportButtons();
    });

    // Save settings button
    document.getElementById('saveSettingsBtn').addEventListener('click', () => {
      if (state.currentStep < 3) {
        alert(i18n[currentLang].finishProcessing || 'Please complete the workflow (step 3) before saving settings.');
        return;
      }
      saveCurrentFileSettings();
    });

    // Add more files button
    document.getElementById('addMoreFilesBtn').addEventListener('click', () => {
      const input = document.createElement('input');
      input.type = 'file';
      input.multiple = true;
      input.accept = '.cr2,.nef,.arw,.dng,.raw,.rw2,.tif,.tiff,image/*';
      input.onchange = (e) => {
        if (e.target.files.length > 0) {
          addFilesToQueue(Array.from(e.target.files));
        }
      };
      input.click();
    });

    // Clear file list button
    document.getElementById('clearFileListBtn').addEventListener('click', () => {
      state.fileQueue = [];
      state.currentFileIndex = 0;
      state.batchMode = false;
      showBatchUI(false);
      updateExportButtons();
    });

    function addFilesToQueue(files) {
      // Filter for supported image files
      const supportedExtensions = ['.cr2', '.nef', '.arw', '.dng', '.raw', '.rw2', '.tif', '.tiff', '.png', '.jpg', '.jpeg', '.gif', '.webp', '.bmp'];
      const validFiles = files.filter(file => {
        const ext = '.' + file.name.split('.').pop().toLowerCase();
        return supportedExtensions.includes(ext) || file.type.startsWith('image/');
      });

      if (validFiles.length === 0) return;

      // Add files to queue
      for (const file of validFiles) {
        // Avoid duplicates
        if (!state.fileQueue.some(f => f.file.name === file.name && f.file.size === file.size)) {
          state.fileQueue.push({
            file: file,
            selected: true,  // Selected by default
            status: 'pending',
            error: null,
            settings: null  // null = use auto-detect, otherwise saved settings
          });
        }
      }

      // Enable batch mode if more than one file
      if (state.fileQueue.length > 1) {
        state.batchMode = true;
        showBatchUI(true);
      }

      updateFileListUI();
      updateExportButtons();
    }

    // ===========================================
    // File Input Handling
    // ===========================================
    const fileInput = document.getElementById('fileInput');
    const folderInput = document.getElementById('folderInput');
    const uploadBtn = document.getElementById('uploadBtn');
    const uploadFolderBtn = document.getElementById('uploadFolderBtn');

    uploadBtn.addEventListener('click', () => fileInput.click());
    uploadFolderBtn.addEventListener('click', () => folderInput.click());

    fileInput.addEventListener('change', (e) => {
      const files = Array.from(e.target.files);
      if (files.length === 0) return;

      // Reset state for new batch
      state.fileQueue = [];
      state.currentFileIndex = 0;
      state.batchMode = false;
      state.cropRegion = null;

      addFilesToQueue(files);

      // Load the first file
      if (state.fileQueue.length > 0) {
        loadFile(state.fileQueue[0].file);
      }
    });

    folderInput.addEventListener('change', (e) => {
      const files = Array.from(e.target.files);
      if (files.length === 0) return;

      // Reset state for new batch
      state.fileQueue = [];
      state.currentFileIndex = 0;
      state.batchMode = false;
      state.cropRegion = null;

      addFilesToQueue(files);

      // Load the first file
      if (state.fileQueue.length > 0) {
        loadFile(state.fileQueue[0].file);
      }
    });

    canvasContainer.addEventListener('dragover', (e) => {
      e.preventDefault();
      canvasContainer.style.borderColor = 'var(--accent)';
    });

    canvasContainer.addEventListener('dragleave', () => {
      canvasContainer.style.borderColor = '';
    });

    canvasContainer.addEventListener('drop', (e) => {
      e.preventDefault();
      canvasContainer.style.borderColor = '';

      const files = Array.from(e.dataTransfer.files);
      if (files.length === 0) return;

      // Reset state for new batch
      state.fileQueue = [];
      state.currentFileIndex = 0;
      state.batchMode = false;
      state.cropRegion = null;

      addFilesToQueue(files);

      // Load the first file
      if (state.fileQueue.length > 0) {
        loadFile(state.fileQueue[0].file);
      }
    });

    // ===========================================
    // Window Resize
    // ===========================================
    window.addEventListener('resize', () => {
      if (canvas.width > 0 && canvas.height > 0) {
        adjustCanvasDisplay(canvas.width, canvas.height);
      }
    });
  </script>
</body>
</html>
