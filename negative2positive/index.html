<!DOCTYPE html>
<html lang="zh">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
  <title>Negative Converter</title>

  <!-- Google Fonts -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600&display=swap" rel="stylesheet">

  <style>
    :root {
      --bg-primary: #1a1a1a;
      --bg-secondary: #252525;
      --bg-tertiary: #2d2d2d;
      --bg-hover: #363636;
      --text-primary: #e0e0e0;
      --text-secondary: #888;
      --text-muted: #666;
      --accent: #4a9eff;
      --accent-hover: #6db3ff;
      --accent-dim: #3a7ecc;
      --danger: #ff6b6b;
      --success: #4caf50;
      --warning: #ffb74d;
      --border: #3a3a3a;
      --border-light: #444;
      --shadow: rgba(0, 0, 0, 0.3);
      --viewport-h: 100vh;
      --safe-top: env(safe-area-inset-top, 0px);
      --safe-right: env(safe-area-inset-right, 0px);
      --safe-bottom: env(safe-area-inset-bottom, 0px);
      --safe-left: env(safe-area-inset-left, 0px);
    }

    @supports (height: 100dvh) {
      :root {
        --viewport-h: 100dvh;
      }
    }

    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    html, body {
      height: 100%;
      overflow: hidden;
    }

    body {
      font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background: var(--bg-primary);
      color: var(--text-primary);
      display: flex;
      flex-direction: column;
      min-height: var(--viewport-h);
      -webkit-font-smoothing: antialiased;
    }

    @supports (-webkit-touch-callout: none) {
      html {
        height: -webkit-fill-available;
      }

      body {
        min-height: -webkit-fill-available;
      }
    }

    /* Header */
    .app-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 12px 20px;
      background: var(--bg-secondary);
      border-bottom: 1px solid var(--border);
    }

    .header-left {
      display: flex;
      align-items: baseline;
      gap: 10px;
      min-width: 0;
    }

    .app-title {
      font-size: 18px;
      font-weight: 600;
      color: var(--text-primary);
    }

    .build-badge {
      display: inline-flex;
      align-items: center;
      padding: 2px 8px;
      border: 1px solid var(--border);
      border-radius: 999px;
      background: var(--bg-tertiary);
      color: var(--text-secondary);
      font-size: 11px;
      font-weight: 600;
      letter-spacing: 0.02em;
      white-space: nowrap;
    }

    .lang-selector {
      display: flex;
      gap: 4px;
    }

    .lang-btn {
      padding: 6px 12px;
      background: transparent;
      border: 1px solid var(--border);
      color: var(--text-secondary);
      cursor: pointer;
      font-size: 13px;
      transition: all 0.2s;
    }

    .lang-btn:hover {
      background: var(--bg-tertiary);
      color: var(--text-primary);
    }

    .lang-btn.active {
      background: var(--accent);
      border-color: var(--accent);
      color: white;
    }

    /* Main Layout */
    .app-main {
      display: grid;
      grid-template-columns: 1fr 320px;
      flex: 1;
      overflow: hidden;
      min-height: 0;
    }

    /* Preview Section */
    .preview-section {
      display: flex;
      flex-direction: column;
      background: var(--bg-primary);
      padding: 16px;
      overflow: hidden;
      height: 100%;
      max-height: calc(var(--viewport-h) - 120px); /* Account for header and footer */
      min-height: 0;
    }

    .canvas-container {
      flex: 1;
      display: flex;
      align-items: center;
      justify-content: center;
      background: #111;
      border-radius: 8px;
      position: relative;
      overflow: hidden;
      min-height: 400px;
    }

    #canvas {
      max-width: 100%;
      max-height: 100%;
      object-fit: contain;
    }

    #glCanvas {
      max-width: 100%;
      max-height: 100%;
      object-fit: contain;
    }

    .crop-overlay {
      border: 2px dashed var(--accent);
      position: absolute;
      pointer-events: none;
      display: none;
      background: rgba(74, 158, 255, 0.1);
      z-index: 100;
    }

    /* Sampling Loupe (Magnifier) */
    .loupe {
      position: absolute;
      pointer-events: none;
      display: none;
      z-index: 250;
      padding: 8px;
      border-radius: 10px;
      background: rgba(17, 17, 17, 0.95);
      border: 1px solid var(--border-light);
      box-shadow: 0 10px 30px rgba(0, 0, 0, 0.55);
      backdrop-filter: blur(6px);
    }

    #loupeCanvas {
      display: block;
      border-radius: 8px;
      border: 1px solid var(--border);
      image-rendering: pixelated;
    }

    .loupe-info {
      margin-top: 6px;
      font-size: 11px;
      color: var(--text-secondary);
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      white-space: nowrap;
      opacity: 0.95;
    }

    /* Upload Placeholder */
    .upload-placeholder {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      color: var(--text-secondary);
      gap: 16px;
    }

    .upload-placeholder svg {
      width: 64px;
      height: 64px;
      opacity: 0.5;
    }

    .upload-btn {
      padding: 12px 24px;
      background: var(--accent);
      border: none;
      border-radius: 6px;
      color: white;
      font-size: 14px;
      font-weight: 500;
      cursor: pointer;
      transition: background 0.2s;
    }

    .upload-btn:hover {
      background: var(--accent-hover);
    }

    #fileInput {
      display: none;
    }

    /* Preview Toolbar */
    .preview-toolbar {
      display: flex;
      gap: 8px;
      padding: 12px 0;
      flex-wrap: wrap;
      align-items: center;
    }

    .toolbar-btn {
      padding: 8px 16px;
      background: var(--bg-secondary);
      border: 1px solid var(--border);
      border-radius: 4px;
      color: var(--text-primary);
      font-size: 13px;
      cursor: pointer;
      transition: all 0.2s;
      display: flex;
      align-items: center;
      gap: 6px;
    }

    .toolbar-btn:hover {
      background: var(--bg-tertiary);
      border-color: var(--border-light);
    }

    .toolbar-btn.active {
      background: var(--accent);
      border-color: var(--accent);
      color: white;
    }

    .toolbar-btn.primary {
      background: var(--accent);
      border-color: var(--accent);
      color: white;
    }

    .toolbar-btn.primary:hover {
      background: var(--accent-hover);
    }

    .toolbar-btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    .toolbar-btn svg {
      width: 16px;
      height: 16px;
    }

    .toolbar-separator {
      width: 1px;
      height: 24px;
      background: var(--border);
      margin: 0 4px;
    }

    /* Status Badge */
    .status-badge {
      padding: 4px 10px;
      border-radius: 12px;
      font-size: 11px;
      font-weight: 500;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    .status-badge.step1 {
      background: rgba(255, 183, 77, 0.2);
      color: var(--warning);
    }

    .status-badge.step2 {
      background: rgba(74, 158, 255, 0.2);
      color: var(--accent);
    }

    .status-badge.step3 {
      background: rgba(76, 175, 80, 0.2);
      color: var(--success);
    }

    .current-file-label {
      max-width: min(40vw, 460px);
      padding: 4px 8px;
      border-radius: 10px;
      background: rgba(255, 255, 255, 0.05);
      color: var(--text-secondary);
      font-size: 11px;
      line-height: 1.3;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }

    /* Histogram */
    .histogram-container {
      background: var(--bg-secondary);
      border-radius: 6px;
      padding: 8px;
      margin-top: 8px;
    }

    .histogram-label {
      font-size: 11px;
      color: var(--text-secondary);
      margin-bottom: 4px;
    }

    #histogramCanvas {
      width: 100%;
      height: 60px;
      background: #111;
      border-radius: 4px;
    }

    /* Controls Panel */
    .controls-panel {
      background: var(--bg-secondary);
      border-left: 1px solid var(--border);
      overflow-y: auto;
      overflow-x: hidden;
      display: flex;
      flex-direction: column;
      height: 100%;
      max-height: calc(var(--viewport-h) - 120px); /* Account for header and footer */
      min-height: 0;
    }

    /* Prevent flexbox from collapsing earlier sections (e.g. File List) when Step 3 reveals more UI. */
    .controls-panel > .file-list-section,
    .controls-panel > .control-section {
      flex: 0 0 auto;
      flex-shrink: 0;
    }

    .control-section {
      border-bottom: 1px solid var(--border);
      padding: 16px;
    }

    .section-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 12px;
      cursor: pointer;
    }

    .section-title {
      font-size: 13px;
      font-weight: 600;
      color: var(--text-primary);
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    .section-toggle {
      color: var(--text-secondary);
      transition: transform 0.2s;
    }

    .section-toggle.collapsed {
      transform: rotate(-90deg);
    }

    .section-content {
      display: flex;
      flex-direction: column;
      gap: 12px;
    }

    .section-content.collapsed {
      display: none;
    }

    /* Workflow Steps */
    .workflow-steps {
      display: flex;
      flex-direction: column;
      gap: 8px;
      padding: 12px;
      background: var(--bg-tertiary);
      border-radius: 6px;
      margin-bottom: 12px;
    }

    .workflow-step {
      display: flex;
      align-items: center;
      gap: 10px;
      padding: 8px;
      border-radius: 4px;
      font-size: 12px;
      color: var(--text-secondary);
    }

    .workflow-step.active {
      background: rgba(74, 158, 255, 0.1);
      color: var(--accent);
    }

    .workflow-step.completed {
      color: var(--success);
    }

    .step-number {
      width: 20px;
      height: 20px;
      border-radius: 50%;
      background: var(--bg-secondary);
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 11px;
      font-weight: 600;
    }

    .workflow-step.active .step-number {
      background: var(--accent);
      color: white;
    }

    .workflow-step.completed .step-number {
      background: var(--success);
      color: white;
    }

    /* Film Type Toggle */
    .film-type-toggle {
      display: flex;
      background: var(--bg-tertiary);
      border-radius: 6px;
      padding: 3px;
    }

    .film-type-btn {
      flex: 1;
      padding: 8px;
      background: transparent;
      border: none;
      color: var(--text-secondary);
      font-size: 13px;
      cursor: pointer;
      border-radius: 4px;
      transition: all 0.2s;
    }

    .film-type-btn.active {
      background: var(--accent);
      color: white;
    }

    /* Preset Selector */
    .preset-select {
      width: 100%;
      padding: 8px 12px;
      background: var(--bg-tertiary);
      border: 1px solid var(--border);
      border-radius: 4px;
      color: var(--text-primary);
      font-size: 13px;
      cursor: pointer;
    }

    .preset-select:focus {
      outline: none;
      border-color: var(--accent);
    }

    /* Film Base Buttons */
    .film-base-buttons {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
    }

    .film-base-btn {
      flex: 1;
      padding: 8px;
      background: var(--bg-tertiary);
      border: 1px solid var(--border);
      border-radius: 4px;
      color: var(--text-primary);
      font-size: 12px;
      cursor: pointer;
      transition: all 0.2s;
    }

    .film-base-btn:hover {
      background: var(--bg-hover);
      border-color: var(--border-light);
    }

    .film-base-btn.active {
      background: var(--accent);
      border-color: var(--accent);
      color: white;
    }

    .step2-mode-toggle {
      display: flex;
      gap: 8px;
      margin-bottom: 10px;
    }

    .step2-mode-btn {
      flex: 1;
      padding: 7px 9px;
      background: var(--bg-tertiary);
      border: 1px solid var(--border);
      border-radius: 4px;
      color: var(--text-secondary);
      font-size: 12px;
      cursor: pointer;
      transition: all 0.2s;
    }

    .step2-mode-btn:hover {
      background: var(--bg-hover);
      border-color: var(--border-light);
      color: var(--text-primary);
    }

    .step2-mode-btn.active {
      background: var(--accent);
      border-color: var(--accent);
      color: white;
    }

    .step2-guide-card {
      margin-bottom: 10px;
      padding: 10px;
      border: 1px solid rgba(74, 158, 255, 0.35);
      border-radius: 6px;
      background: rgba(74, 158, 255, 0.08);
      color: var(--text-primary);
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    .step2-guide-title {
      font-size: 12px;
      font-weight: 700;
      color: var(--accent);
    }

    .step2-guide-intro,
    .step2-guide-term {
      font-size: 11px;
      line-height: 1.45;
      color: var(--text-secondary);
    }

    .step2-guide-list {
      margin: 0;
      padding-left: 18px;
      display: flex;
      flex-direction: column;
      gap: 5px;
      color: var(--text-primary);
      font-size: 12px;
      line-height: 1.4;
    }

    .step2-guide-tip {
      font-size: 11px;
      line-height: 1.45;
      color: var(--accent);
      border-top: 1px dashed rgba(74, 158, 255, 0.35);
      padding-top: 8px;
    }

    .recommended-action {
      outline: 2px solid rgba(74, 158, 255, 0.55);
      box-shadow: 0 0 0 1px rgba(74, 158, 255, 0.25) inset;
      border-color: var(--accent) !important;
      background: rgba(74, 158, 255, 0.12);
      color: var(--text-primary);
    }

    .roll-reference-controls {
      margin-top: 10px;
      padding: 10px;
      border: 1px solid var(--border);
      border-radius: 6px;
      background: rgba(255, 255, 255, 0.02);
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    .roll-reference-title {
      font-size: 11px;
      text-transform: uppercase;
      letter-spacing: 0.4px;
      color: var(--text-secondary);
      font-weight: 600;
    }

    .roll-reference-status {
      font-size: 11px;
      color: var(--text-secondary);
      line-height: 1.3;
    }

    .roll-reference-options {
      display: flex;
      flex-direction: column;
      gap: 6px;
    }

    .roll-reference-option {
      display: flex;
      align-items: center;
      gap: 6px;
      font-size: 12px;
      color: var(--text-secondary);
      user-select: none;
    }

    .roll-reference-option input[type="checkbox"] {
      accent-color: var(--accent);
      width: 14px;
      height: 14px;
    }

    .autoframe-settings {
      margin-top: 8px;
      padding: 10px;
      border: 1px solid var(--border);
      border-radius: 6px;
      background: rgba(255, 255, 255, 0.02);
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    .autoframe-row {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 8px;
      font-size: 12px;
      color: var(--text-secondary);
    }

    .autoframe-row select {
      flex: 1;
      min-width: 0;
      padding: 6px 8px;
      background: var(--bg-tertiary);
      border: 1px solid var(--border);
      border-radius: 4px;
      color: var(--text-primary);
      font-size: 12px;
    }

    .autoframe-row select:focus {
      outline: none;
      border-color: var(--accent);
    }

    .autoframe-options {
      display: grid;
      grid-template-columns: repeat(2, minmax(0, 1fr));
      gap: 6px 8px;
      padding-top: 2px;
    }

    .autoframe-option {
      display: flex;
      align-items: center;
      gap: 6px;
      font-size: 12px;
      color: var(--text-secondary);
      user-select: none;
    }

    .autoframe-option input[type="checkbox"] {
      accent-color: var(--accent);
      width: 14px;
      height: 14px;
    }

    .autoframe-diagnostics {
      font-family: monospace;
      font-size: 11px;
      color: var(--text-secondary);
      white-space: pre-line;
      line-height: 1.4;
      margin-bottom: 0;
    }

    /* Film Base Preview */
    .film-base-preview {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 8px;
      background: var(--bg-tertiary);
      border-radius: 4px;
    }

    .film-base-color {
      width: 32px;
      height: 32px;
      border-radius: 4px;
      border: 1px solid var(--border);
    }

    .film-base-values {
      font-size: 11px;
      color: var(--text-secondary);
      font-family: monospace;
    }

    /* Slider Control */
    .slider-control {
      display: flex;
      flex-direction: column;
      gap: 4px;
    }

    .slider-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .slider-label {
      font-size: 12px;
      color: var(--text-secondary);
    }

    .slider-value-group {
      display: flex;
      align-items: center;
      gap: 6px;
    }

    .slider-number-input {
      width: 72px;
      padding: 4px 6px;
      background: var(--bg-tertiary);
      border: 1px solid var(--border);
      border-radius: 4px;
      color: var(--text-primary);
      font-size: 12px;
      font-family: monospace;
      text-align: right;
    }

    .slider-number-input:focus {
      outline: none;
      border-color: var(--accent);
    }

    .slider-unit {
      font-size: 11px;
      color: var(--text-secondary);
      min-width: 16px;
    }

    .slider-input {
      -webkit-appearance: none;
      appearance: none;
      width: 100%;
      height: 4px;
      background: var(--bg-tertiary);
      border-radius: 2px;
      cursor: pointer;
    }

    .slider-input::-webkit-slider-thumb {
      -webkit-appearance: none;
      width: 14px;
      height: 14px;
      background: var(--accent);
      border-radius: 50%;
      cursor: pointer;
      transition: transform 0.1s;
    }

    .slider-input::-webkit-slider-thumb:hover {
      transform: scale(1.2);
    }

    .slider-input::-moz-range-thumb {
      width: 14px;
      height: 14px;
      background: var(--accent);
      border: none;
      border-radius: 50%;
      cursor: pointer;
    }

    /* Curve Editor */
    .curve-editor {
      background: var(--bg-tertiary);
      border-radius: 4px;
      padding: 8px;
    }

    .curve-hint {
      font-size: 11px;
      color: var(--text-secondary);
      margin: 0 0 8px 0;
    }

    .curve-tabs {
      display: flex;
      gap: 4px;
      margin-bottom: 8px;
    }

    .curve-tab.reset {
      color: var(--text-secondary);
      margin-left: auto;
    }

    .curve-tab.reset:hover {
      color: var(--accent);
      border-color: var(--accent);
    }

    .curve-tab {
      flex: 1;
      padding: 4px 8px;
      background: transparent;
      border: 1px solid var(--border);
      border-radius: 3px;
      font-size: 11px;
      cursor: pointer;
      transition: all 0.2s;
    }

    .curve-tab.r { color: #ff6b6b; }
    .curve-tab.g { color: #69db7c; }
    .curve-tab.b { color: #74c0fc; }

    .curve-tab.active {
      background: var(--bg-hover);
      border-color: var(--border-light);
    }

    .curve-canvas {
      width: 100%;
      height: 120px;
      background: #111;
      border-radius: 4px;
      border: 1px solid var(--border);
      cursor: crosshair;
      touch-action: none;
      transition: border-color 0.2s;
    }

    .curve-canvas:hover {
      border-color: var(--accent);
    }

    .curve-presets {
      display: flex;
      gap: 4px;
      margin-top: 8px;
    }

    .curve-preset-btn {
      flex: 1;
      padding: 4px;
      background: var(--bg-secondary);
      border: 1px solid var(--border);
      border-radius: 3px;
      color: var(--text-secondary);
      font-size: 10px;
      cursor: pointer;
    }

    .curve-preset-btn:hover {
      background: var(--bg-hover);
      color: var(--text-primary);
    }

    /* Footer */
    .app-footer {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 12px 20px;
      background: var(--bg-secondary);
      border-top: 1px solid var(--border);
    }

    .footer-left {
      display: flex;
      gap: 8px;
    }

    .footer-right {
      display: flex;
      gap: 8px;
    }

    .footer-btn {
      padding: 8px 16px;
      background: var(--bg-tertiary);
      border: 1px solid var(--border);
      border-radius: 4px;
      color: var(--text-primary);
      font-size: 13px;
      cursor: pointer;
      transition: all 0.2s;
    }

    .footer-btn:hover {
      background: var(--bg-hover);
    }

    .footer-btn.primary {
      background: var(--accent);
      border-color: var(--accent);
      color: white;
    }

    .footer-btn.primary:hover {
      background: var(--accent-hover);
    }

    .footer-btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    /* Rotate Controls */
    .rotate-controls {
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .rotate-input {
      width: 60px;
      padding: 6px 8px;
      background: var(--bg-tertiary);
      border: 1px solid var(--border);
      border-radius: 4px;
      color: var(--text-primary);
      font-size: 13px;
      text-align: center;
    }

    .rotate-input:focus {
      outline: none;
      border-color: var(--accent);
    }

    /* Info Box */
    .info-box {
      padding: 10px 12px;
      background: rgba(74, 158, 255, 0.1);
      border: 1px solid rgba(74, 158, 255, 0.3);
      border-radius: 4px;
      font-size: 12px;
      color: var(--accent);
      margin-bottom: 12px;
    }

    .workflow-guide-note {
      margin-top: 8px;
      margin-bottom: 0;
      line-height: 1.5;
      white-space: pre-line;
    }

    /* File List Panel (Batch Mode) */
    .file-list-section {
      max-height: 200px;
      overflow-y: auto;
      border-bottom: 1px solid var(--border);
      position: sticky;
      top: 0;
      z-index: 5;
      background: var(--bg-secondary);
    }

    .file-list-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 8px 16px;
      background: var(--bg-tertiary);
      border-bottom: 1px solid var(--border);
      position: sticky;
      top: 0;
      z-index: 10;
    }

    .file-list-title {
      font-size: 12px;
      font-weight: 600;
      color: var(--text-primary);
    }

    .file-list-count {
      font-size: 11px;
      color: var(--text-secondary);
    }

    .file-list-items {
      padding: 4px 0;
    }

    .file-list-item {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 6px 12px;
      font-size: 12px;
      cursor: pointer;
      transition: background 0.15s;
    }

    .file-list-item:hover {
      background: var(--bg-tertiary);
    }

    .file-list-item.active {
      background: rgba(74, 158, 255, 0.15);
    }

    .file-list-checkbox {
      width: 14px;
      height: 14px;
      cursor: pointer;
      accent-color: var(--accent);
    }

    .file-list-name {
      flex: 1;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
      color: var(--text-primary);
    }

    .file-list-status {
      font-size: 10px;
      padding: 2px 6px;
      border-radius: 8px;
      white-space: nowrap;
    }

    .file-list-status.pending {
      background: rgba(136, 136, 136, 0.2);
      color: var(--text-secondary);
    }

    .file-list-status.processing {
      background: rgba(74, 158, 255, 0.2);
      color: var(--accent);
    }

    .file-list-status.done {
      background: rgba(76, 175, 80, 0.2);
      color: var(--success);
    }

    .file-list-status.error {
      background: rgba(255, 107, 107, 0.2);
      color: var(--danger);
    }

    .file-list-actions {
      display: flex;
      gap: 4px;
      padding: 8px 16px;
      border-top: 1px solid var(--border);
    }

    .file-list-btn {
      flex: 1;
      padding: 6px 8px;
      background: var(--bg-tertiary);
      border: 1px solid var(--border);
      border-radius: 4px;
      color: var(--text-primary);
      font-size: 11px;
      cursor: pointer;
      transition: all 0.2s;
    }

    .file-list-btn:hover {
      background: var(--bg-hover);
    }

    .file-list-item.has-settings {
      border-left: 3px solid var(--success);
    }

    .file-list-item.is-dirty {
      border-left: 3px solid var(--warning);
    }

    .file-list-settings-badge {
      font-size: 9px;
      padding: 1px 4px;
      background: var(--success);
      color: white;
      border-radius: 3px;
      margin-left: 4px;
    }

    .file-list-unsaved-badge {
      font-size: 9px;
      padding: 1px 4px;
      background: var(--warning);
      color: #111;
      border-radius: 3px;
      margin-left: 4px;
      font-weight: 600;
    }

    /* Debug Widget (enable with ?debug=1) */
    .debug-widget {
      position: fixed;
      right: 12px;
      bottom: 12px;
      z-index: 9999;
      max-width: min(420px, calc(100vw - 24px));
      background: rgba(0, 0, 0, 0.72);
      border: 1px solid rgba(255, 255, 255, 0.18);
      border-radius: 10px;
      padding: 10px 12px;
      color: rgba(255, 255, 255, 0.92);
      font: 11px/1.35 ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
      white-space: pre;
      pointer-events: none;
    }

    /* Batch Progress Modal */
    .batch-progress-overlay {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.7);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 1000;
    }

    .batch-progress-modal {
      background: var(--bg-secondary);
      border-radius: 8px;
      padding: 24px;
      min-width: 320px;
      max-width: 400px;
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
    }

    .batch-progress-title {
      font-size: 16px;
      font-weight: 600;
      margin-bottom: 16px;
      color: var(--text-primary);
    }

    .batch-progress-bar {
      height: 8px;
      background: var(--bg-tertiary);
      border-radius: 4px;
      overflow: hidden;
      margin-bottom: 12px;
    }

    .batch-progress-fill {
      height: 100%;
      background: var(--accent);
      transition: width 0.3s ease;
    }

    .batch-progress-text {
      font-size: 13px;
      color: var(--text-secondary);
      text-align: center;
    }

    .batch-progress-current {
      font-size: 12px;
      color: var(--text-muted);
      margin-top: 8px;
      text-align: center;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }

    /* Export Dropdown */
    .export-dropdown {
      position: relative;
      display: inline-block;
    }

    .export-dropdown-menu {
      position: absolute;
      bottom: 100%;
      right: 0;
      background: var(--bg-secondary);
      border: 1px solid var(--border);
      border-radius: 4px;
      min-width: 180px;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
      display: none;
      margin-bottom: 4px;
      z-index: 100;
    }

    .export-dropdown-menu.show {
      display: block;
    }

    .export-dropdown-item {
      display: block;
      width: 100%;
      padding: 10px 12px;
      background: none;
      border: none;
      color: var(--text-primary);
      font-size: 13px;
      text-align: left;
      cursor: pointer;
      transition: background 0.15s;
    }

    .export-dropdown-item:hover {
      background: var(--bg-tertiary);
    }

    .export-dropdown-item:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    .export-dropdown-divider {
      height: 1px;
      background: var(--border);
      margin: 4px 0;
    }

    .export-format-section {
      padding: 10px 12px;
      border-bottom: 1px solid var(--border);
    }

    .export-format-label {
      font-size: 11px;
      color: var(--text-secondary);
      margin-bottom: 6px;
      text-transform: uppercase;
    }

    .export-format-toggle {
      display: flex;
      gap: 4px;
    }

    .export-format-toggle .format-btn {
      flex: 1;
      padding: 6px 12px;
      background: var(--bg-tertiary);
      border: 1px solid var(--border);
      color: var(--text-secondary);
      font-size: 12px;
      cursor: pointer;
      transition: all 0.15s;
    }

    .export-format-toggle .format-btn:first-child {
      border-radius: 4px 0 0 4px;
    }

    .export-format-toggle .format-btn:last-child {
      border-radius: 0 4px 4px 0;
    }

    .export-format-toggle .format-btn.active {
      background: var(--accent);
      border-color: var(--accent);
      color: white;
    }

    .export-quality-section {
      padding: 10px 12px;
      border-bottom: 1px solid var(--border);
      display: none;
    }

    .export-quality-section.show {
      display: block;
    }

    .export-quality-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 6px;
    }

    .export-quality-label {
      font-size: 11px;
      color: var(--text-secondary);
      text-transform: uppercase;
    }

    .export-quality-value {
      font-size: 12px;
      color: var(--text-primary);
    }

    .export-quality-slider {
      width: 100%;
      height: 4px;
      -webkit-appearance: none;
      appearance: none;
      background: var(--bg-tertiary);
      border-radius: 2px;
      outline: none;
    }

    .export-quality-slider::-webkit-slider-thumb {
      -webkit-appearance: none;
      appearance: none;
      width: 14px;
      height: 14px;
      background: var(--accent);
      border-radius: 50%;
      cursor: pointer;
    }

    .export-quality-slider::-moz-range-thumb {
      width: 14px;
      height: 14px;
      background: var(--accent);
      border-radius: 50%;
      cursor: pointer;
      border: none;
    }

    /* Responsive */
    @media (max-width: 900px) {
      body {
        font-family: -apple-system, BlinkMacSystemFont, "SF Pro Text", "SF Pro Display", "Inter", "Segoe UI", Roboto, sans-serif;
        background: linear-gradient(180deg, #1d1d1f 0%, #141416 100%);
      }

      button,
      input,
      select {
        -webkit-tap-highlight-color: transparent;
        touch-action: manipulation;
      }

      .app-header {
        position: sticky;
        top: 0;
        z-index: 60;
        padding: calc(10px + var(--safe-top)) calc(12px + var(--safe-right)) 10px calc(12px + var(--safe-left));
        background: rgba(37, 37, 37, 0.86);
        backdrop-filter: blur(18px) saturate(150%);
        border-bottom: 1px solid rgba(255, 255, 255, 0.08);
      }

      .app-title {
        font-size: 17px;
        letter-spacing: -0.02em;
      }

      .lang-selector {
        background: rgba(255, 255, 255, 0.04);
        border: 1px solid rgba(255, 255, 255, 0.08);
        border-radius: 12px;
        padding: 2px;
      }

      .lang-btn {
        min-height: 32px;
        min-width: 48px;
        padding: 6px 10px;
        border: none;
        border-radius: 9px;
      }

      .app-main {
        grid-template-columns: 1fr;
        grid-template-rows: minmax(220px, 1.08fr) minmax(0, 1fr);
        gap: 10px;
        padding: 10px calc(10px + var(--safe-right)) 10px calc(10px + var(--safe-left));
      }

      .preview-section {
        padding: 0;
        max-height: none;
        border: 1px solid rgba(255, 255, 255, 0.08);
        border-radius: 16px;
        background: rgba(29, 29, 31, 0.76);
      }

      .canvas-container {
        margin: 10px;
        border-radius: 14px;
        min-height: 220px;
      }

      .preview-toolbar {
        padding: 8px 10px 10px;
        gap: 8px;
        flex-wrap: nowrap;
        overflow-x: auto;
        overflow-y: hidden;
        overscroll-behavior-x: contain;
        -webkit-overflow-scrolling: touch;
        scrollbar-width: none;
      }

      .preview-toolbar::-webkit-scrollbar {
        display: none;
      }

      .status-badge,
      .current-file-label,
      .toolbar-btn,
      .rotate-controls {
        flex-shrink: 0;
      }

      .status-badge,
      .current-file-label {
        white-space: nowrap;
      }

      .toolbar-separator {
        display: none;
      }

      .toolbar-btn {
        min-height: 44px;
        padding: 10px 14px;
        border-radius: 12px;
        font-size: 14px;
        white-space: nowrap;
      }

      .rotate-controls {
        gap: 6px;
        padding: 4px 8px;
        border-radius: 12px;
        border: 1px solid rgba(255, 255, 255, 0.08);
        background: rgba(255, 255, 255, 0.03);
      }

      .rotate-input {
        width: 70px;
        height: 34px;
        font-size: 16px;
      }

      .histogram-container {
        margin: 0 10px 10px;
        border-radius: 12px;
      }

      .controls-panel {
        border: 1px solid rgba(255, 255, 255, 0.08);
        border-radius: 16px;
        max-height: none;
        background: rgba(29, 29, 31, 0.72);
        backdrop-filter: blur(14px) saturate(140%);
        overscroll-behavior: contain;
        -webkit-overflow-scrolling: touch;
      }

      .control-section {
        padding: 14px;
      }

      .section-title {
        font-size: 12px;
      }

      .film-type-btn,
      .step2-mode-btn,
      .film-base-btn,
      .file-list-btn,
      .curve-tab,
      .curve-preset-btn,
      .footer-btn {
        min-height: 40px;
      }

      .preset-select,
      .rotate-input,
      .slider-number-input,
      .file-list-btn,
      .footer-btn {
        font-size: 16px;
      }

      .preset-select {
        min-height: 44px;
      }

      .slider-input {
        height: 6px;
      }

      .slider-input::-webkit-slider-thumb {
        width: 18px;
        height: 18px;
      }

      .slider-input::-moz-range-thumb {
        width: 18px;
        height: 18px;
      }

      .slider-number-input {
        width: 84px;
        min-height: 36px;
      }

      .file-list-section {
        max-height: 34vh;
        -webkit-overflow-scrolling: touch;
      }

      .app-footer {
        position: sticky;
        bottom: 0;
        z-index: 60;
        flex-direction: column;
        align-items: stretch;
        gap: 8px;
        padding: 10px calc(10px + var(--safe-right)) calc(10px + var(--safe-bottom)) calc(10px + var(--safe-left));
        background: rgba(37, 37, 37, 0.9);
        backdrop-filter: blur(20px) saturate(160%);
        border-top: 1px solid rgba(255, 255, 255, 0.08);
      }

      .footer-left {
        width: 100%;
        display: grid;
        grid-template-columns: repeat(3, minmax(0, 1fr));
      }

      .footer-right {
        width: 100%;
        display: grid;
        grid-template-columns: repeat(3, minmax(0, 1fr));
      }

      .footer-btn {
        width: 100%;
        min-height: 44px;
        border-radius: 12px;
        font-size: 14px;
      }

      .footer-right .export-dropdown {
        width: 100%;
      }

      .footer-right .export-dropdown > .footer-btn {
        width: 100%;
      }

      .copyright {
        padding: 10px calc(10px + var(--safe-right)) calc(10px + var(--safe-bottom)) calc(10px + var(--safe-left));
        font-size: 12px;
      }
    }

    @media (max-width: 600px) {
      .app-header {
        padding-right: calc(10px + var(--safe-right));
        padding-left: calc(10px + var(--safe-left));
      }

      .app-title {
        font-size: 16px;
      }

      .lang-btn {
        min-width: 42px;
        padding: 5px 8px;
        font-size: 12px;
      }
    }

    /* Copyright Footer */
    .copyright {
      flex-shrink: 0;
      text-align: center;
      padding: 12px 16px;
      font-size: 13px;
      color: var(--text-secondary);
      background: var(--bg-secondary);
      border-top: 1px solid var(--border);
    }
    .copyright a {
      color: var(--accent);
      text-decoration: none;
    }
    .copyright a:hover {
      text-decoration: underline;
    }
    .copyright .github-link {
      display: inline-block;
      margin-left: 12px;
      vertical-align: middle;
      height: 28px;
    }
  </style>

  <!-- External Libraries -->
  <script type="module">
    import LibRaw from './index.js';
    window.LibRaw = LibRaw;
  </script>
  <script src="https://cdn.jsdelivr.net/npm/pako/dist/pako.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/upng-js@2.1.0/UPNG.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/utif@3.1.0/UTIF.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/jszip@3/dist/jszip.min.js"></script>
</head>

<body>
  <!-- Header -->
  <header class="app-header">
    <div class="header-left">
      <h1 class="app-title" data-i18n="title">Negative Converter</h1>
      <span class="build-badge" id="buildBadge" style="display: none;"></span>
    </div>
    <div class="lang-selector">
      <button class="lang-btn" data-lang="zh">中文</button>
      <button class="lang-btn" data-lang="en">EN</button>
      <button class="lang-btn" data-lang="ja">日本語</button>
    </div>
  </header>

  <!-- Main Content -->
  <main class="app-main">
    <!-- Preview Section -->
    <section class="preview-section">
      <div class="canvas-container" id="canvasContainer">
        <div class="upload-placeholder" id="uploadPlaceholder">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
            <path d="M4 16l4.586-4.586a2 2 0 012.828 0L16 16m-2-2l1.586-1.586a2 2 0 012.828 0L20 14m-6-6h.01M6 20h12a2 2 0 002-2V6a2 2 0 00-2-2H6a2 2 0 00-2 2v12a2 2 0 002 2z"/>
          </svg>
          <p data-i18n="dropHint">Drop image here or click to open</p>
          <button class="upload-btn" id="uploadBtn" data-i18n="selectFile">Select File</button>
          <button class="upload-btn" id="uploadFolderBtn" style="margin-left: 8px; background: var(--bg-tertiary); border: 1px solid var(--border);" data-i18n="selectFolder">Select Folder</button>
          <input type="file" id="fileInput" accept=".cr2,.nef,.arw,.dng,.raw,.rw2,.tif,.tiff,image/*" multiple>
          <input type="file" id="folderInput" accept=".cr2,.nef,.arw,.dng,.raw,.rw2,.tif,.tiff,image/*" webkitdirectory style="display: none;">
        </div>
        <canvas id="canvas" style="display: none;"></canvas>
        <canvas id="glCanvas" style="display: none;"></canvas>
        <div class="crop-overlay" id="cropOverlay"></div>
        <div class="loupe" id="loupe">
          <canvas id="loupeCanvas" width="155" height="155"></canvas>
          <div class="loupe-info" id="loupeInfo"></div>
        </div>
      </div>

      <!-- Toolbar -->
      <div class="preview-toolbar" id="previewToolbar" style="display: none;">
        <span class="status-badge step1" id="statusBadge" data-i18n="step1">Step 1: Crop</span>
        <span class="current-file-label" id="currentFileLabel" style="display: none;"></span>
        <div class="toolbar-separator"></div>
        <button class="toolbar-btn" id="rotateLeftBtn" title="Rotate Left">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M2.5 2v6h6M2.66 12a10 10 0 11.8 4"/></svg>
          <span>-90°</span>
        </button>
        <button class="toolbar-btn" id="rotateRightBtn" title="Rotate Right">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M21.5 2v6h-6M21.34 12a10 10 0 11-.8 4" transform="scale(-1,1) translate(-24,0)"/></svg>
          <span>+90°</span>
        </button>
        <button class="toolbar-btn" id="mirrorBtn" data-i18n="mirror" title="Mirror">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <path d="M12 4v16M4 8l4 4-4 4M20 8l-4 4 4 4"/>
          </svg>
          <span data-i18n="mirror">Mirror</span>
        </button>
        <div class="rotate-controls">
          <input type="number" class="rotate-input" id="rotateAngle" value="0" min="-180" max="180" step="0.1">
          <span>°</span>
          <button class="toolbar-btn" id="applyRotateBtn" data-i18n="applyRotate">Apply</button>
        </div>
        <div class="toolbar-separator"></div>
        <button class="toolbar-btn" id="cropBtn" data-i18n="crop">Crop</button>
        <button class="toolbar-btn" id="applyCropBtn" style="display: none;" data-i18n="applyCrop">Apply Crop</button>
        <button class="toolbar-btn" id="cancelCropBtn" style="display: none;" data-i18n="cancelCrop">Cancel</button>
        <button class="toolbar-btn" id="autoFrameBtn" data-i18n="autoFrame">Auto Frame</button>
        <button class="toolbar-btn" id="autoFrameSelectedBtn" data-i18n="autoFrameSelected">Auto Frame Selected</button>
        <button class="toolbar-btn" id="addFilesToolbarBtn" data-i18n="addFiles">Add</button>
        <div class="toolbar-separator" id="convertSeparator" style="display: none;"></div>
        <button class="toolbar-btn primary" id="convertBtn" style="display: none;" data-i18n="convert">Convert Negative</button>
        <button class="toolbar-btn primary" id="convertPositiveBtn" style="display: none;" data-i18n="convertPositive">Convert Positive</button>
      </div>

      <!-- Histogram -->
      <div class="histogram-container" id="histogramContainer" style="display: none;">
        <div class="histogram-label" data-i18n="histogram">Histogram</div>
        <canvas id="histogramCanvas"></canvas>
      </div>
    </section>

    <!-- Controls Panel -->
    <aside class="controls-panel" id="controlsPanel" style="display: none;">
      <!-- File List (Batch Mode) -->
      <div class="file-list-section" id="fileListSection" style="display: none;">
        <div class="file-list-header">
          <span class="file-list-title" data-i18n="fileList">File List</span>
          <span class="file-list-count" id="fileListCount">0 / 0</span>
        </div>
        <div class="file-list-items" id="fileListItems">
          <!-- File items dynamically added here -->
        </div>
        <div class="file-list-actions">
          <button class="file-list-btn" id="selectAllBtn" data-i18n="selectAll">All</button>
          <button class="file-list-btn" id="selectNoneBtn" data-i18n="selectNone">None</button>
          <button class="file-list-btn" id="addMoreFilesBtn" data-i18n="addFiles">Add</button>
          <button class="file-list-btn" id="clearFileListBtn" data-i18n="clearList">Clear</button>
        </div>
      </div>

      <!-- Workflow Guide -->
      <div class="control-section">
        <div class="section-header">
          <span class="section-title" data-i18n="workflow">Workflow</span>
        </div>
        <div class="workflow-steps" id="workflowSteps">
          <div class="workflow-step active" id="step1">
            <span class="step-number">1</span>
            <span data-i18n="stepCrop">Crop image (remove non-film areas)</span>
          </div>
          <div class="workflow-step" id="step2">
            <span class="step-number">2</span>
            <span data-i18n="stepBase">Sample film base (orange mask)</span>
          </div>
          <div class="workflow-step" id="step3">
            <span class="step-number">3</span>
            <span data-i18n="stepAdjust">Adjust colors and export</span>
          </div>
        </div>
        <div class="info-box workflow-guide-note" id="batchStep3GuideBox" data-i18n="batchStep3Guide" style="display: none;">
          Batch Step 3 Guide:
          1) Adjust current image.
          2) Click "Save Settings".
          3) Click the next file in File List.
          4) Repeat, then export all.
        </div>
      </div>

      <!-- Auto Frame Settings (Step 1) -->
      <div class="control-section" id="autoFrameSettingsSection" style="display: none;">
        <div class="section-header">
          <span class="section-title" data-i18n="autoFrameSettings">Auto Frame Settings</span>
        </div>
        <div class="section-content">
          <div class="autoframe-settings">
            <label class="autoframe-option">
              <input type="checkbox" id="autoFrameEnabledInput" checked>
              <span data-i18n="autoFrameEnabled">Enable Auto Frame</span>
            </label>
            <label class="autoframe-option">
              <input type="checkbox" id="autoFrameAutoApplyInput" checked>
              <span data-i18n="autoFrameAutoApplyHigh">Auto-apply high confidence</span>
            </label>
            <div class="autoframe-row">
              <span data-i18n="autoFrameFormatLabel">Film Format</span>
              <select id="autoFrameFormatSelect">
                <option value="auto" data-i18n="autoFrameFormatAuto">Auto (135/120)</option>
                <option value="135" data-i18n="autoFrameFormat135">Prefer 135</option>
                <option value="120" data-i18n="autoFrameFormat120">Prefer 120</option>
              </select>
            </div>
            <div class="autoframe-row" id="autoFrame120LabelRow">
              <span data-i18n="autoFrame120Formats">120 sub-formats</span>
            </div>
            <div class="autoframe-options" id="autoFrame120Options">
              <label class="autoframe-option">
                <input type="checkbox" id="autoFrame120_645" checked>
                <span>6x4.5</span>
              </label>
              <label class="autoframe-option">
                <input type="checkbox" id="autoFrame120_66" checked>
                <span>6x6</span>
              </label>
              <label class="autoframe-option">
                <input type="checkbox" id="autoFrame120_67" checked>
                <span>6x7</span>
              </label>
              <label class="autoframe-option">
                <input type="checkbox" id="autoFrame120_69" checked>
                <span>6x9</span>
              </label>
            </div>
            <div class="autoframe-row">
              <span data-i18n="autoFrameLowConfidenceBehavior">Low confidence</span>
              <select id="autoFrameLowConfidenceSelect">
                <option value="suggest" data-i18n="autoFrameSuggestOnly">Suggest only</option>
                <option value="rotateOnly" data-i18n="autoFrameRotateOnly">Rotate only</option>
                <option value="ignore" data-i18n="autoFrameNoAction">Do nothing</option>
              </select>
            </div>
          </div>
          <div class="info-box autoframe-diagnostics" id="autoFrameDiagnosticsBox" style="display: none;"></div>
        </div>
      </div>

      <!-- Film Settings (Step 2) -->
      <div class="control-section" id="filmSettingsSection" style="display: none;">
        <div class="section-header">
          <span class="section-title" data-i18n="filmSettings">Film Settings</span>
        </div>
        <div class="section-content">
          <div class="step2-mode-toggle" id="step2ModeToggle">
            <button class="step2-mode-btn active" id="step2ModeBorderBtn" data-mode="border" data-i18n="step2ModeBorder">Border Available</button>
            <button class="step2-mode-btn" id="step2ModeNoBorderBtn" data-mode="noBorder" data-i18n="step2ModeNoBorder">No Border / ES-2</button>
          </div>
          <div class="info-box workflow-guide-note" id="step2FirstHint" data-i18n="step2FirstHint" style="display: none;"></div>
          <div class="step2-guide-card" id="step2GuideCard">
            <div class="step2-guide-title" data-i18n="guideStep2Title">First time here? Follow these 3 steps.</div>
            <div class="step2-guide-intro" data-i18n="guideStep2Intro">Pick the mode that matches your scan setup, then follow the guided steps below.</div>
            <div class="step2-guide-term" data-i18n="guideTermMaskHelp">Film mask means the unexposed orange edge area near sprocket holes or frame edge.</div>
            <ol class="step2-guide-list">
              <li id="step2GuideStep1"></li>
              <li id="step2GuideStep2"></li>
              <li id="step2GuideStep3"></li>
            </ol>
            <div class="step2-guide-tip" id="step2GuideTip"></div>
          </div>
          <div class="film-type-toggle">
            <button class="film-type-btn active" data-type="color" data-i18n="colorFilm">Color</button>
            <button class="film-type-btn" data-type="bw" data-i18n="bwFilm">B&W</button>
            <button class="film-type-btn" data-type="positive" data-i18n="positiveFilm">Positive</button>
          </div>
          <select class="preset-select" id="filmPreset">
            <option value="generic_color" data-i18n="genericColor">Generic Color</option>
          </select>
          <div id="filmBaseControls">
            <div class="info-box" data-i18n="filmBaseInfo">Sample the unexposed film edge if available. If the border is already cropped out, use Auto Detect or reuse a reference frame.</div>
            <div class="film-base-buttons">
              <button class="film-base-btn" id="sampleBaseBtn" data-i18n="sampleBase">Sample Film Base</button>
              <button class="film-base-btn" id="autoDetectBtn" data-i18n="autoDetect">Auto Detect</button>
              <button class="film-base-btn" id="useReferenceBtn" data-i18n="useRollReference">Use Roll Reference</button>
            </div>
            <div class="film-base-preview" id="filmBasePreview" style="display: none;">
              <div class="film-base-color" id="filmBaseColor"></div>
              <div class="film-base-values" id="filmBaseValues">R: 0 G: 0 B: 0</div>
            </div>
            <div class="roll-reference-controls" id="rollReferenceControls">
              <div class="roll-reference-title" data-i18n="rollReferenceTitle">Roll Reference</div>
              <div class="roll-reference-status" id="rollReferenceStatus" data-i18n="rollReferenceNone">No roll reference set.</div>
              <div class="film-base-buttons">
                <button class="film-base-btn" id="setRollReferenceBtn" data-i18n="setRollReference">Set Current as Reference</button>
                <button class="film-base-btn" id="applyRollReferenceBtn" data-i18n="applyRollReference">Apply Reference to Selected</button>
                <button class="film-base-btn" id="clearRollReferenceBtn" data-i18n="clearRollReference">Clear Reference</button>
              </div>
              <div class="roll-reference-options">
                <label class="roll-reference-option">
                  <input type="checkbox" id="lockRollReference">
                  <span data-i18n="lockRollReference">Lock reference for newly added files</span>
                </label>
                <label class="roll-reference-option">
                  <input type="checkbox" id="applyCropWithReference">
                  <span data-i18n="applyCropWithReference">Also apply crop from reference</span>
                </label>
              </div>
            </div>
          </div>
          <div class="info-box" id="positiveFilmInfo" data-i18n="positiveModeInfo" style="display: none;">Positive slide film mode does not require film base sampling.</div>
          <button class="toolbar-btn primary" id="applyConvertBtn" style="margin-top: 8px; width: 100%; justify-content: center;" data-i18n="applyConvert">Apply & Convert</button>
        </div>
      </div>

      <!-- White Balance (Step 3) -->
      <div class="control-section" id="whiteBalanceSection" style="display: none;">
        <div class="section-header" data-section="wb">
          <span class="section-title" data-i18n="whiteBalance">White Balance</span>
          <span class="section-toggle">▼</span>
        </div>
        <div class="section-content" id="wbSection">
          <div class="info-box" data-i18n="wbInfo">Click on a neutral gray area in the image, or adjust manually</div>
          <button class="film-base-btn" id="sampleWBBtn" data-i18n="sampleWB">Sample Gray Point</button>
          <div class="slider-control">
            <div class="slider-header">
              <span class="slider-label">R</span>
              <input type="number" class="slider-number-input" id="wbRValue" min="0.5" max="2" step="0.01" value="1.00">
            </div>
            <input type="range" class="slider-input" id="wbR" min="0.5" max="2" step="0.01" value="1">
          </div>
          <div class="slider-control">
            <div class="slider-header">
              <span class="slider-label">G</span>
              <input type="number" class="slider-number-input" id="wbGValue" min="0.5" max="2" step="0.01" value="1.00">
            </div>
            <input type="range" class="slider-input" id="wbG" min="0.5" max="2" step="0.01" value="1">
          </div>
          <div class="slider-control">
            <div class="slider-header">
              <span class="slider-label">B</span>
              <input type="number" class="slider-number-input" id="wbBValue" min="0.5" max="2" step="0.01" value="1.00">
            </div>
            <input type="range" class="slider-input" id="wbB" min="0.5" max="2" step="0.01" value="1">
          </div>
        </div>
      </div>

      <!-- Tone Adjustments (Step 3) -->
      <div class="control-section" id="toneSection" style="display: none;">
        <div class="section-header" data-section="tone">
          <span class="section-title" data-i18n="toneAdjustments">Tone</span>
          <span class="section-toggle">▼</span>
        </div>
        <div class="section-content" id="toneSectionContent">
          <div class="slider-control">
            <div class="slider-header">
              <span class="slider-label" data-i18n="exposure">Exposure</span>
              <div class="slider-value-group">
                <input type="number" class="slider-number-input" id="exposureValue" min="-3" max="3" step="0.1" value="0.0">
                <span class="slider-unit">EV</span>
              </div>
            </div>
            <input type="range" class="slider-input" id="exposure" min="-3" max="3" step="0.1" value="0">
          </div>
          <div class="slider-control">
            <div class="slider-header">
              <span class="slider-label" data-i18n="contrast">Contrast</span>
              <input type="number" class="slider-number-input" id="contrastValue" min="-100" max="100" step="1" value="0">
            </div>
            <input type="range" class="slider-input" id="contrast" min="-100" max="100" step="1" value="0">
          </div>
          <div class="slider-control">
            <div class="slider-header">
              <span class="slider-label" data-i18n="highlights">Highlights</span>
              <input type="number" class="slider-number-input" id="highlightsValue" min="-100" max="100" step="1" value="0">
            </div>
            <input type="range" class="slider-input" id="highlights" min="-100" max="100" step="1" value="0">
          </div>
          <div class="slider-control">
            <div class="slider-header">
              <span class="slider-label" data-i18n="shadows">Shadows</span>
              <input type="number" class="slider-number-input" id="shadowsValue" min="-100" max="100" step="1" value="0">
            </div>
            <input type="range" class="slider-input" id="shadows" min="-100" max="100" step="1" value="0">
          </div>
        </div>
      </div>

      <!-- Color Balance (Step 3) -->
      <div class="control-section" id="colorSection" style="display: none;">
        <div class="section-header" data-section="color">
          <span class="section-title" data-i18n="colorBalance">Color Balance</span>
          <span class="section-toggle">▼</span>
        </div>
        <div class="section-content" id="colorSectionContent">
          <div class="slider-control">
            <div class="slider-header">
              <span class="slider-label" data-i18n="temperature">Temperature</span>
              <input type="number" class="slider-number-input" id="temperatureValue" min="-100" max="100" step="1" value="0">
            </div>
            <input type="range" class="slider-input" id="temperature" min="-100" max="100" step="1" value="0">
          </div>
          <div class="slider-control">
            <div class="slider-header">
              <span class="slider-label" data-i18n="tint">Tint</span>
              <input type="number" class="slider-number-input" id="tintValue" min="-100" max="100" step="1" value="0">
            </div>
            <input type="range" class="slider-input" id="tint" min="-100" max="100" step="1" value="0">
          </div>
          <div class="slider-control">
            <div class="slider-header">
              <span class="slider-label" data-i18n="vibrance">Vibrance</span>
              <input type="number" class="slider-number-input" id="vibranceValue" min="-100" max="100" step="1" value="0">
            </div>
            <input type="range" class="slider-input" id="vibrance" min="-100" max="100" step="1" value="0">
          </div>
          <div class="slider-control">
            <div class="slider-header">
              <span class="slider-label" data-i18n="saturation">Saturation</span>
              <input type="number" class="slider-number-input" id="saturationValue" min="-100" max="100" step="1" value="0">
            </div>
            <input type="range" class="slider-input" id="saturation" min="-100" max="100" step="1" value="0">
          </div>
        </div>
      </div>

      <!-- CMY Adjustments (Step 3) -->
      <div class="control-section" id="cmySection" style="display: none;">
        <div class="section-header" data-section="cmy">
          <span class="section-title">CMY</span>
          <span class="section-toggle">▼</span>
        </div>
        <div class="section-content" id="cmySectionContent">
          <div class="slider-control">
            <div class="slider-header">
              <span class="slider-label">Cyan</span>
              <input type="number" class="slider-number-input" id="cyanValue" min="-100" max="100" step="1" value="0">
            </div>
            <input type="range" class="slider-input" id="cyan" min="-100" max="100" step="1" value="0">
          </div>
          <div class="slider-control">
            <div class="slider-header">
              <span class="slider-label">Magenta</span>
              <input type="number" class="slider-number-input" id="magentaValue" min="-100" max="100" step="1" value="0">
            </div>
            <input type="range" class="slider-input" id="magenta" min="-100" max="100" step="1" value="0">
          </div>
          <div class="slider-control">
            <div class="slider-header">
              <span class="slider-label">Yellow</span>
              <input type="number" class="slider-number-input" id="yellowValue" min="-100" max="100" step="1" value="0">
            </div>
            <input type="range" class="slider-input" id="yellow" min="-100" max="100" step="1" value="0">
          </div>
        </div>
      </div>

      <!-- Advanced (Curves) (Step 3) -->
      <div class="control-section" id="advancedSection" style="display: none;">
        <div class="section-header" data-section="advanced">
          <span class="section-title" data-i18n="advanced">Advanced</span>
          <span class="section-toggle collapsed">▼</span>
        </div>
        <div class="section-content collapsed" id="advancedSectionContent">
          <div class="curve-editor">
            <p class="curve-hint" data-i18n="curveHint">Click and drag to adjust the curve</p>
            <div class="curve-tabs">
              <button class="curve-tab r active" data-channel="r">R</button>
              <button class="curve-tab g" data-channel="g">G</button>
              <button class="curve-tab b" data-channel="b">B</button>
              <button class="curve-tab reset" id="resetCurveBtn" data-i18n="resetCurve">Reset</button>
            </div>
            <canvas class="curve-canvas" id="curveCanvas"></canvas>
            <div class="curve-presets">
              <button class="curve-preset-btn" data-preset="linear" data-i18n="linear">Linear</button>
              <button class="curve-preset-btn" data-preset="scurve" data-i18n="sCurve">S-Curve</button>
              <button class="curve-preset-btn" data-preset="log" data-i18n="log">Log</button>
            </div>
          </div>
        </div>
      </div>
    </aside>
  </main>

  <!-- Footer -->
  <footer class="app-footer" id="appFooter" style="display: none;">
    <div class="footer-left">
      <button class="footer-btn" id="newImageBtn" data-i18n="newImage">New Image</button>
      <button class="footer-btn" id="resetBtn" data-i18n="reset">Reset</button>
      <button class="footer-btn" id="startOverBtn" data-i18n="startOver">Start Over</button>
    </div>
    <div class="footer-right">
      <button class="footer-btn" id="saveSettingsBtn" style="display: none;" data-i18n="saveSettings">Save Settings</button>
      <button class="footer-btn" id="applyToSelectedBtn" style="display: none;" data-i18n="applyToSelected">Apply to Selected</button>
      <div class="export-dropdown">
        <button class="footer-btn primary" id="exportBtn" data-i18n="exportPng">Export PNG</button>
        <div class="export-dropdown-menu" id="exportDropdownMenu">
          <div class="export-format-section">
            <div class="export-format-label" data-i18n="exportFormat">Export Format</div>
            <div class="export-format-toggle">
              <button class="format-btn active" data-format="png">PNG</button>
              <button class="format-btn" data-format="jpeg">JPEG</button>
            </div>
          </div>
          <div class="export-quality-section" id="exportQualitySection">
            <div class="export-quality-header">
              <span class="export-quality-label" data-i18n="jpegQuality">JPEG Quality</span>
              <span class="export-quality-value" id="exportQualityValue">92%</span>
            </div>
            <input type="range" class="export-quality-slider" id="exportQualitySlider" min="1" max="100" value="92">
          </div>
          <button class="export-dropdown-item" id="exportSingleBtn" data-i18n="exportCurrent">Export Current (PNG)</button>
          <div class="export-dropdown-divider"></div>
          <button class="export-dropdown-item" id="exportZipBtn" data-i18n="exportZip" disabled>Export All (ZIP)</button>
          <button class="export-dropdown-item" id="exportAllBtn" data-i18n="exportIndividual" disabled>Download All Individually</button>
        </div>
      </div>
    </div>
  </footer>

  <!-- Batch Progress Modal -->
  <div class="batch-progress-overlay" id="batchProgressOverlay" style="display: none;">
    <div class="batch-progress-modal">
      <div class="batch-progress-title" data-i18n="batchProcessing">Batch Processing...</div>
      <div class="batch-progress-bar">
        <div class="batch-progress-fill" id="batchProgressFill" style="width: 0%;"></div>
      </div>
      <div class="batch-progress-text" id="batchProgressText">0 / 0</div>
      <div class="batch-progress-current" id="batchProgressCurrent"></div>
    </div>
  </div>

  <div class="copyright">
    © 2025 Negative Converter. <a href="https://neoanaloglab.com" target="_blank">neoanaloglab.com</a> All rights reserved.
    <span class="github-link">
      <a class="github-button" href="https://github.com/lexluthor0304/NegativeConverter" data-icon="octicon-star" data-size="large" data-show-count="true" aria-label="Star lexluthor0304/NegativeConverter on GitHub">Star</a>
    </span>
  </div>
  <script async defer src="https://buttons.github.io/buttons.js"></script>

  <script>
    // ===========================================
    // Internationalization
    // ===========================================
    const i18n = {
      zh: {
        title: "负片转正片",
        dropHint: "拖放图片到此处或点击读取",
        selectFile: "选择文件",
        applyRotate: "应用",
        mirror: "镜像",
        crop: "裁剪",
        applyCrop: "应用裁剪",
        cancelCrop: "取消",
        autoFrame: "自动识别边框",
        autoFrameSelected: "批量自动识别",
        convert: "转换负片",
        convertPositive: "转换正片",
        histogram: "直方图",
        loadError: "加载文件失败",
        rawUnsupported: "当前 Safari 版本不支持 RAW 解码，请升级 Safari（建议 iOS 16.4+）或先转为 TIFF/JPEG。",
        workflow: "工作流程",
        stepCrop: "裁剪图像（移除胶片外区域）",
        stepBase: "设置色罩基准（新手按步骤即可）",
        stepAdjust: "调整颜色并导出",
        step1: "第1步：裁剪",
        step2: "第2步：色罩",
        step3: "第3步：调整",
        step2ModeBorder: "有边框",
        step2ModeNoBorder: "无边框 / ES-2",
        filmSettings: "胶片设置",
        colorFilm: "彩色",
        bwFilm: "黑白",
        positiveFilm: "正片",
        genericColor: "通用彩色",
        genericBW: "通用黑白",
        genericPositive: "通用正片",
        filmBaseInfo: "看得到橙色未曝光边缘：请手动采样。看不到边缘（如 ES-2）：请点“自动检测色罩”或“使用整卷参考值”。",
        positiveModeInfo: "正片模式不需要色罩采样，可直接点击“下一步：转换并进入调整”。",
        sampleBase: "手动采样色罩",
        autoDetect: "自动检测色罩",
        useRollReference: "使用整卷参考值",
        step2FirstHint: "提示：如果你找不到橙色边缘，请切换到“无边框 / ES-2”再继续。",
        guideStep2Title: "第一次用？按下面 3 步做",
        guideStep2Intro: "先选择“有边框”或“无边框 / ES-2”，再按步骤执行。",
        guideTermMaskHelp: "“色罩”就是胶片未曝光的橙色底片区域，常在齿孔附近或画面边缘。",
        guideBorderStep1: "点击“手动采样色罩”。",
        guideBorderStep2: "在图上点击橙色未曝光边缘（尽量避开画面内容）。",
        guideBorderStep3: "点击“下一步：转换并进入调整”。",
        guideNoBorderStep1: "点击“自动检测色罩”。",
        guideNoBorderStep2: "如果你有参考图，点击“使用整卷参考值”。",
        guideNoBorderStep3: "点击“下一步：转换并进入调整”。",
        guideTipMismatch: "如果采样后颜色怪异，通常是点到了画面内容。请重新采样或切到“无边框 / ES-2”。",
        guideTipFallback: "没有参考值也没关系，先点“自动检测色罩”；不满意可再微调。",
        guideTipReady: "色罩已设置完成，可以直接进入下一步。",
        guideTipReferenceReady: "检测不到边缘时，优先使用“整卷参考值”通常更稳定。",
        guideAutoDetectFallback: "未手动采样色罩，系统已自动尝试检测。若颜色仍异常，请切换到“无边框 / ES-2”并重试。",
        guideReferenceSuggestion: "如果自动检测不稳定，建议先把一张参考图设置为“整卷参考值”再转换。",
        rollReferenceTitle: "整卷参考",
        rollReferenceNone: "尚未设置整卷参考。",
        rollReferenceActive: "参考来源：{file}",
        setRollReference: "将当前图设为参考",
        applyRollReference: "应用参考到已选中",
        clearRollReference: "清除参考",
        lockRollReference: "新增文件自动套用参考",
        applyCropWithReference: "同时套用参考裁剪",
        rollReferenceSet: "已将当前图片设为整卷参考。",
        rollReferenceCleared: "已清除整卷参考。",
        rollReferenceApplied: "已将整卷参考应用到 {count} 张图片。",
        rollReferenceMissing: "尚未设置整卷参考。",
        rollReferenceAppliedCurrent: "已将整卷参考应用到当前图片。",
        applyConvert: "下一步：转换并进入调整",
        whiteBalance: "白平衡",
        wbInfo: "点击图像中应为中性灰的区域，或手动调整",
        sampleWB: "采样灰点",
        toneAdjustments: "色调调整",
        exposure: "曝光",
        contrast: "对比度",
        highlights: "高光",
        shadows: "阴影",
        colorBalance: "色彩平衡",
        temperature: "色温",
        tint: "色调",
        vibrance: "活力",
        saturation: "饱和度",
        advanced: "高级",
        linear: "线性",
        sCurve: "S曲线",
        log: "对数",
        curveHint: "点击添加控制点，拖动调整，双击删除",
        resetCurve: "重置",
        reset: "重置调整",
        startOver: "重新开始",
        newImage: "选择新图片",
        exportPng: "导出 PNG",
        colorFilms: "彩色负片",
        bwFilms: "黑白负片",
        positiveFilms: "正片",
        processing: "处理中...",
        currentFile: "当前文件",
        selectFolder: "选择文件夹",
        fileList: "文件列表",
        selectAll: "全选",
        selectNone: "全不选",
        addFiles: "添加",
        clearList: "清空",
        batchProcess: "批量处理",
        batchProcessing: "批量处理中...",
        saveSettings: "保存设置",
        settingsSaved: "当前图片设置已保存。",
        applyToSelected: "应用到已选中",
        appliedToSelected: "已将当前设置应用到 {count} 张图片。",
        noSelectedFiles: "没有选中的图片可应用设置。",
        batchStep3Guide: "批处理第3步指南：\n1) 调整当前图片。\n2) 切换图片或导出时会自动保存。\n3) 也可手动点击“保存设置”。\n4) 如需整卷统一参数，可点“应用到已选中”。\n5) 最后点击“批量导出 (ZIP)”或“逐个下载全部”。",
        autoFrameAnalyzing: "正在自动识别边框...",
        autoFramePreviewTitle: "检测到可用边框，是否应用？",
        autoFramePreviewDetail: "将旋转 {angle}°，裁剪到 {width}×{height}，置信度 {confidence}",
        autoFrameLowConfidenceTitle: "检测到低置信度边框，是否仍按建议应用裁剪？",
        autoFrameNoReliableBorder: "未检测到可靠边框，请手动裁剪。",
        autoFrameCvLoadError: "OpenCV 加载失败，无法使用自动识别。",
        autoFrameBatchDone: "自动识别完成：成功 {success} 张，失败 {failed} 张。",
        autoFrameBatchDoneExtended: "自动识别完成：成功裁剪 {success} 张，仅旋转 {rotated} 张，失败 {failed} 张。",
        autoFrameRotateOnlyApplied: "低置信度：已仅应用旋转 {angle}°。",
        autoFrameSettings: "自动边框设置",
        autoFrameEnabled: "启用自动边框识别",
        autoFrameAutoApplyHigh: "高置信度时自动应用",
        autoFrameFormatLabel: "胶片格式",
        autoFrameFormatAuto: "自动（135/120）",
        autoFrameFormat135: "优先 135",
        autoFrameFormat120: "优先 120",
        autoFrame120Formats: "120 子格式",
        autoFrameLowConfidenceBehavior: "低置信度处理",
        autoFrameSuggestOnly: "仅建议，不自动应用",
        autoFrameRotateOnly: "只应用旋转",
        autoFrameNoAction: "不执行操作",
        autoFrameDiagnostics: "检测详情：方法 {method} | 格式 {format} | 置信度 {confidence}",
        exportCurrent: "导出当前图片 (PNG)",
        exportZip: "批量导出 (ZIP)",
        exportIndividual: "逐个下载全部",
        pending: "等待处理",
        processingStatus: "处理中",
        done: "已完成",
        error: "错误",
        unsaved: "未保存",
        configured: "已配置",
        customSettings: "已设置",
        autoDetect: "自动检测色罩",
        finishProcessing: "请先完成当前图片的处理流程（到第3步）",
        exportFormat: "导出格式",
        jpegQuality: "JPEG 质量",
        exportJpeg: "导出 JPEG",
        exportCurrentJpeg: "导出当前图片 (JPEG)",
        exportZipJpeg: "批量导出 (ZIP/JPEG)"
      },
      en: {
        title: "Negative Converter",
        dropHint: "Drop image here or click to open",
        selectFile: "Select File",
        applyRotate: "Apply",
        mirror: "Mirror",
        crop: "Crop",
        applyCrop: "Apply Crop",
        cancelCrop: "Cancel",
        autoFrame: "Auto Frame",
        autoFrameSelected: "Auto Frame Selected",
        convert: "Convert Negative",
        convertPositive: "Convert Positive",
        histogram: "Histogram",
        loadError: "Error loading file",
        rawUnsupported: "RAW decode is not supported in this Safari version. Update Safari (iOS 16.4+) or convert to TIFF/JPEG first.",
        workflow: "Workflow",
        stepCrop: "Crop image (remove non-film areas)",
        stepBase: "Set Film Mask Baseline (Beginner Friendly)",
        stepAdjust: "Adjust colors and export",
        step1: "Step 1: Crop",
        step2: "Step 2: Mask",
        step3: "Step 3: Adjust",
        step2ModeBorder: "Border Available",
        step2ModeNoBorder: "No Border / ES-2",
        filmSettings: "Film Settings",
        colorFilm: "Color",
        bwFilm: "B&W",
        positiveFilm: "Positive",
        genericColor: "Generic Color",
        genericBW: "Generic B&W",
        genericPositive: "Generic Positive",
        filmBaseInfo: "If you can see unexposed orange border, sample it manually. If border is cropped out (for example ES-2), use Auto Detect Mask or Roll Reference.",
        positiveModeInfo: "Positive mode does not need film-mask sampling. You can go straight to “Next: Convert and Continue”.",
        sampleBase: "Sample Mask Manually",
        autoDetect: "Auto Detect Mask",
        useRollReference: "Use Roll Reference Value",
        step2FirstHint: "Tip: If you cannot find orange border area, switch to “No Border / ES-2”.",
        guideStep2Title: "First time here? Follow these 3 steps",
        guideStep2Intro: "Pick the mode that matches your scan setup, then do the steps below.",
        guideTermMaskHelp: "Film mask means the unexposed orange base area, usually near sprocket holes or frame edge.",
        guideBorderStep1: "Click “Sample Mask Manually”.",
        guideBorderStep2: "Click an unexposed orange edge area (avoid image content).",
        guideBorderStep3: "Click “Next: Convert and Continue”.",
        guideNoBorderStep1: "Click “Auto Detect Mask”.",
        guideNoBorderStep2: "If you already have a reference frame, click “Use Roll Reference Value”.",
        guideNoBorderStep3: "Click “Next: Convert and Continue”.",
        guideTipMismatch: "If colors look strange, you probably sampled picture content. Re-sample or switch to “No Border / ES-2”.",
        guideTipFallback: "No reference yet is fine. Start with “Auto Detect Mask”, then fine tune if needed.",
        guideTipReady: "Mask baseline is ready. You can continue to conversion.",
        guideTipReferenceReady: "When border is missing, roll reference is usually the most stable choice.",
        guideAutoDetectFallback: "Mask was not sampled manually, so auto-detect was applied. If colors still look off, switch to “No Border / ES-2” and try again.",
        guideReferenceSuggestion: "If auto-detect is unstable, set one frame as roll reference first, then convert.",
        rollReferenceTitle: "Roll Reference",
        rollReferenceNone: "No roll reference set.",
        rollReferenceActive: "Reference source: {file}",
        setRollReference: "Set Current as Reference",
        applyRollReference: "Apply Reference to Selected",
        clearRollReference: "Clear Reference",
        lockRollReference: "Lock reference for newly added files",
        applyCropWithReference: "Also apply crop from reference",
        rollReferenceSet: "Current image has been set as the roll reference.",
        rollReferenceCleared: "Roll reference cleared.",
        rollReferenceApplied: "Applied roll reference to {count} image(s).",
        rollReferenceMissing: "No roll reference is set.",
        rollReferenceAppliedCurrent: "Roll reference applied to current image.",
        applyConvert: "Next: Convert and Continue",
        whiteBalance: "White Balance",
        wbInfo: "Click on a neutral gray area in the image, or adjust manually",
        sampleWB: "Sample Gray Point",
        toneAdjustments: "Tone",
        exposure: "Exposure",
        contrast: "Contrast",
        highlights: "Highlights",
        shadows: "Shadows",
        colorBalance: "Color Balance",
        temperature: "Temperature",
        tint: "Tint",
        vibrance: "Vibrance",
        saturation: "Saturation",
        advanced: "Advanced",
        linear: "Linear",
        sCurve: "S-Curve",
        log: "Log",
        curveHint: "Click to add point, drag to adjust, double-click to remove",
        resetCurve: "Reset",
        reset: "Reset Adjustments",
        startOver: "Start Over",
        newImage: "New Image",
        exportPng: "Export PNG",
        colorFilms: "Color Films",
        bwFilms: "B&W Films",
        positiveFilms: "Positive Slides",
        processing: "Processing...",
        currentFile: "Current File",
        selectFolder: "Select Folder",
        fileList: "File List",
        selectAll: "All",
        selectNone: "None",
        addFiles: "Add",
        clearList: "Clear",
        batchProcess: "Batch Process",
        batchProcessing: "Batch Processing...",
        saveSettings: "Save Settings",
        settingsSaved: "Settings saved for current image.",
        applyToSelected: "Apply to Selected",
        appliedToSelected: "Applied current settings to {count} image(s).",
        noSelectedFiles: "No selected images to apply settings.",
        batchStep3Guide: "Batch Step 3 Guide:\n1) Adjust the current image.\n2) Settings auto-save when switching files or exporting.\n3) You can still click \"Save Settings\" manually.\n4) Use \"Apply to Selected\" for roll-wide baseline settings.\n5) When finished, use \"Export All (ZIP)\" or \"Download All Individually\".",
        autoFrameAnalyzing: "Analyzing frame borders...",
        autoFramePreviewTitle: "Reliable frame detected. Apply auto rotation and crop?",
        autoFramePreviewDetail: "Rotate {angle}°, crop to {width}×{height}, confidence {confidence}",
        autoFrameLowConfidenceTitle: "Low-confidence frame detected. Apply suggested crop anyway?",
        autoFrameNoReliableBorder: "No reliable frame border detected. Please crop manually.",
        autoFrameCvLoadError: "OpenCV failed to load. Auto frame is unavailable.",
        autoFrameBatchDone: "Auto frame finished: {success} succeeded, {failed} failed.",
        autoFrameBatchDoneExtended: "Auto frame finished: {success} crop success, {rotated} rotation-only, {failed} failed.",
        autoFrameRotateOnlyApplied: "Low confidence: applied rotation only ({angle}°).",
        autoFrameSettings: "Auto Frame Settings",
        autoFrameEnabled: "Enable Auto Frame",
        autoFrameAutoApplyHigh: "Auto-apply high confidence",
        autoFrameFormatLabel: "Film Format",
        autoFrameFormatAuto: "Auto (135/120)",
        autoFrameFormat135: "Prefer 135",
        autoFrameFormat120: "Prefer 120",
        autoFrame120Formats: "120 sub-formats",
        autoFrameLowConfidenceBehavior: "Low confidence",
        autoFrameSuggestOnly: "Suggest only",
        autoFrameRotateOnly: "Rotate only",
        autoFrameNoAction: "Do nothing",
        autoFrameDiagnostics: "Detection: method {method} | format {format} | confidence {confidence}",
        exportCurrent: "Export Current (PNG)",
        exportZip: "Export All (ZIP)",
        exportIndividual: "Download All Individually",
        pending: "Pending",
        processingStatus: "Processing",
        done: "Done",
        error: "Error",
        unsaved: "Unsaved",
        configured: "configured",
        customSettings: "Custom",
        autoDetect: "Auto Detect Mask",
        finishProcessing: "Please complete the workflow (step 3) before saving settings",
        exportFormat: "Export Format",
        jpegQuality: "JPEG Quality",
        exportJpeg: "Export JPEG",
        exportCurrentJpeg: "Export Current (JPEG)",
        exportZipJpeg: "Export All (ZIP/JPEG)"
      },
      ja: {
        title: "ネガポジ変換",
        dropHint: "画像をドロップまたはクリックして読み込み",
        selectFile: "ファイル選択",
        applyRotate: "適用",
        mirror: "ミラー",
        crop: "トリミング",
        applyCrop: "適用",
        cancelCrop: "キャンセル",
        autoFrame: "自動フレーム検出",
        autoFrameSelected: "選択画像を自動検出",
        convert: "ネガ変換",
        convertPositive: "ポジ変換",
        histogram: "ヒストグラム",
        loadError: "ファイルの読み込みに失敗しました",
        rawUnsupported: "この Safari バージョンでは RAW デコードに対応していません。Safari（iOS 16.4+ 推奨）へ更新するか、先に TIFF/JPEG に変換してください。",
        workflow: "ワークフロー",
        stepCrop: "画像をトリミング（フィルム外を除去）",
        stepBase: "マスク基準を設定（初回でも簡単）",
        stepAdjust: "色調整とエクスポート",
        step1: "ステップ1：トリミング",
        step2: "ステップ2：マスク",
        step3: "ステップ3：調整",
        step2ModeBorder: "端あり",
        step2ModeNoBorder: "端なし / ES-2",
        filmSettings: "フィルム設定",
        colorFilm: "カラー",
        bwFilm: "白黒",
        positiveFilm: "ポジ",
        genericColor: "汎用カラー",
        genericBW: "汎用白黒",
        genericPositive: "汎用ポジ",
        filmBaseInfo: "未露光のオレンジ端が見える場合は手動サンプリング。端がない（ES-2 など）場合は「マスク自動検出」または「ロール参照値」を使ってください。",
        positiveModeInfo: "ポジモードではマスクサンプリングは不要です。「次へ：変換して調整へ」を押してください。",
        sampleBase: "マスクを手動サンプリング",
        autoDetect: "マスク自動検出",
        useRollReference: "ロール参照値を使用",
        step2FirstHint: "ヒント：オレンジ端が見つからない場合は「端なし / ES-2」に切り替えてください。",
        guideStep2Title: "初めての方へ：この 3 ステップでOK",
        guideStep2Intro: "まずスキャン方法に合うモードを選び、次の手順を実行してください。",
        guideTermMaskHelp: "マスクとは、未露光のオレンジ色のベース部分（パーフォレーション付近やコマ端）です。",
        guideBorderStep1: "「マスクを手動サンプリング」をクリック。",
        guideBorderStep2: "画像内容ではなく、未露光のオレンジ端をクリック。",
        guideBorderStep3: "「次へ：変換して調整へ」をクリック。",
        guideNoBorderStep1: "「マスク自動検出」をクリック。",
        guideNoBorderStep2: "参照コマがある場合は「ロール参照値を使用」をクリック。",
        guideNoBorderStep3: "「次へ：変換して調整へ」をクリック。",
        guideTipMismatch: "色が不自然な場合は、画像部分をサンプリングした可能性があります。再サンプリングするか「端なし / ES-2」に切り替えてください。",
        guideTipFallback: "参照値がなくても大丈夫です。まず「マスク自動検出」を使い、必要なら後で微調整してください。",
        guideTipReady: "マスク基準の設定が完了しました。次へ進めます。",
        guideTipReferenceReady: "端がない場合は「ロール参照値」を使うと安定しやすいです。",
        guideAutoDetectFallback: "手動サンプリングが未実施のため、自動検出を適用しました。色がおかしい場合は「端なし / ES-2」に切り替えて再試行してください。",
        guideReferenceSuggestion: "自動検出が不安定な場合は、先に1枚をロール参照値として設定してから変換してください。",
        rollReferenceTitle: "ロール参照",
        rollReferenceNone: "ロール参照は未設定です。",
        rollReferenceActive: "参照元: {file}",
        setRollReference: "現在画像を参照に設定",
        applyRollReference: "参照を選択画像へ適用",
        clearRollReference: "参照をクリア",
        lockRollReference: "追加ファイルへ参照を自動適用",
        applyCropWithReference: "参照のトリミングも適用",
        rollReferenceSet: "現在の画像をロール参照に設定しました。",
        rollReferenceCleared: "ロール参照をクリアしました。",
        rollReferenceApplied: "ロール参照を {count} 枚に適用しました。",
        rollReferenceMissing: "ロール参照が設定されていません。",
        rollReferenceAppliedCurrent: "ロール参照を現在の画像に適用しました。",
        applyConvert: "次へ：変換して調整へ",
        whiteBalance: "ホワイトバランス",
        wbInfo: "画像内のニュートラルグレー部分をクリック、または手動調整",
        sampleWB: "グレーポイントを取得",
        toneAdjustments: "トーン調整",
        exposure: "露出",
        contrast: "コントラスト",
        highlights: "ハイライト",
        shadows: "シャドウ",
        colorBalance: "カラーバランス",
        temperature: "色温度",
        tint: "色合い",
        vibrance: "バイブランス",
        saturation: "彩度",
        advanced: "詳細",
        linear: "リニア",
        sCurve: "Sカーブ",
        log: "ログ",
        curveHint: "クリックでポイント追加、ドラッグで調整、ダブルクリックで削除",
        resetCurve: "リセット",
        reset: "調整をリセット",
        startOver: "最初から",
        newImage: "新しい画像",
        exportPng: "PNG出力",
        colorFilms: "カラーフィルム",
        bwFilms: "白黒フィルム",
        positiveFilms: "ポジフィルム",
        processing: "処理中...",
        currentFile: "現在のファイル",
        selectFolder: "フォルダ選択",
        fileList: "ファイル一覧",
        selectAll: "全選択",
        selectNone: "全解除",
        addFiles: "追加",
        clearList: "クリア",
        batchProcess: "一括処理",
        batchProcessing: "一括処理中...",
        saveSettings: "設定を保存",
        settingsSaved: "現在の画像の設定を保存しました。",
        applyToSelected: "選択中に適用",
        appliedToSelected: "現在の設定を {count} 枚に適用しました。",
        noSelectedFiles: "設定を適用できる選択画像がありません。",
        batchStep3Guide: "一括処理ステップ3ガイド：\n1) 現在の画像を調整します。\n2) 画像切替または書き出し時に自動保存されます。\n3) 必要なら「設定を保存」も使えます。\n4) ロール全体に適用する場合は「選択中に適用」を使います。\n5) 最後に「一括出力 (ZIP)」または「すべて個別にダウンロード」を実行します。",
        autoFrameAnalyzing: "フレーム境界を解析中...",
        autoFramePreviewTitle: "信頼できるフレームを検出しました。自動回転とトリミングを適用しますか？",
        autoFramePreviewDetail: "{angle}°回転、{width}×{height} にトリミング、信頼度 {confidence}",
        autoFrameLowConfidenceTitle: "低信頼度のフレーム候補です。提案どおり適用しますか？",
        autoFrameNoReliableBorder: "信頼できるフレーム境界を検出できませんでした。手動でトリミングしてください。",
        autoFrameCvLoadError: "OpenCV の読み込みに失敗したため、自動検出は利用できません。",
        autoFrameBatchDone: "自動検出が完了しました: 成功 {success} 枚、失敗 {failed} 枚。",
        autoFrameBatchDoneExtended: "自動検出が完了しました: トリミング成功 {success} 枚、回転のみ {rotated} 枚、失敗 {failed} 枚。",
        autoFrameRotateOnlyApplied: "低信頼度のため回転のみを適用しました（{angle}°）。",
        autoFrameSettings: "自動フレーム設定",
        autoFrameEnabled: "自動フレーム検出を有効化",
        autoFrameAutoApplyHigh: "高信頼度は自動適用",
        autoFrameFormatLabel: "フィルム形式",
        autoFrameFormatAuto: "自動（135/120）",
        autoFrameFormat135: "135 を優先",
        autoFrameFormat120: "120 を優先",
        autoFrame120Formats: "120 サブ形式",
        autoFrameLowConfidenceBehavior: "低信頼度時の動作",
        autoFrameSuggestOnly: "提案のみ",
        autoFrameRotateOnly: "回転のみ適用",
        autoFrameNoAction: "何もしない",
        autoFrameDiagnostics: "検出情報: 手法 {method} | 形式 {format} | 信頼度 {confidence}",
        exportCurrent: "現在の画像を出力 (PNG)",
        exportZip: "一括出力 (ZIP)",
        exportIndividual: "すべて個別にダウンロード",
        pending: "待機中",
        processingStatus: "処理中",
        done: "完了",
        error: "エラー",
        unsaved: "未保存",
        configured: "設定済",
        customSettings: "設定済",
        autoDetect: "マスク自動検出",
        finishProcessing: "設定を保存する前にワークフロー（ステップ3）を完了してください",
        exportFormat: "出力形式",
        jpegQuality: "JPEG品質",
        exportJpeg: "JPEG出力",
        exportCurrentJpeg: "現在の画像を出力 (JPEG)",
        exportZipJpeg: "一括出力 (ZIP/JPEG)"
      }
    };

    const DEBUG_UI = new URLSearchParams(window.location.search).get('debug') === '1';
    const BUILD_ID = '2026-02-22-auto-frame-detect-3';
    const OPENCV_SCRIPT_CANDIDATES = [
      './vendor/opencv/opencv-4.12.0.js',
      'https://cdn.jsdelivr.net/npm/@techstark/opencv-js@4.12.0-release.1/dist/opencv.js'
    ];
    const AUTO_FRAME_MAX_SIDE = 1600;
    const AUTO_FRAME_FORMAT_RATIOS = {
      '135': 1.5,
      '120-6x4.5': 1.33,
      '120-6x6': 1.0,
      '120-6x7': 1.17,
      '120-6x9': 1.5
    };
    const AUTO_FRAME_DEFAULT_120_FORMATS = ['6x4.5', '6x6', '6x7', '6x9'];
    const AUTO_FRAME_SCORE_WEIGHTS = {
      area: 0.18,
      rectangularity: 0.20,
      orthogonality: 0.14,
      parallelism: 0.10,
      edgeSupport: 0.18,
      centerPrior: 0.08,
      aspect: 0.12
    };
    let opencvReadyPromise = null;
    let opencvActiveSource = null;
    const STEP2_FIRST_HINT_SESSION_KEY = 'nc_step2_first_hint_seen_v1';

    let currentLang = 'en';
    let stateReady = false;
    let step2FirstHintHandled = false;

    function getLocalizedText(key, fallback = '') {
      const dict = i18n[currentLang] || i18n.en || {};
      if (Object.prototype.hasOwnProperty.call(dict, key) && dict[key]) {
        return dict[key];
      }
      return fallback;
    }

    function setLanguage(lang) {
      currentLang = lang;
      document.querySelectorAll('.lang-btn').forEach(btn => {
        btn.classList.toggle('active', btn.dataset.lang === lang);
      });
      document.querySelectorAll('[data-i18n]').forEach(el => {
        const key = el.dataset.i18n;
        if (i18n[lang][key]) {
          el.textContent = i18n[lang][key];
        }
      });
      document.querySelectorAll('[data-i18n-label]').forEach(el => {
        const key = el.dataset.i18nLabel;
        if (i18n[lang][key]) {
          el.label = i18n[lang][key];
        }
      });
      if (stateReady) {
        updateCurrentFileLabel();
        updateRollReferenceUI();
        updateAutoFrameConfigUI();
        updateAutoFrameDiagnosticsUI();
        updateAutoFrameButtons();
        updateStep2GuideCard({ skipFirstHint: true });
      }
    }

    // Detect language
    const browserLang = navigator.language.startsWith('ja') ? 'ja'
      : navigator.language.startsWith('zh') ? 'zh' : 'en';
    setLanguage(browserLang);

    if (DEBUG_UI) {
      const badge = document.getElementById('buildBadge');
      if (badge) {
        badge.style.display = 'inline-flex';
        badge.textContent = `build ${BUILD_ID}`;
      }
    }

    // Language selector
    document.querySelectorAll('.lang-btn').forEach(btn => {
      btn.addEventListener('click', () => setLanguage(btn.dataset.lang));
    });

    // ===========================================
    // Film Presets
    // ===========================================
    const PRESET_DATA_URL = './presets/film_presets.json';
    const PRESET_TYPES = ['color', 'bw', 'positive'];
    const PRESET_GROUPS = [
      { type: 'color', labelKey: 'colorFilms', fallbackLabel: 'Color' },
      { type: 'bw', labelKey: 'bwFilms', fallbackLabel: 'B&W' },
      { type: 'positive', labelKey: 'positiveFilms', fallbackLabel: 'Positive' }
    ];
    const GENERIC_PRESET_I18N_KEYS = {
      generic_color: 'genericColor',
      generic_bw: 'genericBW',
      generic_positive: 'genericPositive'
    };
    const DEFAULT_PRESET_BY_TYPE = {
      color: 'generic_color',
      bw: 'generic_bw',
      positive: 'generic_positive'
    };
    const DEFAULT_FILM_PRESET_LIST = [
      {
        id: 'generic_color',
        name: 'Generic Color',
        brand: 'generic',
        type: 'color',
        status: 'active',
        baseColor: { r: 0.82, g: 0.55, b: 0.36 },
        characteristics: { warmth: 0, saturation: 0, contrast: 0 }
      },
      {
        id: 'generic_bw',
        name: 'Generic B&W',
        brand: 'generic',
        type: 'bw',
        status: 'active',
        contrast: 1.0,
        gamma: 1.0,
        bw: { gamma: 1.0 },
        characteristics: { warmth: 0, saturation: 0, contrast: 0 }
      },
      {
        id: 'generic_positive',
        name: 'Generic Positive',
        brand: 'generic',
        type: 'positive',
        status: 'active',
        characteristics: { warmth: 0, saturation: 0.1, contrast: 0.1 }
      }
    ];

    let FILM_PRESETS = {};
    let FILM_PRESET_LIST = [];
    let FILM_PRESET_ALIASES = {};

    function sanitizePresetType(type) {
      return PRESET_TYPES.includes(type) ? type : 'color';
    }

    function clampUnit(value, fallback) {
      const n = Number(value);
      if (Number.isFinite(n)) return Math.max(0, Math.min(1, n));
      return fallback;
    }

    function normalizePreset(rawPreset) {
      if (!rawPreset || typeof rawPreset !== 'object') return null;
      if (typeof rawPreset.id !== 'string' || !rawPreset.id) return null;

      const type = sanitizePresetType(rawPreset.type);
      const status = rawPreset.status === 'deprecated' ? 'deprecated' : 'active';
      const characteristics = rawPreset.characteristics || {};
      const preset = {
        id: rawPreset.id,
        name: rawPreset.name || rawPreset.id,
        brand: rawPreset.brand || 'generic',
        type,
        status,
        characteristics: {
          warmth: Number.isFinite(characteristics.warmth) ? characteristics.warmth : 0,
          saturation: Number.isFinite(characteristics.saturation) ? characteristics.saturation : 0,
          contrast: Number.isFinite(characteristics.contrast) ? characteristics.contrast : 0
        }
      };

      if (type === 'color') {
        const baseColor = rawPreset.baseColor || {};
        preset.baseColor = {
          r: clampUnit(baseColor.r, 0.82),
          g: clampUnit(baseColor.g, 0.55),
          b: clampUnit(baseColor.b, 0.36)
        };
      }

      if (type === 'bw') {
        const gammaFromNested = rawPreset.bw && Number.isFinite(rawPreset.bw.gamma)
          ? rawPreset.bw.gamma
          : undefined;
        const gamma = Number.isFinite(rawPreset.gamma) ? rawPreset.gamma
          : (gammaFromNested !== undefined ? gammaFromNested : 1.0);
        const contrast = Number.isFinite(rawPreset.contrast) ? rawPreset.contrast : 1.0;
        preset.gamma = gamma;
        preset.contrast = contrast;
        preset.bw = { gamma };
      }

      if (rawPreset.sourceMeta && typeof rawPreset.sourceMeta === 'object') {
        preset.sourceMeta = rawPreset.sourceMeta;
      }

      return preset;
    }

    function buildPresetMap(presetList) {
      const map = {};
      for (const preset of presetList) {
        map[preset.id] = preset;
      }
      return map;
    }

    function applyPresetDataset(dataset) {
      if (!dataset || !Array.isArray(dataset.presets)) return false;
      const list = dataset.presets
        .map(normalizePreset)
        .filter(Boolean);
      if (!list.length) return false;

      FILM_PRESET_LIST = list;
      FILM_PRESETS = buildPresetMap(list);
      FILM_PRESET_ALIASES = (dataset.aliases && typeof dataset.aliases === 'object')
        ? { ...dataset.aliases }
        : {};
      return true;
    }

    function initPresetFallbacks() {
      FILM_PRESET_LIST = DEFAULT_FILM_PRESET_LIST
        .map(normalizePreset)
        .filter(Boolean);
      FILM_PRESETS = buildPresetMap(FILM_PRESET_LIST);
      FILM_PRESET_ALIASES = {};
    }

    function resolvePresetId(presetId) {
      if (typeof presetId !== 'string' || !presetId) return null;
      if (FILM_PRESETS[presetId]) return presetId;
      const aliasTarget = FILM_PRESET_ALIASES[presetId];
      if (aliasTarget && FILM_PRESETS[aliasTarget]) return aliasTarget;
      return null;
    }

    function getDefaultPresetForType(type) {
      const safeType = sanitizePresetType(type);
      const preferredId = DEFAULT_PRESET_BY_TYPE[safeType];
      if (preferredId && FILM_PRESETS[preferredId]) return preferredId;

      const firstActive = FILM_PRESET_LIST.find((preset) => (
        preset.type === safeType && preset.status !== 'deprecated'
      ));
      return firstActive ? firstActive.id : (DEFAULT_PRESET_BY_TYPE.color || 'generic_color');
    }

    function getPresetOrFallback(presetId, fallbackType = 'color') {
      const resolved = resolvePresetId(presetId);
      if (resolved) return FILM_PRESETS[resolved];
      const fallbackId = getDefaultPresetForType(fallbackType);
      return FILM_PRESETS[fallbackId] || FILM_PRESETS.generic_color || null;
    }

    function getBwPresetParams(preset) {
      const safePreset = preset || {};
      const contrast = Number.isFinite(safePreset.contrast) ? safePreset.contrast : 1.0;
      const gamma = Number.isFinite(safePreset.gamma)
        ? safePreset.gamma
        : (safePreset.bw && Number.isFinite(safePreset.bw.gamma) ? safePreset.bw.gamma : 1.0);
      return { contrast, gamma };
    }

    function renderPresetOptions(selectedPresetId = state ? state.filmPreset : null) {
      const presetSelect = document.getElementById('filmPreset');
      if (!presetSelect) return;

      presetSelect.innerHTML = '';
      for (const group of PRESET_GROUPS) {
        const presets = FILM_PRESET_LIST.filter((preset) => (
          preset.type === group.type && preset.status !== 'deprecated'
        ));
        if (!presets.length) continue;

        const optgroup = document.createElement('optgroup');
        optgroup.setAttribute('data-i18n-label', group.labelKey);
        optgroup.label = (i18n[currentLang] && i18n[currentLang][group.labelKey]) || group.fallbackLabel;

        for (const preset of presets) {
          const option = document.createElement('option');
          option.value = preset.id;
          option.textContent = preset.name;
          const i18nKey = GENERIC_PRESET_I18N_KEYS[preset.id];
          if (i18nKey) option.setAttribute('data-i18n', i18nKey);
          optgroup.appendChild(option);
        }
        presetSelect.appendChild(optgroup);
      }

      const resolvedSelection = resolvePresetId(selectedPresetId);
      const fallbackSelection = getDefaultPresetForType(state ? state.filmType : 'color');
      const nextSelection = resolvedSelection || fallbackSelection;
      if (nextSelection && presetSelect.querySelector(`option[value="${nextSelection}"]`)) {
        presetSelect.value = nextSelection;
      } else if (presetSelect.options.length) {
        presetSelect.value = presetSelect.options[0].value;
      }

      if (state && presetSelect.value) {
        state.filmPreset = presetSelect.value;
      }
    }

    async function loadPresetDataset() {
      initPresetFallbacks();
      try {
        const response = await fetch(PRESET_DATA_URL, { cache: 'no-store' });
        if (!response.ok) {
          throw new Error(`Preset dataset request failed: ${response.status}`);
        }
        const payload = await response.json();
        if (!applyPresetDataset(payload)) {
          throw new Error('Preset dataset is invalid.');
        }
      } catch (err) {
        console.warn('Using fallback preset dataset.', err);
      }
      renderPresetOptions(state ? state.filmPreset : null);
      if (typeof setLanguage === 'function') setLanguage(currentLang);
    }

    initPresetFallbacks();

    // ===========================================
    // Application State
    // ===========================================
    const state = {
      // Workflow state
      currentStep: 1,  // 1=crop, 2=film base, 3=adjust

      // Image data
      loadedBaseImageData: null,    // File-loaded baseline (never transformed)
      originalImageData: null,      // Current working base image (may include rotation)
      croppedImageData: null,       // After cropping (still negative)
      processedImageData: null,     // After negative conversion
      displayImageData: null,       // After all adjustments
      previewSourceImageData: null, // Downscaled source for preview renders
      histogramSourceImageData: null, // Further downscaled source for histogram updates
      webglSourceImageData: null,   // Downscaled source for WebGL preview renders

      // Film settings
      filmType: 'color',
      filmPreset: 'generic_color',
      filmBase: { r: 210, g: 140, b: 90 },
      filmBaseSet: false,
      step2Mode: 'border', // 'border' | 'noBorder'

      // White balance multipliers
      wbR: 1.0,
      wbG: 1.0,
      wbB: 1.0,

      // Tone adjustments
      exposure: 0,
      contrast: 0,
      highlights: 0,
      shadows: 0,

      // Color adjustments
      temperature: 0,
      tint: 0,
      vibrance: 0,
      saturation: 0,

      // CMY
      cyan: 0,
      magenta: 0,
      yellow: 0,

      // Curves (256-value lookup tables)
      curves: { r: null, g: null, b: null },
      // Control points for each channel [{x, y}, ...] sorted by x
      curvePoints: {
        r: [{ x: 0, y: 0 }, { x: 255, y: 255 }],
        g: [{ x: 0, y: 0 }, { x: 255, y: 255 }],
        b: [{ x: 0, y: 0 }, { x: 255, y: 255 }]
      },

      // UI state
      cropping: false,
      cropStart: null,
      croppingActive: false,
      samplingMode: null,  // null, 'filmBase', 'whiteBalance'
      rotationAngle: 0,

      autoFrame: {
        enabled: true,
        marginRatio: 0.02,
        minConfidence: 0.55,
        highConfidence: 0.72,
        autoApplyHighConfidence: true,
        formatPreference: 'auto', // 'auto' | '135' | '120'
        allowed120Formats: {
          '6x4.5': true,
          '6x6': true,
          '6x7': true,
          '6x9': true
        },
        lowConfidenceBehavior: 'suggest', // 'suggest' | 'rotateOnly' | 'ignore'
        lastDiagnostics: null
      },

      // Batch mode state
      batchMode: false,
      batchSessionActive: false,
      // fileQueue item: {id, file, selected, status, error, settings: null | {...}, isDirty: boolean}
      // settings = null means use auto-detect for film base
      fileQueue: [],
      currentFileIndex: 0,
      // Saved crop region for current image (used when saving settings)
      cropRegion: null,

      // Roll-level reference profile (session scoped)
      rollReference: {
        enabled: false,
        sourceFileId: null,
        settingsSnapshot: null,
        applyLock: false,
        applyCrop: false
      },

      // Export settings
      exportFormat: 'png',  // 'png' or 'jpeg'
      jpegQuality: 92,      // 1-100

      // Render state
      lastRenderQuality: 'full' // 'full' | 'preview' | 'gl'
    };
    stateReady = true;

    // Initialize curves
    function initCurves(markDirty = false) {
      state.curves.r = new Uint8Array(256);
      state.curves.g = new Uint8Array(256);
      state.curves.b = new Uint8Array(256);
      // Reset control points to linear
      state.curvePoints.r = [{ x: 0, y: 0 }, { x: 255, y: 255 }];
      state.curvePoints.g = [{ x: 0, y: 0 }, { x: 255, y: 255 }];
      state.curvePoints.b = [{ x: 0, y: 0 }, { x: 255, y: 255 }];
      // Fill curves with linear values
      for (let i = 0; i < 256; i++) {
        state.curves.r[i] = i;
        state.curves.g[i] = i;
        state.curves.b[i] = i;
      }

      if (markDirty && webglState.gl) webglState.curveDirty = true;
    }
    initCurves(false);

    // ===========================================
    // Canvas & Context
    // ===========================================
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d', { willReadFrequently: true });
    const glCanvas = document.getElementById('glCanvas');
    const canvasContainer = document.getElementById('canvasContainer');
    const histogramCanvas = document.getElementById('histogramCanvas');
    const histogramCtx = histogramCanvas.getContext('2d');
    const HISTOGRAM_MAX_SAMPLES = 24_576;
    const HISTOGRAM_UPDATE_INTERVAL_MS = 260;
    const curveCanvas = document.getElementById('curveCanvas');
    const curveCtx = curveCanvas.getContext('2d');
    const loupe = document.getElementById('loupe');
    const loupeCanvas = document.getElementById('loupeCanvas');
    const loupeCtx = loupeCanvas.getContext('2d');
    const loupeInfo = document.getElementById('loupeInfo');

    const loupeSrcCanvas = document.createElement('canvas');
    const loupeSrcCtx = loupeSrcCanvas.getContext('2d', { willReadFrequently: true });

    let transformCanvas = document.createElement('canvas');
    let transformCtx = transformCanvas.getContext('2d');

    // ===========================================
    // Workflow Management
    // ===========================================
    const debugUI = {
      fileListSetCalls: 0,
      lastFileListVisible: null,
      lastFileListReason: ''
    };

    function ensureDebugWidget() {
      if (!DEBUG_UI) return null;
      let el = document.getElementById('debugWidget');
      if (el) return el;
      el = document.createElement('div');
      el.id = 'debugWidget';
      el.className = 'debug-widget';
      document.body.appendChild(el);
      return el;
    }

    function updateDebugWidget() {
      if (!DEBUG_UI) return;
      const el = ensureDebugWidget();
      if (!el) return;

      const fileListEl = document.getElementById('fileListSection');
      const fileListDisplay = fileListEl
        ? (fileListEl.style.display || getComputedStyle(fileListEl).display)
        : 'n/a';
      const fileListRect = fileListEl ? fileListEl.getBoundingClientRect() : null;
      const fileListH = fileListRect ? Math.round(fileListRect.height) : 0;

      el.textContent =
        `BUILD ${BUILD_ID}\n` +
        `step=${state.currentStep} queue=${state.fileQueue.length} idx=${state.currentFileIndex}\n` +
        `batchSessionActive=${state.batchSessionActive} batchMode=${state.batchMode}\n` +
        `fileList display=${fileListDisplay} h=${fileListH}\n` +
        `fileList last=${debugUI.lastFileListVisible} reason=${debugUI.lastFileListReason}\n` +
        `fileList setCalls=${debugUI.fileListSetCalls}`;
    }

    function setFileListVisible(visible, reason) {
      const fileListEl = document.getElementById('fileListSection');
      if (!fileListEl) return;

      // Once a batch session is active, keep the list visible unless the session is explicitly cleared.
      if (!visible && state.batchSessionActive) {
        visible = true;
        reason = `${reason || 'unknown'} (blocked)`;
      }

      const nextDisplay = visible ? 'block' : 'none';
      if (fileListEl.style.display !== nextDisplay) {
        fileListEl.style.display = nextDisplay;
      }

      if (DEBUG_UI) {
        debugUI.fileListSetCalls++;
        debugUI.lastFileListVisible = visible;
        debugUI.lastFileListReason = reason || '';
        updateDebugWidget();
      }
    }

    function updateBatchStep3GuideVisibility() {
      const guide = document.getElementById('batchStep3GuideBox');
      if (!guide) return;
      guide.style.display = (state.batchSessionActive && state.currentStep >= 3) ? 'block' : 'none';
    }

    function syncBatchUIState(options = {}) {
      if (state.fileQueue.length > 1) state.batchSessionActive = true;

      state.batchMode = state.batchSessionActive;
      showBatchUI(state.batchSessionActive, options.reason || 'syncBatchUIState');

      const saveSettingsBtn = document.getElementById('saveSettingsBtn');
      const applyToSelectedBtn = document.getElementById('applyToSelectedBtn');
      const showBatchStep3Actions = state.batchSessionActive && state.currentStep >= 3;
      if (saveSettingsBtn) {
        saveSettingsBtn.style.display = showBatchStep3Actions ? 'inline-flex' : 'none';
      }
      if (applyToSelectedBtn) {
        applyToSelectedBtn.style.display = showBatchStep3Actions ? 'inline-flex' : 'none';
      }

      updateCurrentFileLabel();
      updateRollReferenceUI();
      updateAutoFrameButtons();
      updateDebugWidget();
    }

    function revealBatchFileList(reason = 'revealBatchFileList') {
      if (!state.batchSessionActive) return;

      const controlsPanel = document.getElementById('controlsPanel');
      if (!controlsPanel) return;

      setFileListVisible(true, reason);
      controlsPanel.scrollTop = 0;
    }

    function getCurrentQueueItem() {
      if (state.currentFileIndex < 0 || state.currentFileIndex >= state.fileQueue.length) return null;
      return state.fileQueue[state.currentFileIndex];
    }

    function getQueueItemById(id) {
      if (!id) return null;
      return state.fileQueue.find(item => item.id === id) || null;
    }

    function hasRollReference() {
      return Boolean(state.rollReference.enabled && state.rollReference.settingsSnapshot);
    }

    function resetRollReferenceState() {
      state.rollReference.enabled = false;
      state.rollReference.sourceFileId = null;
      state.rollReference.settingsSnapshot = null;
      state.rollReference.applyLock = false;
      state.rollReference.applyCrop = false;
    }

    function updateCurrentFileLabel() {
      const label = document.getElementById('currentFileLabel');
      if (!label) return;

      const item = getCurrentQueueItem();
      if (!item || !item.file) {
        label.style.display = 'none';
        label.textContent = '';
        return;
      }

      const prefix = i18n[currentLang].currentFile || 'Current File';
      const unsavedText = item.isDirty ? ` • ${i18n[currentLang].unsaved || 'Unsaved'}` : '';
      label.textContent = `${prefix}: ${item.file.name}${unsavedText}`;
      label.style.display = 'inline-flex';
    }

    function updateRollReferenceUI() {
      const statusEl = document.getElementById('rollReferenceStatus');
      const setBtn = document.getElementById('setRollReferenceBtn');
      const applyBtn = document.getElementById('applyRollReferenceBtn');
      const clearBtn = document.getElementById('clearRollReferenceBtn');
      const useBtn = document.getElementById('useReferenceBtn');
      const lockInput = document.getElementById('lockRollReference');
      const cropInput = document.getElementById('applyCropWithReference');
      const controlsEl = document.getElementById('rollReferenceControls');
      if (!statusEl || !setBtn || !applyBtn || !clearBtn || !lockInput || !cropInput || !controlsEl) return;

      const showControls = requiresFilmBase();
      controlsEl.style.display = showControls ? 'flex' : 'none';
      if (!showControls) return;

      const hasReference = hasRollReference();
      const sourceItem = getQueueItemById(state.rollReference.sourceFileId);
      const sourceName = sourceItem ? sourceItem.file.name : 'n/a';

      statusEl.textContent = hasReference
        ? (i18n[currentLang].rollReferenceActive || 'Reference source: {file}').replace('{file}', sourceName)
        : (i18n[currentLang].rollReferenceNone || 'No roll reference set.');

      setBtn.disabled = !(state.currentStep >= 3 && state.processedImageData);
      applyBtn.disabled = !hasReference;
      clearBtn.disabled = !hasReference;
      if (useBtn) useBtn.disabled = !hasReference;
      lockInput.checked = Boolean(state.rollReference.applyLock);
      cropInput.checked = Boolean(state.rollReference.applyCrop);
      lockInput.disabled = !hasReference;
      cropInput.disabled = !hasReference;
    }

    function updateWorkflowUI() {
      const steps = ['step1', 'step2', 'step3'];
      const badge = document.getElementById('statusBadge');

      steps.forEach((stepId, idx) => {
        const stepEl = document.getElementById(stepId);
        stepEl.classList.remove('active', 'completed');
        if (idx + 1 < state.currentStep) {
          stepEl.classList.add('completed');
        } else if (idx + 1 === state.currentStep) {
          stepEl.classList.add('active');
        }
      });

      // Update badge
      badge.className = 'status-badge step' + state.currentStep;
      badge.setAttribute('data-i18n', 'step' + state.currentStep);
      badge.textContent = i18n[currentLang]['step' + state.currentStep];

      // Show/hide sections based on step
      document.getElementById('autoFrameSettingsSection').style.display =
        state.currentStep === 1 ? 'block' : 'none';
      document.getElementById('filmSettingsSection').style.display =
        state.currentStep >= 2 ? 'block' : 'none';

      const step3Sections = ['whiteBalanceSection', 'toneSection', 'colorSection', 'cmySection', 'advancedSection'];
      step3Sections.forEach(id => {
        document.getElementById(id).style.display = state.currentStep >= 3 ? 'block' : 'none';
      });

      // Show convert button after cropping is done
      document.getElementById('convertSeparator').style.display =
        state.currentStep === 1 ? 'inline-block' : 'none';
      document.getElementById('convertBtn').style.display =
        state.currentStep === 1 ? 'inline-flex' : 'none';
      document.getElementById('convertPositiveBtn').style.display =
        state.currentStep === 1 ? 'inline-flex' : 'none';

      syncBatchUIState({ reason: 'updateWorkflowUI' });
      updateAutoFrameButtons();
    }

    function goToStep(step) {
      state.currentStep = step;
      if (step === 2 && requiresFilmBase()) {
        setStep2Mode(suggestStep2Mode());
      }
      updateWorkflowUI();
      updateCanvasVisibility();
    }

    // ===========================================
    // Core Negative Processing Algorithm
    // ===========================================
    function sampleFilmBase(imageData, x, y, radius = 10) {
      const { width, height, data } = imageData;
      let rSum = 0, gSum = 0, bSum = 0, count = 0;

      const startX = Math.max(0, x - radius);
      const endX = Math.min(width - 1, x + radius);
      const startY = Math.max(0, y - radius);
      const endY = Math.min(height - 1, y + radius);

      for (let py = startY; py <= endY; py++) {
        for (let px = startX; px <= endX; px++) {
          const idx = (py * width + px) * 4;
          rSum += data[idx];
          gSum += data[idx + 1];
          bSum += data[idx + 2];
          count++;
        }
      }

      return {
        r: Math.round(rSum / count),
        g: Math.round(gSum / count),
        b: Math.round(bSum / count)
      };
    }

    function autoDetectFilmBase(imageData) {
      const { width, height, data } = imageData;
      const edgeSize = Math.min(50, Math.floor(Math.min(width, height) * 0.05));

      let candidates = [];
      const regions = [
        { x: width / 2, y: edgeSize / 2 },
        { x: width / 2, y: height - edgeSize / 2 },
        { x: edgeSize / 2, y: height / 2 },
        { x: width - edgeSize / 2, y: height / 2 },
        { x: edgeSize / 2, y: edgeSize / 2 },
        { x: width - edgeSize / 2, y: edgeSize / 2 },
        { x: edgeSize / 2, y: height - edgeSize / 2 },
        { x: width - edgeSize / 2, y: height - edgeSize / 2 }
      ];

      for (const region of regions) {
        const sample = sampleFilmBase(imageData, Math.floor(region.x), Math.floor(region.y), edgeSize);
        const brightness = (sample.r + sample.g + sample.b) / 3;
        candidates.push({ ...sample, brightness });
      }

      candidates.sort((a, b) => b.brightness - a.brightness);
      return { r: candidates[0].r, g: candidates[0].g, b: candidates[0].b };
    }

    function convertColorNegative(imageData, filmBase) {
      const { width, height, data } = imageData;
      const output = new ImageData(new Uint8ClampedArray(data.length), width, height);
      const outData = output.data;

      const baseR = filmBase.r / 255;
      const baseG = filmBase.g / 255;
      const baseB = filmBase.b / 255;
      const eps = 0.001;

      const normalized = new Float32Array(data.length);

      for (let i = 0; i < data.length; i += 4) {
        let r = data[i] / 255;
        let g = data[i + 1] / 255;
        let b = data[i + 2] / 255;

        r = r / Math.max(baseR, eps);
        g = g / Math.max(baseG, eps);
        b = b / Math.max(baseB, eps);

        r = Math.min(r, 2);
        g = Math.min(g, 2);
        b = Math.min(b, 2);

        r = 1 / Math.max(r, eps);
        g = 1 / Math.max(g, eps);
        b = 1 / Math.max(b, eps);

        normalized[i] = r;
        normalized[i + 1] = g;
        normalized[i + 2] = b;
        normalized[i + 3] = 1;
      }

      let rMin = Infinity, rMax = -Infinity;
      let gMin = Infinity, gMax = -Infinity;
      let bMin = Infinity, bMax = -Infinity;

      for (let i = 0; i < normalized.length; i += 4) {
        rMin = Math.min(rMin, normalized[i]);
        rMax = Math.max(rMax, normalized[i]);
        gMin = Math.min(gMin, normalized[i + 1]);
        gMax = Math.max(gMax, normalized[i + 1]);
        bMin = Math.min(bMin, normalized[i + 2]);
        bMax = Math.max(bMax, normalized[i + 2]);
      }

      const rHist = new Float32Array(1000);
      const gHist = new Float32Array(1000);
      const bHist = new Float32Array(1000);

      for (let i = 0; i < normalized.length; i += 4) {
        const rIdx = Math.min(999, Math.floor((normalized[i] - rMin) / (rMax - rMin + 0.001) * 999));
        const gIdx = Math.min(999, Math.floor((normalized[i + 1] - gMin) / (gMax - gMin + 0.001) * 999));
        const bIdx = Math.min(999, Math.floor((normalized[i + 2] - bMin) / (bMax - bMin + 0.001) * 999));
        rHist[rIdx]++;
        gHist[gIdx]++;
        bHist[bIdx]++;
      }

      const pixelCount = width * height;
      function findPercentile(hist, target) {
        let sum = 0;
        for (let i = 0; i < hist.length; i++) {
          sum += hist[i];
          if (sum >= target) return i / 999;
        }
        return 1;
      }

      const rLow = rMin + (rMax - rMin) * findPercentile(rHist, pixelCount * 0.02);
      const rHigh = rMin + (rMax - rMin) * findPercentile(rHist, pixelCount * 0.98);
      const gLow = gMin + (gMax - gMin) * findPercentile(gHist, pixelCount * 0.02);
      const gHigh = gMin + (gMax - gMin) * findPercentile(gHist, pixelCount * 0.98);
      const bLow = bMin + (bMax - bMin) * findPercentile(bHist, pixelCount * 0.02);
      const bHigh = bMin + (bMax - bMin) * findPercentile(bHist, pixelCount * 0.98);

      for (let i = 0; i < normalized.length; i += 4) {
        let r = (normalized[i] - rLow) / (rHigh - rLow + 0.001);
        let g = (normalized[i + 1] - gLow) / (gHigh - gLow + 0.001);
        let b = (normalized[i + 2] - bLow) / (bHigh - bLow + 0.001);

        const gamma = 1.1;
        r = Math.pow(Math.max(0, Math.min(1, r)), gamma);
        g = Math.pow(Math.max(0, Math.min(1, g)), gamma);
        b = Math.pow(Math.max(0, Math.min(1, b)), gamma);

        outData[i] = Math.round(r * 255);
        outData[i + 1] = Math.round(g * 255);
        outData[i + 2] = Math.round(b * 255);
        outData[i + 3] = 255;
      }

      return output;
    }

    function convertBWNegative(imageData, options = {}) {
      const { width, height, data } = imageData;
      const output = new ImageData(new Uint8ClampedArray(data.length), width, height);
      const outData = output.data;

      const contrast = options.contrast || 1.0;
      const gamma = options.gamma || 1.0;

      const grayValues = new Float32Array(width * height);

      for (let i = 0; i < data.length; i += 4) {
        const gray = (data[i] * 0.299 + data[i + 1] * 0.587 + data[i + 2] * 0.114) / 255;
        grayValues[i / 4] = 1 - gray;
      }

      const sorted = Float32Array.from(grayValues).sort();
      const p2 = sorted[Math.floor(sorted.length * 0.02)];
      const p98 = sorted[Math.floor(sorted.length * 0.98)];

      for (let i = 0; i < grayValues.length; i++) {
        let v = (grayValues[i] - p2) / (p98 - p2 + 0.001);
        v = Math.max(0, Math.min(1, v));
        v = ((v - 0.5) * contrast) + 0.5;
        v = Math.max(0, Math.min(1, v));
        v = Math.pow(v, gamma);

        const byte = Math.round(v * 255);
        const idx = i * 4;
        outData[idx] = byte;
        outData[idx + 1] = byte;
        outData[idx + 2] = byte;
        outData[idx + 3] = 255;
      }

      return output;
    }

    function convertPositiveFilm(imageData, options = {}) {
      const { width, height, data } = imageData;
      const output = new ImageData(new Uint8ClampedArray(data.length), width, height);
      const outData = output.data;
      const pixelCount = width * height;

      const clipPercent = Math.max(0, Math.min(0.1, options.clipPercent ?? 0.01));
      const lowTarget = pixelCount * clipPercent;
      const highTarget = pixelCount * (1 - clipPercent);

      const rHist = new Uint32Array(256);
      const gHist = new Uint32Array(256);
      const bHist = new Uint32Array(256);

      for (let i = 0; i < data.length; i += 4) {
        rHist[data[i]]++;
        gHist[data[i + 1]]++;
        bHist[data[i + 2]]++;
      }

      function histogramPercentile(hist, target) {
        let sum = 0;
        for (let i = 0; i < hist.length; i++) {
          sum += hist[i];
          if (sum >= target) return i;
        }
        return hist.length - 1;
      }

      const rLow = histogramPercentile(rHist, lowTarget);
      const gLow = histogramPercentile(gHist, lowTarget);
      const bLow = histogramPercentile(bHist, lowTarget);
      const rHigh = histogramPercentile(rHist, highTarget);
      const gHigh = histogramPercentile(gHist, highTarget);
      const bHigh = histogramPercentile(bHist, highTarget);

      const rScale = 255 / Math.max(1, rHigh - rLow);
      const gScale = 255 / Math.max(1, gHigh - gLow);
      const bScale = 255 / Math.max(1, bHigh - bLow);

      for (let i = 0; i < data.length; i += 4) {
        let r = (data[i] - rLow) * rScale;
        let g = (data[i + 1] - gLow) * gScale;
        let b = (data[i + 2] - bLow) * bScale;

        if (r < 0) r = 0; else if (r > 255) r = 255;
        if (g < 0) g = 0; else if (g > 255) g = 255;
        if (b < 0) b = 0; else if (b > 255) b = 255;

        outData[i] = (r + 0.5) | 0;
        outData[i + 1] = (g + 0.5) | 0;
        outData[i + 2] = (b + 0.5) | 0;
        outData[i + 3] = 255;
      }

      return output;
    }

    // ===========================================
    // Pixel Adjustments (Optimized)
    // ===========================================
    function ensureImageDataBuffer(buffer, width, height) {
      if (buffer && buffer.width === width && buffer.height === height) return buffer;
      return new ImageData(new Uint8ClampedArray(width * height * 4), width, height);
    }

    function hue2rgb(p, q, t) {
      if (t < 0) t += 1;
      if (t > 1) t -= 1;
      if (t < 1 / 6) return p + (q - p) * 6 * t;
      if (t < 1 / 2) return q;
      if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;
      return p;
    }

    const channelLutR = new Uint8Array(256);
    const channelLutG = new Uint8Array(256);
    const channelLutB = new Uint8Array(256);

    function buildChannelLuts({
      lutR,
      lutG,
      lutB,
      curveR,
      curveG,
      curveB,
      rMult,
      gMult,
      bMult,
      contrastFactor,
      doContrast,
      doTempTint,
      tempRMult,
      tintGMult,
      tempBMult,
      doCMY,
      cmyRShift,
      cmyGShift,
      cmyBShift
    }) {
      for (let v = 0; v < 256; v++) {
        let r = v * rMult;
        let g = v * gMult;
        let b = v * bMult;

        if (doContrast) {
          r = (r - 127.5) * contrastFactor + 127.5;
          g = (g - 127.5) * contrastFactor + 127.5;
          b = (b - 127.5) * contrastFactor + 127.5;
        }

        if (doTempTint) {
          r *= tempRMult;
          g *= tintGMult;
          b *= tempBMult;
        }

        if (r < 0) r = 0; else if (r > 255) r = 255;
        if (g < 0) g = 0; else if (g > 255) g = 255;
        if (b < 0) b = 0; else if (b > 255) b = 255;

        if (doCMY) {
          r -= cmyRShift;
          g -= cmyGShift;
          b -= cmyBShift;

          if (r < 0) r = 0; else if (r > 255) r = 255;
          if (g < 0) g = 0; else if (g > 255) g = 255;
          if (b < 0) b = 0; else if (b > 255) b = 255;
        }

        lutR[v] = curveR[(r + 0.5) | 0];
        lutG[v] = curveG[(g + 0.5) | 0];
        lutB[v] = curveB[(b + 0.5) | 0];
      }
    }

    function applyAdjustmentsToBuffer(imageData, settings, output, quality = 'full') {
      const { data } = imageData;
      const outData = output.data;

      const preset = getPresetOrFallback(settings.filmPreset, settings.filmType || 'color');
      const presetChars = (preset && preset.characteristics) ? preset.characteristics : {};

      const exposureMult = Math.pow(2, settings.exposure);
      const contrastFactor = 1 + ((settings.contrast + (presetChars.contrast || 0) * 100) / 100);
      const tempFactor = (settings.temperature + (presetChars.warmth || 0) * 100) / 100;
      const tintFactor = settings.tint / 100;
      const satFactor = 1 + ((settings.saturation + (presetChars.saturation || 0) * 100) / 100);
      const vibFactor = settings.vibrance / 100;
      const highlightsFactor = settings.highlights / 100;
      const shadowsFactor = settings.shadows / 100;

      const rMult = settings.wbR * exposureMult;
      const gMult = settings.wbG * exposureMult;
      const bMult = settings.wbB * exposureMult;

      const tempRMult = 1 + tempFactor * 0.3;
      const tempBMult = 1 - tempFactor * 0.3;
      const tintGMult = 1 + tintFactor * 0.3;

      const cmyRShift = settings.cyan * 2.55;
      const cmyGShift = settings.magenta * 2.55;
      const cmyBShift = settings.yellow * 2.55;

      const curveR = settings.curves.r;
      const curveG = settings.curves.g;
      const curveB = settings.curves.b;

      const doContrast = contrastFactor !== 1;
      const doHighlights = highlightsFactor !== 0;
      const doShadows = shadowsFactor !== 0;
      const doTempTint = tempFactor !== 0 || tintFactor !== 0;
      const doHsl = satFactor !== 1 || vibFactor !== 0;
      const doCMY = cmyRShift !== 0 || cmyGShift !== 0 || cmyBShift !== 0;

      const lumaScale = 2 / 255;

      // Fast path: when adjustments are per-channel only, precompute LUTs once and do 3 lookups per pixel.
      if (!doHighlights && !doShadows && !doHsl) {
        buildChannelLuts({
          lutR: channelLutR,
          lutG: channelLutG,
          lutB: channelLutB,
          curveR,
          curveG,
          curveB,
          rMult,
          gMult,
          bMult,
          contrastFactor,
          doContrast,
          doTempTint,
          tempRMult,
          tintGMult,
          tempBMult,
          doCMY,
          cmyRShift,
          cmyGShift,
          cmyBShift
        });

        for (let i = 0; i < data.length; i += 4) {
          outData[i] = channelLutR[data[i]];
          outData[i + 1] = channelLutG[data[i + 1]];
          outData[i + 2] = channelLutB[data[i + 2]];
          outData[i + 3] = 255;
        }
        return;
      }

      for (let i = 0; i < data.length; i += 4) {
        let r = data[i] * rMult;
        let g = data[i + 1] * gMult;
        let b = data[i + 2] * bMult;

        if (doContrast) {
          r = (r - 127.5) * contrastFactor + 127.5;
          g = (g - 127.5) * contrastFactor + 127.5;
          b = (b - 127.5) * contrastFactor + 127.5;
        }

        if (doHighlights || doShadows) {
          const luma = (r * 0.299 + g * 0.587 + b * 0.114);
          if (doHighlights && luma > 127.5) {
            const mult = 1 + highlightsFactor * (luma - 127.5) * lumaScale;
            r *= mult; g *= mult; b *= mult;
          }
          if (doShadows && luma < 127.5) {
            const mult = 1 + shadowsFactor * (127.5 - luma) * lumaScale;
            r *= mult; g *= mult; b *= mult;
          }
        }

        if (doTempTint) {
          r *= tempRMult;
          b *= tempBMult;
          g *= tintGMult;
        }

        if (r < 0) r = 0; else if (r > 255) r = 255;
        if (g < 0) g = 0; else if (g > 255) g = 255;
        if (b < 0) b = 0; else if (b > 255) b = 255;

        // The old pipeline always rounded here (via an HSL round-trip),
        // so keep rounding even when saturation/vibrance is neutral.
        if (!doHsl) {
          r = (r + 0.5) | 0;
          g = (g + 0.5) | 0;
          b = (b + 0.5) | 0;
        }

        if (doHsl) {
          if (quality === 'preview') {
            // Fast approximation in RGB space (much cheaper than HSL), used only for interactive previews.
            const max = r > g ? (r > b ? r : b) : (g > b ? g : b);
            const min = r < g ? (r < b ? r : b) : (g < b ? g : b);

            // Per-pixel saturation measure (HSV saturation) to modulate vibrance.
            const hsvSat = max <= 0 ? 0 : (max - min) / max;
            let vibScale = 1;
            if (vibFactor >= 0) vibScale = 1 + vibFactor * (1 - hsvSat);
            else vibScale = 1 + vibFactor;

            const scale = satFactor * vibScale;
            const gray = (r * 0.299 + g * 0.587 + b * 0.114);

            r = gray + (r - gray) * scale;
            g = gray + (g - gray) * scale;
            b = gray + (b - gray) * scale;

            if (r < 0) r = 0; else if (r > 255) r = 255;
            if (g < 0) g = 0; else if (g > 255) g = 255;
            if (b < 0) b = 0; else if (b > 255) b = 255;

            r = (r + 0.5) | 0;
            g = (g + 0.5) | 0;
            b = (b + 0.5) | 0;
          } else {
          let rn = r / 255;
          let gn = g / 255;
          let bn = b / 255;

          const max = rn > gn ? (rn > bn ? rn : bn) : (gn > bn ? gn : bn);
          const min = rn < gn ? (rn < bn ? rn : bn) : (gn < bn ? gn : bn);
          let h = 0;
          let s = 0;
          const l = (max + min) / 2;

          if (max !== min) {
            const d = max - min;
            s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
            if (max === rn) h = (gn - bn) / d + (gn < bn ? 6 : 0);
            else if (max === gn) h = (bn - rn) / d + 2;
            else h = (rn - gn) / d + 4;
            h /= 6;
          }

          // Saturation + vibrance adjustments (same semantics as the original HSL approach)
          s *= satFactor;
          if (vibFactor >= 0) s += (1 - s) * vibFactor;
          else s *= (1 + vibFactor);
          if (s < 0) s = 0; else if (s > 1) s = 1;

          if (s === 0) {
            const v = Math.round(l * 255);
            r = v; g = v; b = v;
          } else {
            const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
            const p = 2 * l - q;
            rn = hue2rgb(p, q, h + 1 / 3);
            gn = hue2rgb(p, q, h);
            bn = hue2rgb(p, q, h - 1 / 3);
            r = Math.round(rn * 255);
            g = Math.round(gn * 255);
            b = Math.round(bn * 255);
          }
          }
        }

        if (doCMY) {
          r -= cmyRShift;
          g -= cmyGShift;
          b -= cmyBShift;

          if (r < 0) r = 0; else if (r > 255) r = 255;
          if (g < 0) g = 0; else if (g > 255) g = 255;
          if (b < 0) b = 0; else if (b > 255) b = 255;
        }

        r = curveR[(r + 0.5) | 0];
        g = curveG[(g + 0.5) | 0];
        b = curveB[(b + 0.5) | 0];

        outData[i] = r;
        outData[i + 1] = g;
        outData[i + 2] = b;
        outData[i + 3] = 255;
      }
    }

    function buildPreviewSourceImageData(imageData) {
      const { width, height, data } = imageData;
      const totalPixels = width * height;
      // Keep interactive preview responsive on slower machines.
      const maxPixels = 250_000;

      if (totalPixels <= maxPixels) return imageData;

      const step = Math.ceil(Math.sqrt(totalPixels / maxPixels));
      const outW = Math.max(1, Math.floor(width / step));
      const outH = Math.max(1, Math.floor(height / step));

      const out = new ImageData(new Uint8ClampedArray(outW * outH * 4), outW, outH);
      const outData = out.data;

      for (let y = 0; y < outH; y++) {
        const sy = Math.min(height - 1, y * step);
        for (let x = 0; x < outW; x++) {
          const sx = Math.min(width - 1, x * step);
          const srcIdx = (sy * width + sx) * 4;
          const dstIdx = (y * outW + x) * 4;
          outData[dstIdx] = data[srcIdx];
          outData[dstIdx + 1] = data[srcIdx + 1];
          outData[dstIdx + 2] = data[srcIdx + 2];
          outData[dstIdx + 3] = 255;
        }
      }

      return out;
    }

    function buildHistogramSourceImageData(imageData) {
      if (!imageData) return null;

      const { width, height, data } = imageData;
      const totalPixels = width * height;
      const maxPixels = HISTOGRAM_MAX_SAMPLES;

      if (totalPixels <= maxPixels) return imageData;

      const step = Math.ceil(Math.sqrt(totalPixels / maxPixels));
      const outW = Math.max(1, Math.floor(width / step));
      const outH = Math.max(1, Math.floor(height / step));

      const out = new ImageData(new Uint8ClampedArray(outW * outH * 4), outW, outH);
      const outData = out.data;

      for (let y = 0; y < outH; y++) {
        const sy = Math.min(height - 1, y * step);
        for (let x = 0; x < outW; x++) {
          const sx = Math.min(width - 1, x * step);
          const srcIdx = (sy * width + sx) * 4;
          const dstIdx = (y * outW + x) * 4;
          outData[dstIdx] = data[srcIdx];
          outData[dstIdx + 1] = data[srcIdx + 1];
          outData[dstIdx + 2] = data[srcIdx + 2];
          outData[dstIdx + 3] = 255;
        }
      }

      return out;
    }

    function buildWebglSourceImageData(imageData, maxDim = 2048) {
      if (!imageData) return null;
      const { width, height, data } = imageData;
      const scale = Math.max(width / maxDim, height / maxDim, 1);
      const step = Math.ceil(scale);
      if (step <= 1) return imageData;

      const outW = Math.max(1, Math.floor(width / step));
      const outH = Math.max(1, Math.floor(height / step));
      const out = new ImageData(new Uint8ClampedArray(outW * outH * 4), outW, outH);
      const outData = out.data;

      for (let y = 0; y < outH; y++) {
        const sy = Math.min(height - 1, y * step);
        for (let x = 0; x < outW; x++) {
          const sx = Math.min(width - 1, x * step);
          const srcIdx = (sy * width + sx) * 4;
          const dstIdx = (y * outW + x) * 4;
          outData[dstIdx] = data[srcIdx];
          outData[dstIdx + 1] = data[srcIdx + 1];
          outData[dstIdx + 2] = data[srcIdx + 2];
          outData[dstIdx + 3] = 255;
        }
      }

      return out;
    }

    // ===========================================
    // Histogram (Lightroom-style)
    // ===========================================
    const HISTOGRAM_BINS = 256;
    const histogramR = new Uint32Array(HISTOGRAM_BINS);
    const histogramG = new Uint32Array(HISTOGRAM_BINS);
    const histogramB = new Uint32Array(HISTOGRAM_BINS);
    const histogramL = new Uint32Array(HISTOGRAM_BINS);
    const histogramSmoothR = new Float32Array(HISTOGRAM_BINS);
    const histogramSmoothG = new Float32Array(HISTOGRAM_BINS);
    const histogramSmoothB = new Float32Array(HISTOGRAM_BINS);
    const histogramSmoothL = new Float32Array(HISTOGRAM_BINS);
    const histogramX = new Float32Array(HISTOGRAM_BINS);
    let histogramXWidth = 0;

    function smoothHistogram(src, dst) {
      dst[0] = (src[0] * 4 + src[1] * 2 + src[2]) / 7;
      for (let i = 1; i < 255; i++) {
        dst[i] = (src[i - 1] + src[i] * 2 + src[i + 1]) * 0.25;
      }
      dst[255] = (src[253] + src[254] * 2 + src[255] * 4) / 7;
    }

    function ensureHistogramX(width) {
      if (histogramXWidth === width) return;
      const scale = (width - 1) / 255;
      for (let i = 0; i < HISTOGRAM_BINS; i++) {
        histogramX[i] = i * scale;
      }
      histogramXWidth = width;
    }

    function renderHistogram(imageData) {
      if (!imageData) return;

      const baseW = histogramCanvas.offsetWidth || histogramCanvas.clientWidth;
      const baseH = histogramCanvas.offsetHeight || histogramCanvas.clientHeight;
      if (baseW <= 0 || baseH <= 0) return;

      const dpr = window.devicePixelRatio || 1;
      const cw = histogramCanvas.width = Math.max(1, Math.round(baseW * dpr));
      const ch = histogramCanvas.height = Math.max(1, Math.round(baseH * dpr));
      ensureHistogramX(cw);

      histogramR.fill(0);
      histogramG.fill(0);
      histogramB.fill(0);
      histogramL.fill(0);

      const { data } = imageData;
      const totalPixels = data.length >> 2;
      const sampleStep = Math.max(1, Math.ceil(totalPixels / HISTOGRAM_MAX_SAMPLES));
      const sampleStride = sampleStep << 2;
      let sampleCount = 0;

      for (let i = 0; i < data.length; i += sampleStride) {
        const r = data[i];
        const g = data[i + 1];
        const b = data[i + 2];
        histogramR[r]++;
        histogramG[g]++;
        histogramB[b]++;
        histogramL[(r * 77 + g * 150 + b * 29) >> 8]++;
        sampleCount++;
      }
      if (sampleCount === 0) return;

      smoothHistogram(histogramR, histogramSmoothR);
      smoothHistogram(histogramG, histogramSmoothG);
      smoothHistogram(histogramB, histogramSmoothB);
      smoothHistogram(histogramL, histogramSmoothL);

      let maxVal = 0;
      for (let i = 0; i < HISTOGRAM_BINS; i++) {
        if (histogramSmoothR[i] > maxVal) maxVal = histogramSmoothR[i];
        if (histogramSmoothG[i] > maxVal) maxVal = histogramSmoothG[i];
        if (histogramSmoothB[i] > maxVal) maxVal = histogramSmoothB[i];
        if (histogramSmoothL[i] > maxVal) maxVal = histogramSmoothL[i];
      }
      if (maxVal <= 0) return;

      const logScale = (ch - dpr * 3) / Math.log1p(maxVal);
      const toY = (value) => ch - Math.log1p(value) * logScale - dpr;

      const bg = histogramCtx.createLinearGradient(0, 0, 0, ch);
      bg.addColorStop(0, '#1b1b1b');
      bg.addColorStop(1, '#0f0f0f');
      histogramCtx.fillStyle = bg;
      histogramCtx.fillRect(0, 0, cw, ch);

      histogramCtx.strokeStyle = 'rgba(255, 255, 255, 0.08)';
      histogramCtx.lineWidth = Math.max(1, dpr * 0.8);
      for (let i = 1; i < 5; i++) {
        const x = (cw * i) / 5;
        histogramCtx.beginPath();
        histogramCtx.moveTo(x, dpr * 2);
        histogramCtx.lineTo(x, ch - dpr * 2);
        histogramCtx.stroke();
      }

      function drawHistogramCurve(values, fillColor, strokeColor, composite) {
        histogramCtx.globalCompositeOperation = composite;
        histogramCtx.beginPath();
        histogramCtx.moveTo(0, ch - dpr);
        for (let i = 0; i < HISTOGRAM_BINS; i++) {
          histogramCtx.lineTo(histogramX[i], toY(values[i]));
        }
        histogramCtx.lineTo(cw - 1, ch - dpr);
        histogramCtx.closePath();
        histogramCtx.fillStyle = fillColor;
        histogramCtx.fill();

        histogramCtx.beginPath();
        histogramCtx.moveTo(0, toY(values[0]));
        for (let i = 1; i < HISTOGRAM_BINS; i++) {
          histogramCtx.lineTo(histogramX[i], toY(values[i]));
        }
        histogramCtx.strokeStyle = strokeColor;
        histogramCtx.lineWidth = Math.max(1, dpr * 0.9);
        histogramCtx.stroke();
      }

      drawHistogramCurve(histogramSmoothL, 'rgba(228, 228, 228, 0.22)', 'rgba(245, 245, 245, 0.42)', 'source-over');
      drawHistogramCurve(histogramSmoothR, 'rgba(255, 90, 90, 0.20)', 'rgba(255, 110, 110, 0.70)', 'lighter');
      drawHistogramCurve(histogramSmoothG, 'rgba(90, 230, 120, 0.20)', 'rgba(120, 245, 145, 0.70)', 'lighter');
      drawHistogramCurve(histogramSmoothB, 'rgba(110, 180, 255, 0.20)', 'rgba(135, 200, 255, 0.72)', 'lighter');
      histogramCtx.globalCompositeOperation = 'source-over';

      const shadowClipRatio = (histogramL[0] + histogramL[1] + histogramL[2]) / sampleCount;
      const highlightClipRatio = (histogramL[253] + histogramL[254] + histogramL[255]) / sampleCount;
      const indicatorSize = Math.max(6, Math.round(7 * dpr));
      const indicatorMargin = Math.max(3, Math.round(4 * dpr));

      if (shadowClipRatio > 0.008) {
        histogramCtx.fillStyle = '#5da9ff';
        histogramCtx.beginPath();
        histogramCtx.moveTo(indicatorMargin, indicatorMargin);
        histogramCtx.lineTo(indicatorMargin + indicatorSize, indicatorMargin);
        histogramCtx.lineTo(indicatorMargin, indicatorMargin + indicatorSize);
        histogramCtx.closePath();
        histogramCtx.fill();
      }

      if (highlightClipRatio > 0.008) {
        histogramCtx.fillStyle = '#ff6f6f';
        histogramCtx.beginPath();
        histogramCtx.moveTo(cw - indicatorMargin, indicatorMargin);
        histogramCtx.lineTo(cw - indicatorMargin - indicatorSize, indicatorMargin);
        histogramCtx.lineTo(cw - indicatorMargin, indicatorMargin + indicatorSize);
        histogramCtx.closePath();
        histogramCtx.fill();
      }
    }

    // ===========================================
    // Curve Editor (Lightroom-style with control points)
    // ===========================================
    let currentCurveChannel = 'r';
    let draggingPoint = null;
    let hoveredPoint = null;

    // Monotonic cubic spline interpolation
    function computeSpline(points) {
      const n = points.length;
      if (n < 2) return (x) => x;

      // Sort points by x
      points = [...points].sort((a, b) => a.x - b.x);

      const xs = points.map(p => p.x);
      const ys = points.map(p => p.y);

      // Calculate slopes
      const dxs = [], dys = [], ms = [];
      for (let i = 0; i < n - 1; i++) {
        dxs.push(xs[i + 1] - xs[i]);
        dys.push(ys[i + 1] - ys[i]);
        ms.push(dys[i] / dxs[i]);
      }

      // Calculate degree-1 coefficients
      const c1s = [ms[0]];
      for (let i = 0; i < dxs.length - 1; i++) {
        const m = ms[i], mNext = ms[i + 1];
        if (m * mNext <= 0) {
          c1s.push(0);
        } else {
          const dx = dxs[i], dxNext = dxs[i + 1], common = dx + dxNext;
          c1s.push(3 * common / ((common + dxNext) / m + (common + dx) / mNext));
        }
      }
      c1s.push(ms[ms.length - 1]);

      // Calculate degree-2 and degree-3 coefficients
      const c2s = [], c3s = [];
      for (let i = 0; i < c1s.length - 1; i++) {
        const c1 = c1s[i], m = ms[i], invDx = 1 / dxs[i], common = c1 + c1s[i + 1] - 2 * m;
        c2s.push((m - c1 - common) * invDx);
        c3s.push(common * invDx * invDx);
      }

      // Return interpolation function
      return function(x) {
        let i = xs.length - 1;
        if (x <= xs[0]) return ys[0];
        if (x >= xs[n - 1]) return ys[n - 1];

        // Binary search
        let low = 0, high = c3s.length - 1;
        while (low <= high) {
          const mid = Math.floor((low + high) / 2);
          if (xs[mid] < x) low = mid + 1;
          else high = mid - 1;
        }
        i = Math.max(0, high);

        const diff = x - xs[i];
        return ys[i] + c1s[i] * diff + c2s[i] * diff * diff + c3s[i] * diff * diff * diff;
      };
    }

    // Update the 256-value curve from control points
    function updateCurveFromPoints(channel) {
      const points = state.curvePoints[channel];
      const curve = state.curves[channel];
      const spline = computeSpline(points);

      for (let i = 0; i < 256; i++) {
        curve[i] = Math.max(0, Math.min(255, Math.round(spline(i))));
      }

      if (webglState.gl) webglState.curveDirty = true;
    }

    function renderCurve() {
      const cw = curveCanvas.width = curveCanvas.offsetWidth * 2;
      const ch = curveCanvas.height = curveCanvas.offsetHeight * 2;

      curveCtx.fillStyle = '#111';
      curveCtx.fillRect(0, 0, cw, ch);

      // Grid lines
      curveCtx.strokeStyle = '#333';
      curveCtx.lineWidth = 1;
      for (let i = 0; i <= 4; i++) {
        const x = (i / 4) * cw;
        const y = (i / 4) * ch;
        curveCtx.beginPath();
        curveCtx.moveTo(x, 0);
        curveCtx.lineTo(x, ch);
        curveCtx.stroke();
        curveCtx.beginPath();
        curveCtx.moveTo(0, y);
        curveCtx.lineTo(cw, y);
        curveCtx.stroke();
      }

      // Diagonal reference line
      curveCtx.strokeStyle = '#444';
      curveCtx.beginPath();
      curveCtx.moveTo(0, ch);
      curveCtx.lineTo(cw, 0);
      curveCtx.stroke();

      // Draw the curve
      const colors = { r: '#ff6b6b', g: '#69db7c', b: '#74c0fc' };
      curveCtx.strokeStyle = colors[currentCurveChannel];
      curveCtx.lineWidth = 2;
      curveCtx.beginPath();

      const curve = state.curves[currentCurveChannel];
      for (let i = 0; i < 256; i++) {
        const x = (i / 255) * cw;
        const y = ch - (curve[i] / 255) * ch;
        if (i === 0) curveCtx.moveTo(x, y);
        else curveCtx.lineTo(x, y);
      }
      curveCtx.stroke();

      // Draw control points
      const points = state.curvePoints[currentCurveChannel];
      points.forEach((point, index) => {
        const px = (point.x / 255) * cw;
        const py = ch - (point.y / 255) * ch;
        const isHovered = hoveredPoint === index;
        const isDragging = draggingPoint === index;

        // Point circle
        curveCtx.beginPath();
        curveCtx.arc(px, py, isHovered || isDragging ? 8 : 6, 0, Math.PI * 2);
        curveCtx.fillStyle = isDragging ? '#fff' : (isHovered ? colors[currentCurveChannel] : '#222');
        curveCtx.fill();
        curveCtx.strokeStyle = colors[currentCurveChannel];
        curveCtx.lineWidth = 2;
        curveCtx.stroke();
      });
    }

    function setCurvePreset(preset) {
      let points;
      switch (preset) {
        case 'linear':
          points = [{ x: 0, y: 0 }, { x: 255, y: 255 }];
          break;
        case 'scurve':
          points = [{ x: 0, y: 0 }, { x: 64, y: 48 }, { x: 192, y: 208 }, { x: 255, y: 255 }];
          break;
        case 'log':
          points = [{ x: 0, y: 0 }, { x: 64, y: 128 }, { x: 128, y: 192 }, { x: 255, y: 255 }];
          break;
        default:
          points = [{ x: 0, y: 0 }, { x: 255, y: 255 }];
      }
      state.curvePoints[currentCurveChannel] = points;
      updateCurveFromPoints(currentCurveChannel);
      renderCurve();
      markCurrentFileDirty();
      scheduleFullUpdate();
    }

    document.querySelectorAll('.curve-tab').forEach(tab => {
      tab.addEventListener('click', () => {
        document.querySelectorAll('.curve-tab').forEach(t => t.classList.remove('active'));
        tab.classList.add('active');
        currentCurveChannel = tab.dataset.channel;
        draggingPoint = null;
        hoveredPoint = null;
        renderCurve();
      });
    });

    document.querySelectorAll('.curve-preset-btn').forEach(btn => {
      btn.addEventListener('click', () => setCurvePreset(btn.dataset.preset));
    });

    document.getElementById('resetCurveBtn').addEventListener('click', () => {
      // Reset ALL channels, not just the current one
      ['r', 'g', 'b'].forEach(channel => {
        state.curvePoints[channel] = [{ x: 0, y: 0 }, { x: 255, y: 255 }];
        updateCurveFromPoints(channel);
      });
      renderCurve();
      markCurrentFileDirty();
      scheduleFullUpdate();
    });

    // Get canvas position from mouse event
    function getCurvePosition(e) {
      const rect = curveCanvas.getBoundingClientRect();
      const scaleX = curveCanvas.width / rect.width;
      const scaleY = curveCanvas.height / rect.height;
      const canvasX = (e.clientX - rect.left) * scaleX;
      const canvasY = (e.clientY - rect.top) * scaleY;
      return {
        x: Math.max(0, Math.min(255, Math.round((canvasX / curveCanvas.width) * 255))),
        y: Math.max(0, Math.min(255, 255 - Math.round((canvasY / curveCanvas.height) * 255))),
        canvasX,
        canvasY
      };
    }

    // Find point near position
    function findNearPoint(canvasX, canvasY, threshold = 15) {
      const points = state.curvePoints[currentCurveChannel];
      const cw = curveCanvas.width;
      const ch = curveCanvas.height;

      for (let i = 0; i < points.length; i++) {
        const px = (points[i].x / 255) * cw;
        const py = ch - (points[i].y / 255) * ch;
        const dist = Math.sqrt((canvasX - px) ** 2 + (canvasY - py) ** 2);
        if (dist < threshold) return i;
      }
      return -1;
    }

    curveCanvas.addEventListener('mousedown', (e) => {
      const pos = getCurvePosition(e);
      const nearPoint = findNearPoint(pos.canvasX, pos.canvasY);

      if (nearPoint >= 0) {
        // Start dragging existing point
        draggingPoint = nearPoint;
      } else {
        // Add new point
        const points = state.curvePoints[currentCurveChannel];
        const newPoint = { x: pos.x, y: pos.y };

        // Insert in sorted order
        let insertIndex = points.findIndex(p => p.x > pos.x);
        if (insertIndex === -1) insertIndex = points.length;
        points.splice(insertIndex, 0, newPoint);

        draggingPoint = insertIndex;
        updateCurveFromPoints(currentCurveChannel);
        markCurrentFileDirty();
      }
      renderCurve();
    });

    curveCanvas.addEventListener('mousemove', (e) => {
      const pos = getCurvePosition(e);

      if (draggingPoint !== null) {
        const points = state.curvePoints[currentCurveChannel];
        const point = points[draggingPoint];

        // Endpoints can only move vertically
        if (draggingPoint === 0) {
          point.y = pos.y;
        } else if (draggingPoint === points.length - 1) {
          point.y = pos.y;
        } else {
          // Middle points: constrain x between neighbors
          const prevX = points[draggingPoint - 1].x + 1;
          const nextX = points[draggingPoint + 1].x - 1;
          point.x = Math.max(prevX, Math.min(nextX, pos.x));
          point.y = pos.y;
        }

        updateCurveFromPoints(currentCurveChannel);
        renderCurve();
        markCurrentFileDirty();
        schedulePreviewUpdate();
      } else {
        // Update hover state
        const nearPoint = findNearPoint(pos.canvasX, pos.canvasY);
        if (nearPoint !== hoveredPoint) {
          hoveredPoint = nearPoint;
          renderCurve();
        }
        curveCanvas.style.cursor = nearPoint >= 0 ? 'grab' : 'crosshair';
      }
    });

    curveCanvas.addEventListener('mouseup', () => {
      if (draggingPoint !== null) {
        draggingPoint = null;
        scheduleFullUpdate();
      }
    });

    curveCanvas.addEventListener('mouseleave', () => {
      if (draggingPoint !== null) {
        draggingPoint = null;
        scheduleFullUpdate();
      }
      hoveredPoint = null;
      renderCurve();
    });

    // Double-click to remove point (except endpoints)
    curveCanvas.addEventListener('dblclick', (e) => {
      const pos = getCurvePosition(e);
      const nearPoint = findNearPoint(pos.canvasX, pos.canvasY);

      if (nearPoint > 0 && nearPoint < state.curvePoints[currentCurveChannel].length - 1) {
        state.curvePoints[currentCurveChannel].splice(nearPoint, 1);
        updateCurveFromPoints(currentCurveChannel);
        renderCurve();
        markCurrentFileDirty();
        scheduleFullUpdate();
      }
    });

    // Touch-friendly pointer support for iOS Safari. Keep mouse path above unchanged for PC.
    let activeCurvePointerId = null;

    curveCanvas.addEventListener('pointerdown', (e) => {
      if (e.pointerType === 'mouse') return;
      e.preventDefault();

      const pos = getCurvePosition(e);
      const nearPoint = findNearPoint(pos.canvasX, pos.canvasY);

      if (nearPoint >= 0) {
        draggingPoint = nearPoint;
      } else {
        const points = state.curvePoints[currentCurveChannel];
        const newPoint = { x: pos.x, y: pos.y };
        let insertIndex = points.findIndex(p => p.x > pos.x);
        if (insertIndex === -1) insertIndex = points.length;
        points.splice(insertIndex, 0, newPoint);
        draggingPoint = insertIndex;
        updateCurveFromPoints(currentCurveChannel);
        markCurrentFileDirty();
      }

      activeCurvePointerId = e.pointerId;
      curveCanvas.setPointerCapture(e.pointerId);
      renderCurve();
    }, { passive: false });

    curveCanvas.addEventListener('pointermove', (e) => {
      if (e.pointerType === 'mouse') return;
      if (activeCurvePointerId !== e.pointerId || draggingPoint === null) return;
      e.preventDefault();

      const pos = getCurvePosition(e);
      const points = state.curvePoints[currentCurveChannel];
      const point = points[draggingPoint];

      if (draggingPoint === 0 || draggingPoint === points.length - 1) {
        point.y = pos.y;
      } else {
        const prevX = points[draggingPoint - 1].x + 1;
        const nextX = points[draggingPoint + 1].x - 1;
        point.x = Math.max(prevX, Math.min(nextX, pos.x));
        point.y = pos.y;
      }

      updateCurveFromPoints(currentCurveChannel);
      renderCurve();
      markCurrentFileDirty();
      schedulePreviewUpdate();
    }, { passive: false });

    function finishCurvePointerDrag(pointerId) {
      if (activeCurvePointerId !== pointerId) return;
      if (draggingPoint !== null) {
        draggingPoint = null;
        scheduleFullUpdate();
      }
      if (curveCanvas.hasPointerCapture(pointerId)) {
        curveCanvas.releasePointerCapture(pointerId);
      }
      activeCurvePointerId = null;
    }

    curveCanvas.addEventListener('pointerup', (e) => {
      if (e.pointerType === 'mouse') return;
      finishCurvePointerDrag(e.pointerId);
    });

    curveCanvas.addEventListener('pointercancel', (e) => {
      if (e.pointerType === 'mouse') return;
      finishCurvePointerDrag(e.pointerId);
    });

    // ===========================================
    // Image Processing Pipeline
    // ===========================================
    // WebGL is used to keep Step 3 adjustments responsive (WB/Tone/CMY/Curves) on large scans.
    // CPU rendering is still used for fallback + batch export.

    const webglState = {
      gl: null,
      program: null,
      quadBuffer: null,
      sourceTex: null,
      curveTex: null,
      curveDirty: true,
      sourceDirty: true,
      sourceSize: { w: 0, h: 0 },
      maxTextureSize: 0,
      handlersAttached: false,
      locations: {
        aPos: null,
        uImage: null,
        uCurve: null,
        uWb: null,
        uExposure: null,
        uContrast: null,
        uHighlights: null,
        uShadows: null,
        uTemp: null,
        uTint: null,
        uSat: null,
        uVib: null,
        uCmy: null
      }
    };

    const webglCurveRgba = new Uint8Array(256 * 4);

    function compileShader(gl, type, source) {
      const shader = gl.createShader(type);
      gl.shaderSource(shader, source);
      gl.compileShader(shader);
      if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
        const info = gl.getShaderInfoLog(shader) || 'Unknown shader compile error';
        gl.deleteShader(shader);
        throw new Error(info);
      }
      return shader;
    }

    function createProgram(gl, vsSource, fsSource) {
      const vs = compileShader(gl, gl.VERTEX_SHADER, vsSource);
      const fs = compileShader(gl, gl.FRAGMENT_SHADER, fsSource);
      const program = gl.createProgram();
      gl.attachShader(program, vs);
      gl.attachShader(program, fs);
      gl.linkProgram(program);
      gl.deleteShader(vs);
      gl.deleteShader(fs);
      if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
        const info = gl.getProgramInfoLog(program) || 'Unknown program link error';
        gl.deleteProgram(program);
        throw new Error(info);
      }
      return program;
    }

    function initWebGLRenderer() {
      if (webglState.gl) return true;

      let gl = null;
      try {
        gl = glCanvas.getContext('webgl', {
          alpha: false,
          depth: false,
          stencil: false,
          antialias: false,
          preserveDrawingBuffer: false,
          premultipliedAlpha: false
        });
      } catch {
        gl = null;
      }

      if (!gl) return false;

      const vsSource = `
        attribute vec2 a_pos;
        varying vec2 v_uv;
        void main() {
          v_uv = (a_pos + 1.0) * 0.5;
          gl_Position = vec4(a_pos, 0.0, 1.0);
        }
      `;

      const fsSource = `
        #ifdef GL_FRAGMENT_PRECISION_HIGH
        precision highp float;
        #else
        precision mediump float;
        #endif
        varying vec2 v_uv;
        uniform sampler2D u_image;
        uniform sampler2D u_curve;

        uniform vec3 u_wb;
        uniform float u_exposure;
        uniform float u_contrast;
        uniform float u_highlights;
        uniform float u_shadows;
        uniform float u_temp;
        uniform float u_tint;
        uniform float u_sat;
        uniform float u_vib;
        uniform vec3 u_cmy;

        float hue2rgb(float p, float q, float t) {
          if (t < 0.0) t += 1.0;
          if (t > 1.0) t -= 1.0;
          if (t < 1.0 / 6.0) return p + (q - p) * 6.0 * t;
          if (t < 1.0 / 2.0) return q;
          if (t < 2.0 / 3.0) return p + (q - p) * (2.0 / 3.0 - t) * 6.0;
          return p;
        }

        vec3 rgbToHsl(vec3 c) {
          float r = c.r, g = c.g, b = c.b;
          float maxc = max(r, max(g, b));
          float minc = min(r, min(g, b));
          float h = 0.0;
          float s = 0.0;
          float l = (maxc + minc) * 0.5;

          if (maxc != minc) {
            float d = maxc - minc;
            s = l > 0.5 ? d / (2.0 - maxc - minc) : d / (maxc + minc);

            if (maxc == r) {
              h = (g - b) / d + (g < b ? 6.0 : 0.0);
            } else if (maxc == g) {
              h = (b - r) / d + 2.0;
            } else {
              h = (r - g) / d + 4.0;
            }
            h /= 6.0;
          }

          return vec3(h, s, l);
        }

        vec3 hslToRgb(float h, float s, float l) {
          float r, g, b;
          if (s == 0.0) {
            r = g = b = l;
          } else {
            float q = l < 0.5 ? l * (1.0 + s) : l + s - l * s;
            float p = 2.0 * l - q;
            r = hue2rgb(p, q, h + 1.0 / 3.0);
            g = hue2rgb(p, q, h);
            b = hue2rgb(p, q, h - 1.0 / 3.0);
          }
          return vec3(r, g, b);
        }

        vec3 applyCurves(vec3 c) {
          float rIdx = floor(c.r * 255.0 + 0.5);
          float gIdx = floor(c.g * 255.0 + 0.5);
          float bIdx = floor(c.b * 255.0 + 0.5);
          vec4 cr = texture2D(u_curve, vec2((rIdx + 0.5) / 256.0, 0.5));
          vec4 cg = texture2D(u_curve, vec2((gIdx + 0.5) / 256.0, 0.5));
          vec4 cb = texture2D(u_curve, vec2((bIdx + 0.5) / 256.0, 0.5));
          return vec3(cr.r, cg.g, cb.b);
        }

        void main() {
          vec3 c = texture2D(u_image, v_uv).rgb;

          float exposureMult = pow(2.0, u_exposure);
          c *= u_wb * exposureMult;

          c = (c - 0.5) * u_contrast + 0.5;

          float luma = dot(c, vec3(0.299, 0.587, 0.114));
          if (u_highlights != 0.0 && luma > 0.5) {
            float mult = 1.0 + u_highlights * (luma - 0.5) * 2.0;
            c *= mult;
          }
          if (u_shadows != 0.0 && luma < 0.5) {
            float mult = 1.0 + u_shadows * (0.5 - luma) * 2.0;
            c *= mult;
          }

          c.r *= (1.0 + u_temp * 0.3);
          c.b *= (1.0 - u_temp * 0.3);
          c.g *= (1.0 + u_tint * 0.3);
          c = clamp(c, 0.0, 1.0);

          if (u_sat != 1.0 || u_vib != 0.0) {
            vec3 hsl = rgbToHsl(c);
            float s = hsl.y * u_sat;
            if (u_vib >= 0.0) {
              s += (1.0 - s) * u_vib;
            } else {
              s *= (1.0 + u_vib);
            }
            hsl.y = clamp(s, 0.0, 1.0);
            c = hslToRgb(hsl.x, hsl.y, hsl.z);
          }

          vec3 cmy = vec3(1.0) - c;
          cmy = clamp(cmy + u_cmy, 0.0, 1.0);
          c = vec3(1.0) - cmy;

          c = applyCurves(c);

          gl_FragColor = vec4(c, 1.0);
        }
      `;

      try {
        webglState.program = createProgram(gl, vsSource, fsSource);
      } catch (err) {
        console.warn('WebGL shader init failed:', err);
        return false;
      }

      webglState.gl = gl;
      webglState.maxTextureSize = gl.getParameter(gl.MAX_TEXTURE_SIZE) || 0;

      if (!webglState.handlersAttached) {
        glCanvas.addEventListener('webglcontextlost', (e) => {
          e.preventDefault();
          // Mark renderer as unavailable; fall back to CPU.
          webglState.gl = null;
          webglState.program = null;
          webglState.quadBuffer = null;
          webglState.sourceTex = null;
          webglState.curveTex = null;
          webglState.sourceSize = { w: 0, h: 0 };
          webglState.maxTextureSize = 0;
          webglState.curveDirty = true;
          webglState.sourceDirty = true;
          updateCanvasVisibility();
          schedulePreviewUpdate();
        }, false);

        glCanvas.addEventListener('webglcontextrestored', () => {
          // Resources are lost; re-init lazily on next render.
          webglState.gl = null;
          webglState.program = null;
          webglState.quadBuffer = null;
          webglState.sourceTex = null;
          webglState.curveTex = null;
          webglState.sourceSize = { w: 0, h: 0 };
          webglState.maxTextureSize = 0;
          webglState.curveDirty = true;
          webglState.sourceDirty = true;
          schedulePreviewUpdate();
        }, false);

        webglState.handlersAttached = true;
      }

      // Full-screen quad
      webglState.quadBuffer = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, webglState.quadBuffer);
      gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
        -1, -1,
         1, -1,
        -1,  1,
         1,  1
      ]), gl.STATIC_DRAW);

      gl.useProgram(webglState.program);

      webglState.locations.aPos = gl.getAttribLocation(webglState.program, 'a_pos');
      webglState.locations.uImage = gl.getUniformLocation(webglState.program, 'u_image');
      webglState.locations.uCurve = gl.getUniformLocation(webglState.program, 'u_curve');
      webglState.locations.uWb = gl.getUniformLocation(webglState.program, 'u_wb');
      webglState.locations.uExposure = gl.getUniformLocation(webglState.program, 'u_exposure');
      webglState.locations.uContrast = gl.getUniformLocation(webglState.program, 'u_contrast');
      webglState.locations.uHighlights = gl.getUniformLocation(webglState.program, 'u_highlights');
      webglState.locations.uShadows = gl.getUniformLocation(webglState.program, 'u_shadows');
      webglState.locations.uTemp = gl.getUniformLocation(webglState.program, 'u_temp');
      webglState.locations.uTint = gl.getUniformLocation(webglState.program, 'u_tint');
      webglState.locations.uSat = gl.getUniformLocation(webglState.program, 'u_sat');
      webglState.locations.uVib = gl.getUniformLocation(webglState.program, 'u_vib');
      webglState.locations.uCmy = gl.getUniformLocation(webglState.program, 'u_cmy');

      // Textures
      webglState.sourceTex = gl.createTexture();
      gl.bindTexture(gl.TEXTURE_2D, webglState.sourceTex);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);

      webglState.curveTex = gl.createTexture();
      gl.bindTexture(gl.TEXTURE_2D, webglState.curveTex);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);

      // Bind samplers
      gl.uniform1i(webglState.locations.uImage, 0);
      gl.uniform1i(webglState.locations.uCurve, 1);

      gl.disable(gl.DEPTH_TEST);
      gl.disable(gl.BLEND);

      webglState.curveDirty = true;
      webglState.sourceDirty = true;

      return true;
    }

    function isWebGLActive() {
      return !!webglState.gl && state.currentStep >= 3 && !!state.processedImageData;
    }

    function resizeWebGLCanvas() {
      if (!webglState.gl) return;
      const rect = glCanvas.getBoundingClientRect();
      if (rect.width <= 0 || rect.height <= 0) return;

      const dpr = window.devicePixelRatio || 1;
      let targetW = Math.max(1, Math.round(rect.width * dpr));
      let targetH = Math.max(1, Math.round(rect.height * dpr));

      // Limit interactive draw resolution to keep things smooth on very large displays.
      const maxDim = 2048;
      const maxCurrent = Math.max(targetW, targetH);
      if (maxCurrent > maxDim) {
        const scale = maxDim / maxCurrent;
        targetW = Math.max(1, Math.floor(targetW * scale));
        targetH = Math.max(1, Math.floor(targetH * scale));
      }

      if (glCanvas.width !== targetW) glCanvas.width = targetW;
      if (glCanvas.height !== targetH) glCanvas.height = targetH;
    }

    function getWebglSourceImageData() {
      const full = state.processedImageData;
      if (!full) return null;

      const maxTex = webglState.maxTextureSize || 0;
      const targetMaxDim = Math.min(2048, maxTex || 2048);

      let src = state.webglSourceImageData;
      if (!src || src.width !== Math.min(src.width, targetMaxDim) || src.height !== Math.min(src.height, targetMaxDim)) {
        // If cached source is missing or too large for the current device, rebuild from full-res.
        src = buildWebglSourceImageData(full, targetMaxDim);
        state.webglSourceImageData = src;
      }

      // Safety: if the result still doesn't fit (very old GPUs), force it down.
      if (maxTex && (src.width > maxTex || src.height > maxTex)) {
        src = buildWebglSourceImageData(full, maxTex);
        state.webglSourceImageData = src;
      }

      return src;
    }

    function webglUploadSource(imageData) {
      if (!webglState.gl) return;
      if (!imageData) return;

      const gl = webglState.gl;
      gl.activeTexture(gl.TEXTURE0);
      gl.bindTexture(gl.TEXTURE_2D, webglState.sourceTex);
      gl.pixelStorei(gl.UNPACK_ALIGNMENT, 1);
      gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
      gl.texImage2D(
        gl.TEXTURE_2D,
        0,
        gl.RGBA,
        imageData.width,
        imageData.height,
        0,
        gl.RGBA,
        gl.UNSIGNED_BYTE,
        imageData.data
      );
      webglState.sourceSize.w = imageData.width;
      webglState.sourceSize.h = imageData.height;
      webglState.sourceDirty = false;
    }

    function webglUploadCurves() {
      if (!webglState.gl) return;
      const gl = webglState.gl;

      for (let i = 0; i < 256; i++) {
        const idx = i * 4;
        webglCurveRgba[idx] = state.curves.r[i];
        webglCurveRgba[idx + 1] = state.curves.g[i];
        webglCurveRgba[idx + 2] = state.curves.b[i];
        webglCurveRgba[idx + 3] = 255;
      }

      gl.activeTexture(gl.TEXTURE1);
      gl.bindTexture(gl.TEXTURE_2D, webglState.curveTex);
      gl.pixelStorei(gl.UNPACK_ALIGNMENT, 1);
      gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);
      gl.texImage2D(
        gl.TEXTURE_2D,
        0,
        gl.RGBA,
        256,
        1,
        0,
        gl.RGBA,
        gl.UNSIGNED_BYTE,
        webglCurveRgba
      );

      webglState.curveDirty = false;
    }

    function webglSetUniforms() {
      const gl = webglState.gl;
      if (!gl) return;

      const preset = getPresetOrFallback(state.filmPreset, state.filmType);
      const presetChars = (preset && preset.characteristics) ? preset.characteristics : {};

      const exposure = state.exposure;
      const contrast = 1 + ((state.contrast + (presetChars.contrast || 0) * 100) / 100);
      const highlights = state.highlights / 100;
      const shadows = state.shadows / 100;
      const tempFactor = (state.temperature + (presetChars.warmth || 0) * 100) / 100;
      const tintFactor = state.tint / 100;
      const satFactor = 1 + ((state.saturation + (presetChars.saturation || 0) * 100) / 100);
      const vibFactor = state.vibrance / 100;

      gl.uniform3f(webglState.locations.uWb, state.wbR, state.wbG, state.wbB);
      gl.uniform1f(webglState.locations.uExposure, exposure);
      gl.uniform1f(webglState.locations.uContrast, contrast);
      gl.uniform1f(webglState.locations.uHighlights, highlights);
      gl.uniform1f(webglState.locations.uShadows, shadows);
      gl.uniform1f(webglState.locations.uTemp, tempFactor);
      gl.uniform1f(webglState.locations.uTint, tintFactor);
      gl.uniform1f(webglState.locations.uSat, satFactor);
      gl.uniform1f(webglState.locations.uVib, vibFactor);
      gl.uniform3f(webglState.locations.uCmy, state.cyan / 100, state.magenta / 100, state.yellow / 100);
    }

    function renderWebGL() {
      if (!webglState.gl || !state.processedImageData) return;

      resizeWebGLCanvas();

      const gl = webglState.gl;
      gl.viewport(0, 0, glCanvas.width, glCanvas.height);
      gl.useProgram(webglState.program);

      // Uploads if needed
      const source = getWebglSourceImageData();
      if (!source) return;
      if (webglState.sourceDirty || webglState.sourceSize.w !== source.width || webglState.sourceSize.h !== source.height) {
        webglUploadSource(source);
      }
      if (webglState.curveDirty) {
        webglUploadCurves();
      }

      // Bind geometry
      gl.bindBuffer(gl.ARRAY_BUFFER, webglState.quadBuffer);
      gl.enableVertexAttribArray(webglState.locations.aPos);
      gl.vertexAttribPointer(webglState.locations.aPos, 2, gl.FLOAT, false, 0, 0);

      // Bind textures
      gl.activeTexture(gl.TEXTURE0);
      gl.bindTexture(gl.TEXTURE_2D, webglState.sourceTex);
      gl.activeTexture(gl.TEXTURE1);
      gl.bindTexture(gl.TEXTURE_2D, webglState.curveTex);

      webglSetUniforms();

      gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
    }

    function updateCanvasVisibility() {
      const showGL = isWebGLActive();
      glCanvas.style.display = showGL ? 'block' : 'none';
      canvas.style.display = showGL ? 'none' : 'block';
      if (showGL) renderWebGL();
    }

    let updateScheduled = false;
    let fullUpdateTimer = null;

    const previewCanvas = document.createElement('canvas');
    const previewCtx = previewCanvas.getContext('2d', { willReadFrequently: true });
    let fullAdjustedBuffer = null;
    let previewAdjustedBuffer = null;
    let histogramAdjustedBuffer = null;
    let lastHistogramUpdateTime = 0;

    function renderHistogramForWebGL(force = false) {
      if (!state.processedImageData) return;
      const now = performance.now();
      if (!force && (now - lastHistogramUpdateTime) < HISTOGRAM_UPDATE_INTERVAL_MS) return;

      const source = state.histogramSourceImageData || state.previewSourceImageData || state.processedImageData;
      histogramAdjustedBuffer = ensureImageDataBuffer(histogramAdjustedBuffer, source.width, source.height);
      applyAdjustmentsToBuffer(source, state, histogramAdjustedBuffer, 'preview');
      renderHistogram(histogramAdjustedBuffer);
      lastHistogramUpdateTime = now;
    }

    function schedulePreviewUpdate() {
      if (!updateScheduled) {
        updateScheduled = true;
        requestAnimationFrame(() => {
          updatePreview();
          updateScheduled = false;
        });
      }
    }

    function scheduleFullUpdate() {
      if (fullUpdateTimer) clearTimeout(fullUpdateTimer);
      // Full-res CPU rendering can be expensive on large scans; debounce aggressively.
      fullUpdateTimer = setTimeout(() => {
        updateFull();
        fullUpdateTimer = null;
      }, 1200);
    }

    function updatePreview() {
      if (!state.processedImageData) return;

      // Prefer GPU rendering in Step 3 when available.
      if (state.currentStep >= 3 && initWebGLRenderer()) {
        updateCanvasVisibility();
        renderWebGL();
        renderHistogramForWebGL(false);
        state.lastRenderQuality = 'gl';
        return;
      }

      updatePreviewCpu();
    }

    function updatePreviewCpu() {
      if (!state.processedImageData) return;

      const source = state.previewSourceImageData || state.processedImageData;
      previewAdjustedBuffer = ensureImageDataBuffer(previewAdjustedBuffer, source.width, source.height);
      applyAdjustmentsToBuffer(source, state, previewAdjustedBuffer, 'preview');

      if (source !== state.processedImageData) {
        if (previewCanvas.width !== source.width) previewCanvas.width = source.width;
        if (previewCanvas.height !== source.height) previewCanvas.height = source.height;
        previewCtx.putImageData(previewAdjustedBuffer, 0, 0);

        ctx.imageSmoothingEnabled = true;
        ctx.drawImage(previewCanvas, 0, 0, canvas.width, canvas.height);
        state.lastRenderQuality = 'preview';
      } else {
        ctx.putImageData(previewAdjustedBuffer, 0, 0);
        state.displayImageData = previewAdjustedBuffer;
        state.lastRenderQuality = 'full';
      }
      // Histogram updates are deferred to full renders for responsiveness.
    }

    function updateFull() {
      if (!state.processedImageData) return;

      // Prefer GPU rendering in Step 3 when available.
      if (state.currentStep >= 3 && initWebGLRenderer()) {
        updateCanvasVisibility();
        renderWebGL();
        renderHistogramForWebGL(true);
        state.lastRenderQuality = 'gl';
        return;
      }

      updateFullCpu();
    }

    function updateFullCpu() {
      if (!state.processedImageData) return;

      const source = state.processedImageData;
      fullAdjustedBuffer = ensureImageDataBuffer(fullAdjustedBuffer, source.width, source.height);
      applyAdjustmentsToBuffer(source, state, fullAdjustedBuffer, 'full');
      state.displayImageData = fullAdjustedBuffer;
      ctx.putImageData(fullAdjustedBuffer, 0, 0);
      renderHistogram(fullAdjustedBuffer);

      transformCanvas.width = canvas.width;
      transformCanvas.height = canvas.height;
      transformCtx.putImageData(fullAdjustedBuffer, 0, 0);
      state.lastRenderQuality = 'full';
    }

    function ensureFullRender() {
      if (!state.processedImageData) return;
      // Always compute full-res on CPU for export/batch correctness.
      updateFullCpu();
    }

    function processNegative() {
      const sourceData = state.croppedImageData || state.originalImageData;
      if (!sourceData) return;

      let processed;
      const preset = getPresetOrFallback(state.filmPreset, state.filmType);
      const presetType = (preset && preset.type) ? preset.type : state.filmType;

      if (state.filmType === 'positive' || presetType === 'positive') {
        processed = convertPositiveFilm(sourceData);
      } else if (state.filmType === 'bw' || presetType === 'bw') {
        const bwParams = getBwPresetParams(preset);
        processed = convertBWNegative(sourceData, {
          contrast: bwParams.contrast,
          gamma: bwParams.gamma
        });
      } else {
        processed = convertColorNegative(sourceData, state.filmBase);
      }

      state.processedImageData = processed;
      state.previewSourceImageData = buildPreviewSourceImageData(processed);
      state.histogramSourceImageData = buildHistogramSourceImageData(state.previewSourceImageData || processed);
      state.webglSourceImageData = buildWebglSourceImageData(processed);
      if (initWebGLRenderer()) {
        webglState.sourceDirty = true;
        webglState.curveDirty = true;
      }
      canvas.width = processed.width;
      canvas.height = processed.height;
      goToStep(3);
      syncBatchUIState({ reason: 'processNegative' });
      revealBatchFileList('processNegative');
      updateFull();
    }

    // ===========================================
    // Canvas Display
    // ===========================================
    function adjustCanvasDisplay(w, h) {
      const container = document.getElementById('canvasContainer');
      const maxWidth = container.clientWidth - 20;
      const maxHeight = container.clientHeight - 20;
      const scale = Math.min(maxWidth / w, maxHeight / h, 1);
      const cssW = (w * scale) + 'px';
      const cssH = (h * scale) + 'px';
      canvas.style.width = cssW;
      canvas.style.height = cssH;
      glCanvas.style.width = cssW;
      glCanvas.style.height = cssH;
      if (isWebGLActive()) resizeWebGLCanvas();
    }

    function displayNegative(imageData) {
      canvas.width = imageData.width;
      canvas.height = imageData.height;
      ctx.putImageData(imageData, 0, 0);
      adjustCanvasDisplay(imageData.width, imageData.height);

      transformCanvas.width = imageData.width;
      transformCanvas.height = imageData.height;
      transformCtx.putImageData(imageData, 0, 0);
    }

    // ===========================================
    // File Loading
    // ===========================================
    async function loadFile(file) {
      const placeholder = document.getElementById('uploadPlaceholder');
      placeholder.innerHTML = `<p>${i18n[currentLang].processing}</p>`;
      const fileName = file.name.toLowerCase();
      const isRawLikeFile = ['.cr2', '.nef', '.arw', '.dng', '.raw', '.rw2', '.tif', '.tiff'].some(ext => fileName.endsWith(ext));

      try {
        const arrayBuffer = await file.arrayBuffer();

        let imageData;

        if (isRawLikeFile) {
          imageData = await loadRawFile(arrayBuffer, fileName);
        } else if (file.type === 'image/png') {
          imageData = loadPngFile(arrayBuffer);
        } else {
          imageData = await loadStandardImage(file);
        }

        if (imageData) {
          state.loadedBaseImageData = imageData;
          state.originalImageData = imageData;
          state.croppedImageData = null;
          state.cropRegion = null;
          state.rotationAngle = 0;
          state.processedImageData = null;
          state.displayImageData = null;
          state.previewSourceImageData = null;
          state.histogramSourceImageData = null;
          state.webglSourceImageData = null;
          state.lastRenderQuality = 'full';
          state.filmBaseSet = false;
          state.autoFrame.lastDiagnostics = null;
          if (webglState.gl) {
            webglState.sourceDirty = true;
            webglState.sourceSize = { w: 0, h: 0 };
          }

          displayNegative(imageData);
          showImageUI();
          goToStep(1);
          updateAutoFrameDiagnosticsUI();
          syncBatchUIState({ reason: 'loadFile' });
          updateAutoFrameButtons();
        }
      } catch (err) {
        console.error('Error loading file:', err);
        const text = String(err?.message || err || '');
        const isRawSupportIssue = isRawLikeFile && /module worker|worker|webassembly|wasm/i.test(text);
        const message = isRawSupportIssue
          ? (i18n[currentLang].rawUnsupported || 'RAW decode is not supported in this Safari version. Update Safari or convert to TIFF/JPEG first.')
          : (i18n[currentLang].loadError || 'Error loading file');
        placeholder.innerHTML = `<p style="color: var(--danger);">${message}</p>`;
      }
    }

    async function loadRawFile(buffer, fileName) {
      // Handle TIF/TIFF files directly with UTIF.js
      if (fileName.endsWith('.tif') || fileName.endsWith('.tiff')) {
        try {
          const ifds = UTIF.decode(buffer);
          UTIF.decodeImage(buffer, ifds[0]);
          const rgba = UTIF.toRGBA8(ifds[0]);
          return new ImageData(new Uint8ClampedArray(rgba), ifds[0].width, ifds[0].height);
        } catch (err) {
          console.error('UTIF.js failed for TIFF:', err);
          throw err;
        }
      }

      // Handle iPhone DNG (ProRaw) with UTIF.js
      if (fileName.endsWith('.dng')) {
        const textSnippet = new TextDecoder().decode(buffer.slice(0, 1000));
        if (textSnippet.includes('iPhone')) {
          try {
            const ifds = UTIF.decode(buffer);
            UTIF.decodeImage(buffer, ifds[0]);
            const rgba = UTIF.toRGBA8(ifds[0]);
            return new ImageData(new Uint8ClampedArray(rgba), ifds[0].width, ifds[0].height);
          } catch (err) {
            console.error('UTIF.js failed:', err);
          }
        }
      }

      let raw;
      try {
        raw = new LibRaw();
      } catch (err) {
        throw new Error(`module worker not supported: ${err?.message || err}`);
      }
      await raw.open(new Uint8Array(buffer), {
        noInterpolation: false,
        useAutoWb: true,
        useCameraWb: true,
        useCameraMatrix: 3,
        outputColor: 1,
        outputBps: 8
      });

      const result = await raw.imageData();
      const { width, height, data: rgbData } = result;

      const pixelCount = width * height;
      const rgbaData = new Uint8ClampedArray(pixelCount * 4);
      for (let i = 0; i < pixelCount; i++) {
        rgbaData[i * 4] = rgbData[i * 3];
        rgbaData[i * 4 + 1] = rgbData[i * 3 + 1];
        rgbaData[i * 4 + 2] = rgbData[i * 3 + 2];
        rgbaData[i * 4 + 3] = 255;
      }

      return new ImageData(rgbaData, width, height);
    }

    function loadPngFile(buffer) {
      const decoded = UPNG.decode(buffer);
      const { width, height, ctype, depth, data } = decoded;

      const channelCount = (ctype & 2 ? 3 : 1) + (ctype & 4 ? 1 : 0);
      const pixelCount = width * height;

      let raw16 = new Uint16Array(pixelCount * channelCount);
      if (depth <= 8) {
        for (let i = 0; i < raw16.length; i++) raw16[i] = data[i] * 257;
      } else {
        for (let i = 0; i < raw16.length; i++) raw16[i] = (data[2 * i] << 8) | data[2 * i + 1];
      }

      const final8 = new Uint8ClampedArray(pixelCount * 4);
      for (let i = 0; i < pixelCount; i++) {
        const idx16 = i * channelCount;
        const idx8 = i * 4;
        final8[idx8] = raw16[idx16] >>> 8;
        if (channelCount >= 3) {
          final8[idx8 + 1] = raw16[idx16 + 1] >>> 8;
          final8[idx8 + 2] = raw16[idx16 + 2] >>> 8;
        } else {
          final8[idx8 + 1] = final8[idx8];
          final8[idx8 + 2] = final8[idx8];
        }
        final8[idx8 + 3] = channelCount === 4 ? (raw16[idx16 + 3] >>> 8) : 255;
      }

      return new ImageData(final8, width, height);
    }

    async function loadStandardImage(file) {
      return new Promise((resolve, reject) => {
        const img = new Image();
        img.onload = () => {
          const tempCanvas = document.createElement('canvas');
          tempCanvas.width = img.width;
          tempCanvas.height = img.height;
          const tempCtx = tempCanvas.getContext('2d');
          tempCtx.drawImage(img, 0, 0);
          resolve(tempCtx.getImageData(0, 0, img.width, img.height));
        };
        img.onerror = reject;
        img.src = URL.createObjectURL(file);
      });
    }

    function showImageUI() {
      document.getElementById('uploadPlaceholder').style.display = 'none';
      document.getElementById('previewToolbar').style.display = 'flex';
      document.getElementById('histogramContainer').style.display = 'block';
      document.getElementById('controlsPanel').style.display = 'flex';
      document.getElementById('appFooter').style.display = 'flex';

      updateCanvasVisibility();
      adjustCanvasDisplay(canvas.width, canvas.height);
      updateAutoFrameConfigUI();
      updateAutoFrameDiagnosticsUI();
    }

    // ===========================================
    // Film Base Sampling
    // ===========================================
    function requiresFilmBase(preset = getPresetOrFallback(state.filmPreset, state.filmType)) {
      return (preset?.type || state.filmType) === 'color';
    }

    function suggestStep2Mode() {
      if (!requiresFilmBase()) return 'border';
      if (state.cropRegion) return 'noBorder';

      const sourceData = state.croppedImageData || state.originalImageData;
      if (!sourceData) return 'border';
      const sample = autoDetectFilmBase(sourceData);
      const orangeBias = (sample.r - sample.b) + ((sample.r - sample.g) * 0.5);
      return orangeBias > 10 ? 'border' : 'noBorder';
    }

    function setStep2Mode(mode) {
      state.step2Mode = mode === 'noBorder' ? 'noBorder' : 'border';
      const borderBtn = document.getElementById('step2ModeBorderBtn');
      const noBorderBtn = document.getElementById('step2ModeNoBorderBtn');
      if (borderBtn) borderBtn.classList.toggle('active', state.step2Mode === 'border');
      if (noBorderBtn) noBorderBtn.classList.toggle('active', state.step2Mode === 'noBorder');
      updateFilmModeUI();
    }

    function applyRollReferenceToCurrentForStep2() {
      if (!hasRollReference()) return false;
      const ref = state.rollReference.settingsSnapshot;
      if (!ref) return false;

      state.filmType = sanitizePresetType(ref.filmType || 'color');
      state.filmPreset = resolvePresetId(ref.filmPreset) || getDefaultPresetForType(state.filmType);
      state.filmBase = { ...ref.filmBase };
      state.filmBaseSet = true;

      updateSlidersFromState();
      updateFilmBasePreview();
      updateStep2GuideCard();
      markCurrentFileDirty();
      return true;
    }

    function setRecommendedAction(actionId) {
      ['sampleBaseBtn', 'autoDetectBtn', 'useReferenceBtn', 'applyConvertBtn'].forEach(id => {
        const btn = document.getElementById(id);
        if (btn) btn.classList.remove('recommended-action');
      });
      if (!actionId) return;

      const target = document.getElementById(actionId);
      if (!target || target.disabled) return;
      if (target.style.display === 'none') return;
      target.classList.add('recommended-action');
    }

    function updateStep2GuideCard(options = {}) {
      const { skipFirstHint = false } = options;
      const card = document.getElementById('step2GuideCard');
      const step1El = document.getElementById('step2GuideStep1');
      const step2El = document.getElementById('step2GuideStep2');
      const step3El = document.getElementById('step2GuideStep3');
      const tipEl = document.getElementById('step2GuideTip');
      const firstHintEl = document.getElementById('step2FirstHint');
      if (!card || !step1El || !step2El || !step3El || !tipEl) return;

      const showFilmBase = requiresFilmBase();
      card.style.display = showFilmBase ? 'flex' : 'none';

      if (firstHintEl) {
        firstHintEl.textContent = getLocalizedText(
          'step2FirstHint',
          'Tip: If you cannot find orange border area, switch to "No Border / ES-2".'
        );
      }

      if (!showFilmBase) {
        setRecommendedAction(null);
        if (firstHintEl) firstHintEl.style.display = 'none';
        return;
      }

      const isNoBorder = state.step2Mode === 'noBorder';
      const hasMask = Boolean(state.filmBaseSet);
      const hasReference = hasRollReference();
      const step2Active = state.currentStep >= 2;

      const step1Key = isNoBorder ? 'guideNoBorderStep1' : 'guideBorderStep1';
      const step2Key = isNoBorder ? 'guideNoBorderStep2' : 'guideBorderStep2';
      const step3Key = isNoBorder ? 'guideNoBorderStep3' : 'guideBorderStep3';

      step1El.textContent = getLocalizedText(step1Key, '');
      step2El.textContent = getLocalizedText(step2Key, '');
      step3El.textContent = getLocalizedText(step3Key, '');

      let tipKey = 'guideTipFallback';
      let recommendedId = isNoBorder ? 'autoDetectBtn' : 'sampleBaseBtn';

      if (hasMask) {
        tipKey = 'guideTipReady';
        recommendedId = 'applyConvertBtn';
      } else if (isNoBorder && hasReference) {
        tipKey = 'guideTipReferenceReady';
        recommendedId = 'useReferenceBtn';
      } else if (!isNoBorder) {
        tipKey = 'guideTipMismatch';
        recommendedId = 'sampleBaseBtn';
      }

      tipEl.textContent = getLocalizedText(tipKey, '');
      setRecommendedAction(recommendedId);

      if (firstHintEl) {
        let showFirstHint = false;
        if (!skipFirstHint && step2Active && !step2FirstHintHandled) {
          try {
            const seen = sessionStorage.getItem(STEP2_FIRST_HINT_SESSION_KEY) === '1';
            if (!seen) {
              showFirstHint = true;
              sessionStorage.setItem(STEP2_FIRST_HINT_SESSION_KEY, '1');
            }
          } catch (err) {
            showFirstHint = true;
          }
          step2FirstHintHandled = true;
        }
        firstHintEl.style.display = showFirstHint ? 'block' : 'none';
      }
    }

    function updateFilmModeUI() {
      const filmBaseControls = document.getElementById('filmBaseControls');
      const positiveFilmInfo = document.getElementById('positiveFilmInfo');
      const modeToggle = document.getElementById('step2ModeToggle');
      const sampleBaseBtn = document.getElementById('sampleBaseBtn');
      const autoDetectBtn = document.getElementById('autoDetectBtn');
      const useReferenceBtn = document.getElementById('useReferenceBtn');
      const showFilmBase = requiresFilmBase();

      modeToggle.style.display = showFilmBase ? 'flex' : 'none';
      filmBaseControls.style.display = showFilmBase ? 'block' : 'none';
      positiveFilmInfo.style.display = showFilmBase ? 'none' : 'block';

      if (!showFilmBase) {
        if (state.samplingMode === 'filmBase') {
          state.samplingMode = null;
          sampleBaseBtn.classList.remove('active');
          canvas.style.cursor = 'default';
          glCanvas.style.cursor = 'default';
          hideLoupe();
        }
        document.getElementById('filmBasePreview').style.display = 'none';
        updateRollReferenceUI();
        updateStep2GuideCard();
        return;
      }

      if (state.samplingMode === 'filmBase' && state.step2Mode === 'noBorder') {
        state.samplingMode = null;
        sampleBaseBtn.classList.remove('active');
        canvas.style.cursor = 'default';
        glCanvas.style.cursor = 'default';
        hideLoupe();
      }

      sampleBaseBtn.style.display = state.step2Mode === 'border' ? 'inline-flex' : 'none';
      autoDetectBtn.style.display = 'inline-flex';
      useReferenceBtn.style.display = state.step2Mode === 'noBorder' ? 'inline-flex' : 'none';

      updateFilmBasePreview();
      updateRollReferenceUI();
      updateStep2GuideCard();
    }

    function updateFilmBasePreview() {
      const preview = document.getElementById('filmBasePreview');
      const colorBox = document.getElementById('filmBaseColor');
      const values = document.getElementById('filmBaseValues');

      if (!requiresFilmBase()) {
        preview.style.display = 'none';
        return;
      }

      if (state.filmBaseSet) {
        preview.style.display = 'flex';
        colorBox.style.backgroundColor = `rgb(${state.filmBase.r}, ${state.filmBase.g}, ${state.filmBase.b})`;
        values.textContent = `R: ${state.filmBase.r} G: ${state.filmBase.g} B: ${state.filmBase.b}`;
      } else {
        preview.style.display = 'none';
      }
    }

    document.getElementById('sampleBaseBtn').addEventListener('click', () => {
      if (!requiresFilmBase()) return;
      if (state.step2Mode !== 'border') return;
      state.samplingMode = 'filmBase';
      document.getElementById('sampleBaseBtn').classList.add('active');
      canvas.style.cursor = 'crosshair';
      glCanvas.style.cursor = 'crosshair';
    });

    document.getElementById('autoDetectBtn').addEventListener('click', () => {
      if (!requiresFilmBase()) return;
      const sourceData = state.croppedImageData || state.originalImageData;
      if (!sourceData) return;
      state.filmBase = autoDetectFilmBase(sourceData);
      state.filmBaseSet = true;
      updateFilmBasePreview();
      updateStep2GuideCard();
      markCurrentFileDirty();
    });

    document.getElementById('useReferenceBtn').addEventListener('click', () => {
      if (!hasRollReference()) {
        alert(i18n[currentLang].rollReferenceMissing || 'No roll reference is set.');
        return;
      }
      if (applyRollReferenceToCurrentForStep2()) {
        updateStep2GuideCard();
        alert(i18n[currentLang].rollReferenceAppliedCurrent || 'Roll reference applied to current image.');
      }
    });

    document.getElementById('applyConvertBtn').addEventListener('click', () => {
      if (requiresFilmBase() && !state.filmBaseSet) {
        const usedReference = state.step2Mode === 'noBorder' ? applyRollReferenceToCurrentForStep2() : false;
        if (!usedReference) {
          // Auto detect if not set
          const sourceData = state.croppedImageData || state.originalImageData;
          state.filmBase = autoDetectFilmBase(sourceData);
          state.filmBaseSet = true;
          updateFilmBasePreview();
          updateStep2GuideCard();
          markCurrentFileDirty();
          if (state.step2Mode === 'border') {
            alert(getLocalizedText('guideAutoDetectFallback', 'Mask was not sampled manually, so auto-detect was applied.'));
          } else if (!hasRollReference()) {
            alert(getLocalizedText('guideReferenceSuggestion', 'If auto-detect is unstable, set one frame as roll reference first.'));
          }
        }
      }
      processNegative();
    });

    // ===========================================
    // White Balance Sampling
    // ===========================================
    document.getElementById('sampleWBBtn').addEventListener('click', () => {
      state.samplingMode = 'whiteBalance';
      document.getElementById('sampleWBBtn').classList.add('active');
      canvas.style.cursor = 'crosshair';
      glCanvas.style.cursor = 'crosshair';
    });

    // ===========================================
    // Sampling Loupe (Magnifier)
    // ===========================================
    const LOUPE_PATCH_SIZE = 31;
    const LOUPE_HALF = (LOUPE_PATCH_SIZE - 1) / 2;
    const loupePatchData = new Uint8ClampedArray(LOUPE_PATCH_SIZE * LOUPE_PATCH_SIZE * 4);
    const loupePatch = new ImageData(loupePatchData, LOUPE_PATCH_SIZE, LOUPE_PATCH_SIZE);
    const loupePatchAdjustedData = new Uint8ClampedArray(LOUPE_PATCH_SIZE * LOUPE_PATCH_SIZE * 4);
    const loupePatchAdjusted = new ImageData(loupePatchAdjustedData, LOUPE_PATCH_SIZE, LOUPE_PATCH_SIZE);

    loupeSrcCanvas.width = LOUPE_PATCH_SIZE;
    loupeSrcCanvas.height = LOUPE_PATCH_SIZE;

    let loupeRaf = 0;
    let loupePending = null;

    function clampBetween(v, min, max) {
      if (v < min) return min;
      if (v > max) return max;
      return v;
    }

    function showLoupe() {
      loupe.style.display = 'block';
    }

    function hideLoupe() {
      if (loupeRaf) cancelAnimationFrame(loupeRaf);
      loupeRaf = 0;
      loupePending = null;
      loupe.style.display = 'none';
      loupeInfo.textContent = '';
    }

    function positionLoupe(clientX, clientY) {
      const containerRect = canvasContainer.getBoundingClientRect();
      const loupeRect = loupe.getBoundingClientRect();

      const offset = 18;
      const margin = 6;
      let left = clientX - containerRect.left + offset;
      let top = clientY - containerRect.top + offset;

      if (left + loupeRect.width + margin > containerRect.width) {
        left = clientX - containerRect.left - loupeRect.width - offset;
      }
      if (top + loupeRect.height + margin > containerRect.height) {
        top = clientY - containerRect.top - loupeRect.height - offset;
      }

      const maxLeft = Math.max(margin, containerRect.width - loupeRect.width - margin);
      const maxTop = Math.max(margin, containerRect.height - loupeRect.height - margin);
      loupe.style.left = clampBetween(left, margin, maxLeft) + 'px';
      loupe.style.top = clampBetween(top, margin, maxTop) + 'px';
    }

    function fillLoupePatchFromSource(sourceData, cx, cy) {
      const { width, height, data } = sourceData;
      let dstIdx = 0;
      for (let py = 0; py < LOUPE_PATCH_SIZE; py++) {
        const sy = clampBetween(cy + py - LOUPE_HALF, 0, height - 1);
        const row = sy * width * 4;
        for (let px = 0; px < LOUPE_PATCH_SIZE; px++) {
          const sx = clampBetween(cx + px - LOUPE_HALF, 0, width - 1);
          const srcIdx = row + sx * 4;
          loupePatchData[dstIdx] = data[srcIdx];
          loupePatchData[dstIdx + 1] = data[srcIdx + 1];
          loupePatchData[dstIdx + 2] = data[srcIdx + 2];
          loupePatchData[dstIdx + 3] = 255;
          dstIdx += 4;
        }
      }
    }

    function drawLoupeOverlay() {
      const pixelSize = loupeCanvas.width / LOUPE_PATCH_SIZE;
      const center = LOUPE_HALF * pixelSize + pixelSize / 2;
      const centerPixel = LOUPE_HALF * pixelSize;

	      // Center pixel outline
	      loupeCtx.lineWidth = 2;
	      loupeCtx.strokeStyle = 'rgba(0, 0, 0, 0.9)';
	      loupeCtx.strokeRect(centerPixel, centerPixel, pixelSize, pixelSize);
	      loupeCtx.lineWidth = 1;
	      loupeCtx.strokeStyle = 'rgba(255, 255, 255, 0.95)';
	      loupeCtx.strokeRect(centerPixel + 0.5, centerPixel + 0.5, pixelSize - 1, pixelSize - 1);

      // Crosshair (with outline for contrast)
      loupeCtx.lineCap = 'butt';
      loupeCtx.beginPath();
      loupeCtx.lineWidth = 3;
      loupeCtx.strokeStyle = 'rgba(0, 0, 0, 0.85)';
      loupeCtx.moveTo(center, 0);
      loupeCtx.lineTo(center, loupeCanvas.height);
      loupeCtx.moveTo(0, center);
      loupeCtx.lineTo(loupeCanvas.width, center);
      loupeCtx.stroke();

      loupeCtx.beginPath();
      loupeCtx.lineWidth = 1;
      loupeCtx.strokeStyle = 'rgba(255, 255, 255, 0.95)';
      loupeCtx.moveTo(center, 0);
      loupeCtx.lineTo(center, loupeCanvas.height);
      loupeCtx.moveTo(0, center);
      loupeCtx.lineTo(loupeCanvas.width, center);
      loupeCtx.stroke();
    }

    function updateLoupe() {
      loupeRaf = 0;
      const pending = loupePending;
      loupePending = null;

      if (!pending || !state.samplingMode || state.cropping) {
        hideLoupe();
        return;
      }

      const target = pending.target;
      const rect = target.getBoundingClientRect();
      if (rect.width <= 0 || rect.height <= 0) {
        hideLoupe();
        return;
      }

      const relX = (pending.clientX - rect.left) / rect.width;
      const relY = (pending.clientY - rect.top) / rect.height;
      if (relX < 0 || relX > 1 || relY < 0 || relY > 1) {
        hideLoupe();
        return;
      }

      let sourceData = null;
      const showAdjusted = state.samplingMode === 'whiteBalance';
      if (state.samplingMode === 'filmBase') {
        sourceData = state.croppedImageData || state.originalImageData;
      } else if (state.samplingMode === 'whiteBalance') {
        sourceData = state.processedImageData;
      }
      if (!sourceData) {
        hideLoupe();
        return;
      }

      const cx = clampBetween(Math.floor(relX * sourceData.width), 0, sourceData.width - 1);
      const cy = clampBetween(Math.floor(relY * sourceData.height), 0, sourceData.height - 1);

      fillLoupePatchFromSource(sourceData, cx, cy);

      let centerR = 0, centerG = 0, centerB = 0;
      const centerIdx = (LOUPE_HALF * LOUPE_PATCH_SIZE + LOUPE_HALF) * 4;

      if (showAdjusted) {
        applyAdjustmentsToBuffer(loupePatch, state, loupePatchAdjusted, 'full');
        loupeSrcCtx.putImageData(loupePatchAdjusted, 0, 0);
        centerR = loupePatchAdjustedData[centerIdx];
        centerG = loupePatchAdjustedData[centerIdx + 1];
        centerB = loupePatchAdjustedData[centerIdx + 2];
      } else {
        loupeSrcCtx.putImageData(loupePatch, 0, 0);
        centerR = loupePatchData[centerIdx];
        centerG = loupePatchData[centerIdx + 1];
        centerB = loupePatchData[centerIdx + 2];
      }

      loupeCtx.imageSmoothingEnabled = false;
      loupeCtx.clearRect(0, 0, loupeCanvas.width, loupeCanvas.height);
      loupeCtx.drawImage(loupeSrcCanvas, 0, 0, loupeCanvas.width, loupeCanvas.height);
      drawLoupeOverlay();

      loupeInfo.textContent = `x ${cx}  y ${cy}   RGB ${centerR} ${centerG} ${centerB}`;

      showLoupe();
      positionLoupe(pending.clientX, pending.clientY);
    }

    function handleLoupePointer(e) {
      if (!state.samplingMode || state.cropping) {
        hideLoupe();
        return;
      }

      loupePending = {
        clientX: e.clientX,
        clientY: e.clientY,
        target: e.currentTarget
      };

      if (!loupeRaf) {
        loupeRaf = requestAnimationFrame(updateLoupe);
      }
    }

    [canvas, glCanvas].forEach(el => {
      el.addEventListener('pointermove', handleLoupePointer);
      el.addEventListener('pointerdown', handleLoupePointer);
      el.addEventListener('pointerleave', hideLoupe);
      el.addEventListener('pointercancel', hideLoupe);
    });

    // ===========================================
    // Canvas Click Handler (Sampling)
    // ===========================================
    function handleSamplingClick(e) {
      if (state.cropping) return;
      if (!state.samplingMode) return;

      const target = e.currentTarget;
      const rect = target.getBoundingClientRect();
      if (rect.width <= 0 || rect.height <= 0) return;

      const relX = (e.clientX - rect.left) / rect.width;
      const relY = (e.clientY - rect.top) / rect.height;
      if (relX < 0 || relX > 1 || relY < 0 || relY > 1) return;

      if (state.samplingMode === 'filmBase') {
        const sourceData = state.croppedImageData || state.originalImageData;
        if (!sourceData) return;

        const x = Math.floor(relX * sourceData.width);
        const y = Math.floor(relY * sourceData.height);

        state.filmBase = sampleFilmBase(sourceData, x, y, 10);
        state.filmBaseSet = true;
        state.samplingMode = null;
        document.getElementById('sampleBaseBtn').classList.remove('active');
        canvas.style.cursor = 'default';
        glCanvas.style.cursor = 'default';
        hideLoupe();
        updateFilmBasePreview();
        updateStep2GuideCard();
        markCurrentFileDirty();
      } else if (state.samplingMode === 'whiteBalance') {
        // Sample from processed image (post-inversion)
        if (!state.processedImageData) return;

        const x = Math.floor(relX * state.processedImageData.width);
        const y = Math.floor(relY * state.processedImageData.height);

        const sample = sampleFilmBase(state.processedImageData, x, y, 5);
        const gray = (sample.r + sample.g + sample.b) / 3;

        // Calculate multipliers to make sampled point neutral
        state.wbR = sample.r > 0 ? gray / sample.r : 1;
        state.wbG = sample.g > 0 ? gray / sample.g : 1;
        state.wbB = sample.b > 0 ? gray / sample.b : 1;

        // Normalize so G=1
        const norm = state.wbG;
        state.wbR /= norm;
        state.wbG = 1;
        state.wbB /= norm;

        state.samplingMode = null;
        document.getElementById('sampleWBBtn').classList.remove('active');
        canvas.style.cursor = 'default';
        glCanvas.style.cursor = 'default';
        hideLoupe();
        updateWBSliders();
        markCurrentFileDirty();
        updateFull();
      }
    }

    canvas.addEventListener('click', handleSamplingClick);
    glCanvas.addEventListener('click', handleSamplingClick);

    // ===========================================
    // Film Type & Preset Selection
    // ===========================================
    function setFilmTypeButtons(type) {
      document.querySelectorAll('.film-type-btn').forEach(btn => {
        btn.classList.toggle('active', btn.dataset.type === type);
      });
    }

    document.querySelectorAll('.step2-mode-btn').forEach(btn => {
      btn.addEventListener('click', () => {
        setStep2Mode(btn.dataset.mode);
      });
    });

    document.querySelectorAll('.film-type-btn').forEach(btn => {
      btn.addEventListener('click', () => {
        state.filmType = btn.dataset.type;

        const defaultPreset = getDefaultPresetForType(state.filmType);
        state.filmPreset = defaultPreset;
        renderPresetOptions(state.filmPreset);
        setFilmTypeButtons(state.filmType);
        let modeUpdated = false;
        if (requiresFilmBase()) {
          setStep2Mode(suggestStep2Mode());
          modeUpdated = true;
        }
        if (!modeUpdated) {
          updateFilmModeUI();
        }

        markCurrentFileDirty();
        schedulePreviewUpdate();
      });
    });

    document.getElementById('filmPreset').addEventListener('change', (e) => {
      const preset = getPresetOrFallback(e.target.value, state.filmType);
      if (!preset) return;
      state.filmPreset = preset.id;
      state.filmType = preset.type;
      if (e.target.value !== state.filmPreset) {
        e.target.value = state.filmPreset;
      }
      setFilmTypeButtons(state.filmType);
      let modeUpdated = false;
      if (requiresFilmBase()) {
        setStep2Mode(suggestStep2Mode());
        modeUpdated = true;
      }
      if (!modeUpdated) {
        updateFilmModeUI();
      }

      markCurrentFileDirty();
      schedulePreviewUpdate();
    });

    setFilmTypeButtons(state.filmType);
    setStep2Mode(suggestStep2Mode());

    loadPresetDataset()
      .then(() => {
        const preset = getPresetOrFallback(state.filmPreset, state.filmType);
        if (!preset) return;
        state.filmPreset = preset.id;
        state.filmType = preset.type;
        setFilmTypeButtons(state.filmType);
        const presetSelect = document.getElementById('filmPreset');
        if (presetSelect && presetSelect.value !== state.filmPreset) {
          presetSelect.value = state.filmPreset;
        }
        setStep2Mode(suggestStep2Mode());
      })
      .catch((err) => {
        console.warn('Preset initialization failed.', err);
      });

    // ===========================================
    // Slider Controls
    // ===========================================
    const sliderBindings = [];
    const sliderBindingMap = new Map();

    function getStepDecimals(step) {
      const text = String(step);
      if (text.includes('e-')) {
        const exp = Number.parseInt(text.split('e-')[1], 10);
        return Number.isFinite(exp) ? exp : 0;
      }
      const dotIndex = text.indexOf('.');
      return dotIndex >= 0 ? (text.length - dotIndex - 1) : 0;
    }

    function normalizeSliderValue(value, min, max, step, decimals) {
      if (!Number.isFinite(value)) return min;

      let nextValue = Math.min(max, Math.max(min, value));
      if (Number.isFinite(step) && step > 0) {
        nextValue = min + (Math.round((nextValue - min) / step) * step);
      }
      return Number(nextValue.toFixed(decimals));
    }

    function formatSliderValue(value, decimals) {
      return decimals > 0 ? value.toFixed(decimals) : String(Math.round(value));
    }

    function setupSlider(id, stateKey, options = {}) {
      const slider = document.getElementById(id);
      const valueInput = document.getElementById(id + 'Value');
      if (!slider || !valueInput) return;

      const min = Number.parseFloat(slider.min);
      const max = Number.parseFloat(slider.max);
      const step = Number.parseFloat(slider.step || '1');
      const decimals = Number.isInteger(options.decimals) ? options.decimals : getStepDecimals(step);
      const format = options.format || ((value) => formatSliderValue(value, decimals));
      const normalize = (rawValue) => normalizeSliderValue(rawValue, min, max, step, decimals);

      const syncUI = (value) => {
        slider.value = String(value);
        valueInput.value = format(value);
      };

      const applyValue = (rawValue, commitFull = false) => {
        const value = normalize(rawValue);
        state[stateKey] = value;
        syncUI(value);
        markCurrentFileDirty();
        schedulePreviewUpdate();
        if (commitFull) scheduleFullUpdate();
      };

      slider.addEventListener('input', () => {
        applyValue(Number.parseFloat(slider.value), false);
      });

      slider.addEventListener('change', () => {
        applyValue(Number.parseFloat(slider.value), true);
      });

      valueInput.addEventListener('input', () => {
        const parsed = Number.parseFloat(valueInput.value);
        if (!Number.isFinite(parsed)) return;
        const value = normalize(parsed);
        state[stateKey] = value;
        slider.value = String(value);
        markCurrentFileDirty();
        schedulePreviewUpdate();
      });

      const commitFromInput = () => {
        const parsed = Number.parseFloat(valueInput.value);
        const sourceValue = Number.isFinite(parsed) ? parsed : state[stateKey];
        applyValue(sourceValue, true);
      };

      valueInput.addEventListener('blur', commitFromInput);
      valueInput.addEventListener('keydown', (event) => {
        if (event.key === 'Enter') {
          event.preventDefault();
          commitFromInput();
        }
      });

      const binding = { id, stateKey, slider, valueInput, normalize, format };
      sliderBindings.push(binding);
      sliderBindingMap.set(id, binding);
      syncUI(normalize(state[stateKey]));
    }

    function syncSliderFromState(id) {
      const binding = sliderBindingMap.get(id);
      if (!binding) return;
      const value = binding.normalize(Number.parseFloat(state[binding.stateKey]));
      state[binding.stateKey] = value;
      binding.slider.value = String(value);
      binding.valueInput.value = binding.format(value);
    }

    function syncAllSlidersFromState() {
      sliderBindings.forEach(binding => syncSliderFromState(binding.id));
    }

    function updateWBSliders() {
      ['wbR', 'wbG', 'wbB'].forEach(syncSliderFromState);
    }

    setupSlider('wbR', 'wbR', { decimals: 2 });
    setupSlider('wbG', 'wbG', { decimals: 2 });
    setupSlider('wbB', 'wbB', { decimals: 2 });
    setupSlider('exposure', 'exposure', { decimals: 1 });
    setupSlider('contrast', 'contrast');
    setupSlider('highlights', 'highlights');
    setupSlider('shadows', 'shadows');
    setupSlider('temperature', 'temperature');
    setupSlider('tint', 'tint');
    setupSlider('vibrance', 'vibrance');
    setupSlider('saturation', 'saturation');
    setupSlider('cyan', 'cyan');
    setupSlider('magenta', 'magenta');
    setupSlider('yellow', 'yellow');

    // ===========================================
    // Section Toggle
    // ===========================================
    document.querySelectorAll('.section-header').forEach(header => {
      header.addEventListener('click', () => {
        const toggle = header.querySelector('.section-toggle');
        const section = header.dataset.section;
        if (!section) return;

        const content = document.getElementById(section + 'SectionContent') ||
                       document.getElementById(section + 'Section');
        if (content && toggle) {
          toggle.classList.toggle('collapsed');
          content.classList.toggle('collapsed');
        }
      });
    });

    // ===========================================
    // Rotation
    // ===========================================
    function normalizeAngleDegrees(angle) {
      let normalized = Number.isFinite(angle) ? angle : 0;
      while (normalized > 180) normalized -= 360;
      while (normalized <= -180) normalized += 360;
      return normalized;
    }

    function applyRotationToImageData(imageData, angle) {
      if (!imageData) return null;
      const normalized = normalizeAngleDegrees(Number(angle) || 0);
      if (Math.abs(normalized) < 0.001) return imageData;

      const rad = normalized * Math.PI / 180;
      const w = imageData.width;
      const h = imageData.height;
      const cos = Math.abs(Math.cos(rad));
      const sin = Math.abs(Math.sin(rad));
      const newW = Math.max(1, Math.ceil(w * cos + h * sin));
      const newH = Math.max(1, Math.ceil(w * sin + h * cos));

      const srcCanvas = document.createElement('canvas');
      srcCanvas.width = w;
      srcCanvas.height = h;
      const srcCtx = srcCanvas.getContext('2d', { willReadFrequently: true });
      srcCtx.putImageData(imageData, 0, 0);

      const dstCanvas = document.createElement('canvas');
      dstCanvas.width = newW;
      dstCanvas.height = newH;
      const dstCtx = dstCanvas.getContext('2d', { willReadFrequently: true });
      dstCtx.translate(newW / 2, newH / 2);
      dstCtx.rotate(rad);
      dstCtx.drawImage(srcCanvas, -w / 2, -h / 2);

      return dstCtx.getImageData(0, 0, newW, newH);
    }

    function resizeImageDataForDetection(imageData, maxSide = AUTO_FRAME_MAX_SIDE) {
      if (!imageData) return null;
      const longest = Math.max(imageData.width, imageData.height);
      if (longest <= maxSide) return imageData;

      const scale = maxSide / longest;
      const targetW = Math.max(1, Math.round(imageData.width * scale));
      const targetH = Math.max(1, Math.round(imageData.height * scale));

      const srcCanvas = document.createElement('canvas');
      srcCanvas.width = imageData.width;
      srcCanvas.height = imageData.height;
      const srcCtx = srcCanvas.getContext('2d', { willReadFrequently: true });
      srcCtx.putImageData(imageData, 0, 0);

      const dstCanvas = document.createElement('canvas');
      dstCanvas.width = targetW;
      dstCanvas.height = targetH;
      const dstCtx = dstCanvas.getContext('2d', { willReadFrequently: true });
      dstCtx.drawImage(srcCanvas, 0, 0, targetW, targetH);
      return dstCtx.getImageData(0, 0, targetW, targetH);
    }

    function getOpenCvScriptBySource(src) {
      return Array.from(document.querySelectorAll('script[data-opencv-loader="1"]'))
        .find(script => script.dataset.opencvSource === src) || null;
    }

    function waitForScriptLoad(script, src) {
      return new Promise((resolve, reject) => {
        const loadState = script.dataset.loadState;
        if (loadState === 'loaded') {
          resolve();
          return;
        }
        if (loadState === 'failed') {
          reject(new Error(`OpenCV script load failed: ${src}`));
          return;
        }

        const onLoad = () => {
          cleanup();
          resolve();
        };
        const onError = () => {
          cleanup();
          reject(new Error(`OpenCV script load failed: ${src}`));
        };
        const cleanup = () => {
          script.removeEventListener('load', onLoad);
          script.removeEventListener('error', onError);
        };

        script.addEventListener('load', onLoad);
        script.addEventListener('error', onError);
      });
    }

    function waitForOpenCvRuntime(timeoutMs = 15000) {
      return new Promise((resolve, reject) => {
        if (!window.cv) {
          reject(new Error('OpenCV global is unavailable'));
          return;
        }
        if (window.cv.Mat) {
          resolve(true);
          return;
        }

        let settled = false;
        const timeoutId = window.setTimeout(() => {
          if (settled) return;
          settled = true;
          reject(new Error('OpenCV runtime init timeout'));
        }, timeoutMs);

        const prev = window.cv.onRuntimeInitialized;
        window.cv.onRuntimeInitialized = () => {
          if (typeof prev === 'function') {
            try {
              prev();
            } catch (err) {
              console.warn('Previous OpenCV runtime hook failed:', err);
            }
          }
          if (settled) return;
          settled = true;
          window.clearTimeout(timeoutId);
          if (window.cv && window.cv.Mat) {
            resolve(true);
          } else {
            reject(new Error('OpenCV initialized without Mat API'));
          }
        };
      });
    }

    async function loadOpenCvFromSource(src) {
      if (window.cv && window.cv.Mat) {
        opencvActiveSource = src;
        return true;
      }

      let script = getOpenCvScriptBySource(src);
      if (script && script.dataset.loadState === 'failed') {
        script.remove();
        script = null;
      }

      if (!script) {
        script = document.createElement('script');
        script.src = src;
        script.async = true;
        script.defer = true;
        script.dataset.opencvLoader = '1';
        script.dataset.opencvSource = src;
        script.dataset.loadState = 'loading';
        script.onload = () => {
          script.dataset.loadState = 'loaded';
        };
        script.onerror = () => {
          script.dataset.loadState = 'failed';
        };
        document.head.appendChild(script);
      }

      await waitForScriptLoad(script, src);

      if (!window.cv) {
        throw new Error(`OpenCV global unavailable after loading ${src}`);
      }
      if (!window.cv.Mat) {
        await waitForOpenCvRuntime();
      }
      if (!(window.cv && window.cv.Mat)) {
        throw new Error(`OpenCV runtime incomplete after loading ${src}`);
      }

      opencvActiveSource = src;
      return true;
    }

    async function ensureOpenCvReady() {
      if (window.cv && window.cv.Mat) return true;
      if (opencvReadyPromise) return opencvReadyPromise;

      opencvReadyPromise = (async () => {
        const errors = [];
        for (const src of OPENCV_SCRIPT_CANDIDATES) {
          try {
            await loadOpenCvFromSource(src);
            if (opencvActiveSource) {
              console.info('OpenCV loaded from:', opencvActiveSource);
            }
            return true;
          } catch (err) {
            const message = err?.message || String(err);
            errors.push(`[${src}] ${message}`);
            console.warn('OpenCV source failed:', src, message);
          }
        }

        console.error('OpenCV unavailable. Tried sources:', errors.join(' | '));
        return false;
      })();

      const ready = await opencvReadyPromise;
      if (!ready) {
        opencvReadyPromise = null;
      }
      return ready;
    }

    function getAutoFrameAspectTargets() {
      const pref = state.autoFrame && state.autoFrame.formatPreference ? state.autoFrame.formatPreference : 'auto';
      const allowed120Map = (state.autoFrame && state.autoFrame.allowed120Formats) || {};
      const enabled120 = AUTO_FRAME_DEFAULT_120_FORMATS.filter(fmt => allowed120Map[fmt] !== false);
      const safe120 = enabled120.length ? enabled120 : ['6x6'];

      const targets = [];
      const addTarget = (key, weight = 1) => {
        const ratio = AUTO_FRAME_FORMAT_RATIOS[key];
        if (!Number.isFinite(ratio)) return;
        targets.push({ key, ratio, weight: clampBetween(weight, 0.4, 1.2) });
      };

      if (pref === '135') {
        addTarget('135', 1.05);
        safe120.forEach(fmt => addTarget(`120-${fmt}`, 0.78));
      } else if (pref === '120') {
        safe120.forEach(fmt => addTarget(`120-${fmt}`, 1.05));
        addTarget('135', 0.78);
      } else {
        addTarget('135', 1);
        safe120.forEach(fmt => addTarget(`120-${fmt}`, 1));
      }
      return targets.length ? targets : [{ key: '135', ratio: 1.5, weight: 1 }];
    }

    function scoreAspectAgainstTargets(ratio, targets) {
      const safeRatio = Math.max(0.01, Number(ratio) || 1);
      let best = { score: 0, format: 'unknown' };
      targets.forEach(target => {
        const delta = Math.abs(safeRatio - target.ratio) / target.ratio;
        const normalized = 1 - clampBetween(delta / 0.45, 0, 1);
        const weighted = clampBetween(normalized * target.weight, 0, 1);
        if (weighted > best.score) {
          best = { score: weighted, format: target.key };
        }
      });
      return best;
    }

    function sanitizeBound(bound, imageWidth, imageHeight) {
      if (!bound) return null;
      const left = clampBetween(Math.floor(Number(bound.x) || 0), 0, imageWidth - 1);
      const top = clampBetween(Math.floor(Number(bound.y) || 0), 0, imageHeight - 1);
      const maxWidth = imageWidth - left;
      const maxHeight = imageHeight - top;
      if (maxWidth < 1 || maxHeight < 1) return null;
      const width = clampBetween(Math.floor(Number(bound.width) || 0), 1, maxWidth);
      const height = clampBetween(Math.floor(Number(bound.height) || 0), 1, maxHeight);
      if (width < 1 || height < 1) return null;
      return { x: left, y: top, width, height };
    }

    function orderPointsClockwise(points) {
      if (!Array.isArray(points) || points.length !== 4) return [];
      const center = points.reduce((acc, p) => {
        acc.x += p.x;
        acc.y += p.y;
        return acc;
      }, { x: 0, y: 0 });
      center.x /= points.length;
      center.y /= points.length;
      return [...points].sort((a, b) => {
        const angleA = Math.atan2(a.y - center.y, a.x - center.x);
        const angleB = Math.atan2(b.y - center.y, b.x - center.x);
        return angleA - angleB;
      });
    }

    function computeOrthogonality(points) {
      if (!Array.isArray(points) || points.length !== 4) return 0.65;
      const ordered = orderPointsClockwise(points);
      if (ordered.length !== 4) return 0.65;

      let deviationSum = 0;
      for (let i = 0; i < 4; i++) {
        const prev = ordered[(i + 3) % 4];
        const curr = ordered[i];
        const next = ordered[(i + 1) % 4];
        const v1x = prev.x - curr.x;
        const v1y = prev.y - curr.y;
        const v2x = next.x - curr.x;
        const v2y = next.y - curr.y;
        const len1 = Math.hypot(v1x, v1y);
        const len2 = Math.hypot(v2x, v2y);
        if (len1 < 0.001 || len2 < 0.001) {
          deviationSum += 45;
          continue;
        }
        const cosTheta = clampBetween((v1x * v2x + v1y * v2y) / (len1 * len2), -1, 1);
        const angle = Math.acos(cosTheta) * 180 / Math.PI;
        deviationSum += Math.abs(90 - angle);
      }
      const avgDeviation = deviationSum / 4;
      return 1 - clampBetween(avgDeviation / 30, 0, 1);
    }

    function computeParallelism(points) {
      if (!Array.isArray(points) || points.length !== 4) return 0.65;
      const ordered = orderPointsClockwise(points);
      if (ordered.length !== 4) return 0.65;

      const edges = [];
      for (let i = 0; i < 4; i++) {
        const p1 = ordered[i];
        const p2 = ordered[(i + 1) % 4];
        let orientation = Math.atan2(p2.y - p1.y, p2.x - p1.x) * 180 / Math.PI;
        if (orientation < 0) orientation += 180;
        edges.push(orientation);
      }

      const pairDelta = (a, b) => {
        let delta = Math.abs(a - b);
        if (delta > 90) delta = 180 - delta;
        return delta;
      };

      const dev1 = pairDelta(edges[0], edges[2]);
      const dev2 = pairDelta(edges[1], edges[3]);
      const avgDeviation = (dev1 + dev2) / 2;
      return 1 - clampBetween(avgDeviation / 20, 0, 1);
    }

    function extractApproxPoints(approxMat) {
      if (!approxMat || !approxMat.data32S) return [];
      const data = approxMat.data32S;
      const points = [];
      for (let i = 0; i + 1 < data.length; i += 2) {
        points.push({ x: data[i], y: data[i + 1] });
      }
      return points;
    }

    function edgePixelAt(mat, x, y) {
      if (!mat || !Number.isFinite(x) || !Number.isFinite(y)) return 0;
      const safeX = clampBetween(Math.round(x), 0, mat.cols - 1);
      const safeY = clampBetween(Math.round(y), 0, mat.rows - 1);
      return mat.ucharPtr(safeY, safeX)[0] > 0 ? 1 : 0;
    }

    function computeEdgeSupport(edges, bound) {
      if (!edges || !bound) return 0;
      const left = bound.x;
      const right = bound.x + bound.width - 1;
      const top = bound.y;
      const bottom = bound.y + bound.height - 1;
      if (right <= left || bottom <= top) return 0;

      const step = Math.max(1, Math.round(Math.min(bound.width, bound.height) / 120));
      let hits = 0;
      let total = 0;

      for (let x = left; x <= right; x += step) {
        hits += edgePixelAt(edges, x, top);
        hits += edgePixelAt(edges, x, bottom);
        total += 2;
      }
      for (let y = top; y <= bottom; y += step) {
        hits += edgePixelAt(edges, left, y);
        hits += edgePixelAt(edges, right, y);
        total += 2;
      }

      return total > 0 ? clampBetween(hits / total, 0, 1) : 0;
    }

    function scoreFrameCandidate(candidate, context) {
      if (!candidate || !context) return null;
      const { imageWidth, imageHeight, imageArea, edges, aspectTargets } = context;
      const bound = sanitizeBound(candidate.bound, imageWidth, imageHeight);
      if (!bound) return null;

      const area = Math.max(1, Number(candidate.area) || (bound.width * bound.height));
      const areaRatio = area / imageArea;
      const rectWidth = Math.max(1, Number(candidate.minRectWidth) || bound.width);
      const rectHeight = Math.max(1, Number(candidate.minRectHeight) || bound.height);
      const rectArea = Math.max(1, rectWidth * rectHeight);
      const rectangularity = clampBetween(area / rectArea, 0, 1);

      const areaCoverage = clampBetween(areaRatio / 0.88, 0, 1);
      const overshootPenalty = areaRatio > 0.97 ? clampBetween((areaRatio - 0.97) / 0.03, 0, 1) * 0.35 : 0;
      const areaScore = clampBetween(areaCoverage - overshootPenalty, 0, 1);

      const points = Array.isArray(candidate.points) ? candidate.points : [];
      const orthogonality = clampBetween(Number(candidate.orthogonalityHint), 0, 1) || computeOrthogonality(points);
      const parallelism = clampBetween(Number(candidate.parallelismHint), 0, 1) || computeParallelism(points);
      const edgeSupport = computeEdgeSupport(edges, bound);

      const centerX = bound.x + (bound.width / 2);
      const centerY = bound.y + (bound.height / 2);
      const centerDist = Math.hypot(centerX - (imageWidth / 2), centerY - (imageHeight / 2));
      const centerPrior = 1 - clampBetween(centerDist / (Math.hypot(imageWidth, imageHeight) * 0.45), 0, 1);

      const ratio = Math.max(rectWidth, rectHeight) / Math.max(1, Math.min(rectWidth, rectHeight));
      const aspect = scoreAspectAgainstTargets(ratio, aspectTargets);

      const score = (
        areaScore * AUTO_FRAME_SCORE_WEIGHTS.area +
        rectangularity * AUTO_FRAME_SCORE_WEIGHTS.rectangularity +
        orthogonality * AUTO_FRAME_SCORE_WEIGHTS.orthogonality +
        parallelism * AUTO_FRAME_SCORE_WEIGHTS.parallelism +
        edgeSupport * AUTO_FRAME_SCORE_WEIGHTS.edgeSupport +
        centerPrior * AUTO_FRAME_SCORE_WEIGHTS.centerPrior +
        aspect.score * AUTO_FRAME_SCORE_WEIGHTS.aspect
      );

      return {
        ...candidate,
        bound,
        score: clampBetween(score, 0, 1),
        areaRatio,
        detectedFormat: aspect.format,
        scoreBreakdown: {
          area: Number(areaScore.toFixed(3)),
          rectangularity: Number(rectangularity.toFixed(3)),
          orthogonality: Number(orthogonality.toFixed(3)),
          parallelism: Number(parallelism.toFixed(3)),
          edgeSupport: Number(edgeSupport.toFixed(3)),
          centerPrior: Number(centerPrior.toFixed(3)),
          aspect: Number(aspect.score.toFixed(3))
        },
        minRect: {
          angle: Number(candidate.minRectAngle) || 0,
          width: rectWidth,
          height: rectHeight
        }
      };
    }

    function buildHoughCandidate(edges, imageWidth, imageHeight) {
      if (!window.cv.HoughLinesP) return null;
      const lines = new window.cv.Mat();
      try {
        const minDim = Math.min(imageWidth, imageHeight);
        window.cv.HoughLinesP(
          edges,
          lines,
          1,
          Math.PI / 180,
          70,
          Math.max(40, Math.round(minDim * 0.25)),
          Math.max(8, Math.round(minDim * 0.02))
        );

        if (!lines.rows || !lines.data32S) return null;
        const data = lines.data32S;
        let left = Infinity;
        let top = Infinity;
        let right = -Infinity;
        let bottom = -Infinity;
        let hCount = 0;
        let vCount = 0;

        for (let i = 0; i < lines.rows; i++) {
          const idx = i * 4;
          const x1 = data[idx];
          const y1 = data[idx + 1];
          const x2 = data[idx + 2];
          const y2 = data[idx + 3];
          const dx = x2 - x1;
          const dy = y2 - y1;
          const length = Math.hypot(dx, dy);
          if (length < minDim * 0.18) continue;

          let angle = Math.abs(Math.atan2(dy, dx) * 180 / Math.PI);
          if (angle > 90) angle = 180 - angle;

          if (angle <= 16) {
            hCount++;
          } else if (angle >= 74) {
            vCount++;
          } else {
            continue;
          }

          left = Math.min(left, x1, x2);
          right = Math.max(right, x1, x2);
          top = Math.min(top, y1, y2);
          bottom = Math.max(bottom, y1, y2);
        }

        if (hCount < 2 || vCount < 2) return null;
        if (!Number.isFinite(left) || !Number.isFinite(top) || !Number.isFinite(right) || !Number.isFinite(bottom)) {
          return null;
        }

        const margin = Math.round(minDim * 0.006);
        const bound = sanitizeBound({
          x: left - margin,
          y: top - margin,
          width: (right - left) + margin * 2,
          height: (bottom - top) + margin * 2
        }, imageWidth, imageHeight);
        if (!bound) return null;

        return {
          method: 'hough',
          area: bound.width * bound.height,
          bound,
          minRectWidth: bound.width,
          minRectHeight: bound.height,
          minRectAngle: 0,
          points: [
            { x: bound.x, y: bound.y },
            { x: bound.x + bound.width, y: bound.y },
            { x: bound.x + bound.width, y: bound.y + bound.height },
            { x: bound.x, y: bound.y + bound.height }
          ],
          orthogonalityHint: 1,
          parallelismHint: 1
        };
      } catch (err) {
        console.warn('Hough candidate failed:', err);
        return null;
      } finally {
        lines.delete();
      }
    }

    function detectFrameCandidatesWithCv(imageData, options = {}) {
      if (!(window.cv && window.cv.Mat) || !imageData) return [];

      const minAreaRatio = Number.isFinite(options.minAreaRatio) ? options.minAreaRatio : 0.05;
      const retrievalMode = options.retrievalMode === 'external' ? window.cv.RETR_EXTERNAL : window.cv.RETR_LIST;
      const aspectTargets = getAutoFrameAspectTargets();
      const src = window.cv.matFromImageData(imageData);
      const imageWidth = src.cols;
      const imageHeight = src.rows;
      const imageArea = Math.max(1, imageWidth * imageHeight);

      let gray = null;
      let claheEnhanced = null;
      let topHat = null;
      let blackHat = null;
      let merged = null;
      let blurred = null;
      let edges = null;
      let kernel3 = null;
      let kernel7 = null;
      let contours = null;
      let hierarchy = null;

      try {
        gray = new window.cv.Mat();
        claheEnhanced = new window.cv.Mat();
        topHat = new window.cv.Mat();
        blackHat = new window.cv.Mat();
        merged = new window.cv.Mat();
        blurred = new window.cv.Mat();
        edges = new window.cv.Mat();
        kernel3 = window.cv.getStructuringElement(window.cv.MORPH_RECT, new window.cv.Size(3, 3));
        kernel7 = window.cv.getStructuringElement(window.cv.MORPH_RECT, new window.cv.Size(7, 7));
        contours = new window.cv.MatVector();
        hierarchy = new window.cv.Mat();

        window.cv.cvtColor(src, gray, window.cv.COLOR_RGBA2GRAY);
        let claheApplied = false;
        let clahe = null;
        try {
          if (window.cv.createCLAHE && typeof window.cv.createCLAHE === 'function') {
            clahe = window.cv.createCLAHE(2.0, new window.cv.Size(8, 8));
          } else if (window.cv.CLAHE && typeof window.cv.CLAHE === 'function') {
            clahe = new window.cv.CLAHE(2.0, new window.cv.Size(8, 8));
          }
          if (clahe && typeof clahe.apply === 'function') {
            clahe.apply(gray, claheEnhanced);
            claheApplied = true;
          }
        } catch (err) {
          claheApplied = false;
        } finally {
          if (clahe && typeof clahe.delete === 'function') {
            clahe.delete();
          }
        }
        if (!claheApplied) {
          window.cv.equalizeHist(gray, claheEnhanced);
        }
        window.cv.morphologyEx(claheEnhanced, topHat, window.cv.MORPH_TOPHAT, kernel7);
        window.cv.morphologyEx(claheEnhanced, blackHat, window.cv.MORPH_BLACKHAT, kernel7);
        window.cv.addWeighted(claheEnhanced, 1.0, topHat, 0.7, 0, merged);
        window.cv.addWeighted(merged, 1.0, blackHat, -0.45, 0, merged);
        window.cv.GaussianBlur(merged, blurred, new window.cv.Size(5, 5), 0, 0, window.cv.BORDER_DEFAULT);
        window.cv.Canny(blurred, edges, 40, 140, 3, false);
        window.cv.dilate(edges, edges, kernel3, new window.cv.Point(-1, -1), 1);

        const candidates = [];
        window.cv.findContours(edges, contours, hierarchy, retrievalMode, window.cv.CHAIN_APPROX_SIMPLE);
        for (let i = 0; i < contours.size(); i++) {
          const contour = contours.get(i);
          let approx = null;
          try {
            const area = Math.abs(window.cv.contourArea(contour));
            if (area < imageArea * minAreaRatio) continue;

            const bound = window.cv.boundingRect(contour);
            const minRect = window.cv.minAreaRect(contour);
            const perimeter = window.cv.arcLength(contour, true);
            approx = new window.cv.Mat();
            window.cv.approxPolyDP(contour, approx, Math.max(2, perimeter * 0.02), true);
            const approxPoints = extractApproxPoints(approx);

            const scored = scoreFrameCandidate({
              method: 'contour',
              area,
              bound,
              minRectWidth: minRect.size.width,
              minRectHeight: minRect.size.height,
              minRectAngle: minRect.angle,
              points: approxPoints.length === 4 ? approxPoints : []
            }, {
              imageWidth,
              imageHeight,
              imageArea,
              edges,
              aspectTargets
            });
            if (scored) candidates.push(scored);
          } finally {
            contour.delete();
            if (approx) approx.delete();
          }
        }

        const houghCandidate = buildHoughCandidate(edges, imageWidth, imageHeight);
        if (houghCandidate) {
          const scoredHough = scoreFrameCandidate(houghCandidate, {
            imageWidth,
            imageHeight,
            imageArea,
            edges,
            aspectTargets
          });
          if (scoredHough) candidates.push(scoredHough);
        }

        return candidates
          .filter(candidate => candidate.areaRatio >= minAreaRatio)
          .sort((a, b) => b.score - a.score)
          .slice(0, 10);
      } catch (err) {
        console.error('OpenCV border analysis failed:', err);
        return [];
      } finally {
        src.delete();
        if (gray) gray.delete();
        if (claheEnhanced) claheEnhanced.delete();
        if (topHat) topHat.delete();
        if (blackHat) blackHat.delete();
        if (merged) merged.delete();
        if (blurred) blurred.delete();
        if (edges) edges.delete();
        if (kernel3) kernel3.delete();
        if (kernel7) kernel7.delete();
        if (contours) contours.delete();
        if (hierarchy) hierarchy.delete();
      }
    }

    function buildRotationCandidates(baseCandidates = []) {
      const angleSet = new Set([0]);
      baseCandidates.slice(0, 4).forEach(candidate => {
        const minRect = candidate && candidate.minRect ? candidate.minRect : null;
        if (!minRect) return;
        let angle = Number(minRect.angle) || 0;
        const width = Number(minRect.width) || 0;
        const height = Number(minRect.height) || 0;
        if (width < height) angle += 90;
        [angle, -angle, angle + 90, angle - 90, angle + 180].forEach(raw => {
          const normalized = normalizeAngleDegrees(raw);
          const quantized = Math.round(normalized * 10) / 10;
          if (Math.abs(quantized) <= 0.1) {
            angleSet.add(0);
          } else {
            angleSet.add(quantized);
          }
        });
      });
      return Array.from(angleSet);
    }

    function buildCropRegionFromBound(bound, imageData, marginRatio = 0.02) {
      if (!bound || !imageData) return null;
      const margin = Math.round(Math.min(imageData.width, imageData.height) * Math.max(0, marginRatio));
      const left = clampBetween(bound.x - margin, 0, imageData.width - 1);
      const top = clampBetween(bound.y - margin, 0, imageData.height - 1);
      const maxWidth = imageData.width - left;
      const maxHeight = imageData.height - top;
      const width = clampBetween(bound.width + margin * 2, 1, maxWidth);
      const height = clampBetween(bound.height + margin * 2, 1, maxHeight);
      return sanitizeCropRegionForImage({ left, top, width, height }, imageData);
    }

    function detectAxisAlignedCropRegion(imageData, marginRatio = 0.02) {
      const candidates = detectFrameCandidatesWithCv(imageData, {
        minAreaRatio: 0.04,
        retrievalMode: 'external'
      });
      if (!candidates.length) return null;

      const best = candidates[0];
      const cropRegion = buildCropRegionFromBound(best.bound, imageData, marginRatio);
      if (!cropRegion) return null;
      const cropAreaRatio = (cropRegion.width * cropRegion.height) / (imageData.width * imageData.height);
      const confidence = clampBetween((best.score * 0.78) + (Math.min(cropAreaRatio / 0.92, 1) * 0.22), 0, 1);
      return {
        cropRegion,
        confidence,
        candidate: best
      };
    }

    function inferConfidenceLevel(confidence) {
      const high = Number.isFinite(state.autoFrame.highConfidence) ? state.autoFrame.highConfidence : 0.72;
      const min = Number.isFinite(state.autoFrame.minConfidence) ? state.autoFrame.minConfidence : 0.55;
      if (confidence >= high) return 'high';
      if (confidence >= min) return 'medium';
      return 'low';
    }

    async function detectFrameAndRotation(imageData) {
      if (!imageData) return null;
      const ready = await ensureOpenCvReady();
      if (!ready) return null;

      const previewData = resizeImageDataForDetection(imageData, AUTO_FRAME_MAX_SIDE);
      const previewCandidates = detectFrameCandidatesWithCv(previewData, { minAreaRatio: 0.04 });
      if (!previewCandidates.length) return null;

      const angleCandidates = buildRotationCandidates(previewCandidates);
      let bestPreview = null;
      for (const angle of angleCandidates) {
        const rotatedPreview = Math.abs(angle) < 0.001 ? previewData : applyRotationToImageData(previewData, angle);
        const cropPreview = detectAxisAlignedCropRegion(rotatedPreview, state.autoFrame.marginRatio);
        if (!cropPreview) continue;
        const baseScore = previewCandidates[0] ? previewCandidates[0].score : 0.5;
        const score = (baseScore * 0.28) + (cropPreview.confidence * 0.72);
        if (!bestPreview || score > bestPreview.score) {
          bestPreview = { angle, score, cropPreview };
        }
      }

      if (!bestPreview) return null;
      const normalizedAngle = Math.abs(bestPreview.angle) < 0.15 ? 0 : Number(bestPreview.angle.toFixed(2));
      const rotatedFull = Math.abs(normalizedAngle) < 0.001 ? imageData : applyRotationToImageData(imageData, normalizedAngle);
      const cropFull = detectAxisAlignedCropRegion(rotatedFull, state.autoFrame.marginRatio);
      if (!cropFull) return null;

      const confidence = Number(clampBetween((bestPreview.score * 0.35) + (cropFull.confidence * 0.65), 0, 1).toFixed(2));
      const confidenceLevel = inferConfidenceLevel(confidence);
      const detectedFormat = cropFull.candidate && cropFull.candidate.detectedFormat
        ? cropFull.candidate.detectedFormat
        : 'unknown';

      return {
        angle: normalizedAngle,
        cropRegion: cropFull.cropRegion,
        confidence,
        confidenceLevel,
        detectedFormat,
        rotatedImageData: rotatedFull,
        diagnostics: {
          method: cropFull.candidate ? cropFull.candidate.method : 'unknown',
          scoreBreakdown: cropFull.candidate ? cropFull.candidate.scoreBreakdown : null
        }
      };
    }

    function formatAutoFrameDetail(result) {
      const detailTemplate = i18n[currentLang].autoFramePreviewDetail
        || 'Rotate {angle}°, crop to {width}x{height}, confidence {confidence}';
      const base = detailTemplate
        .replace('{angle}', String(result.angle))
        .replace('{width}', String(result.cropRegion.width))
        .replace('{height}', String(result.cropRegion.height))
        .replace('{confidence}', String(result.confidence.toFixed(2)));
      const formatPart = result.detectedFormat ? `\nformat: ${result.detectedFormat}` : '';
      return `${base}${formatPart}`;
    }

    function applyAutoFrameResult(result) {
      if (!result || !state.originalImageData) return false;

      state.rotationAngle = normalizeAngleDegrees(result.angle || 0);
      state.croppedImageData = null;
      state.cropRegion = null;
      state.originalImageData = result.rotatedImageData
        || (Math.abs(state.rotationAngle) < 0.001
          ? state.originalImageData
          : applyRotationToImageData(state.originalImageData, state.rotationAngle));
      applyCropRegionToLoadedImage(result.cropRegion, { refreshDisplay: true });
      state.autoFrame.lastDiagnostics = {
        confidence: result.confidence,
        detectedFormat: result.detectedFormat || 'unknown',
        method: result.diagnostics && result.diagnostics.method ? result.diagnostics.method : 'unknown',
        confidenceLevel: result.confidenceLevel || inferConfidenceLevel(result.confidence || 0)
      };
      updateAutoFrameDiagnosticsUI();
      setStep2Mode(suggestStep2Mode());
      return true;
    }

    function applyAutoFrameRotationOnly(result) {
      if (!result || !state.originalImageData) return false;
      state.rotationAngle = normalizeAngleDegrees(result.angle || 0);
      state.cropRegion = null;
      state.croppedImageData = null;
      state.originalImageData = result.rotatedImageData
        || (Math.abs(state.rotationAngle) < 0.001
          ? state.originalImageData
          : applyRotationToImageData(state.originalImageData, state.rotationAngle));
      displayNegative(state.originalImageData);
      state.autoFrame.lastDiagnostics = {
        confidence: result.confidence,
        detectedFormat: result.detectedFormat || 'unknown',
        method: result.diagnostics && result.diagnostics.method ? result.diagnostics.method : 'unknown',
        confidenceLevel: result.confidenceLevel || inferConfidenceLevel(result.confidence || 0),
        rotateOnly: true
      };
      updateAutoFrameDiagnosticsUI();
      setStep2Mode(suggestStep2Mode());
      return true;
    }

    function applyRotation(angle) {
      if (!state.originalImageData || !Number.isFinite(angle) || angle === 0) return;

      const rotatedData = applyRotationToImageData(state.originalImageData, angle);
      if (!rotatedData) return;

      state.originalImageData = rotatedData;
      state.croppedImageData = null;
      state.cropRegion = null;
      state.rotationAngle = normalizeAngleDegrees((state.rotationAngle || 0) + angle);

      displayNegative(rotatedData);
      setStep2Mode(suggestStep2Mode());
      markCurrentFileDirty();
    }

    function applyMirror() {
      const sourceData = state.croppedImageData || state.originalImageData;
      if (!sourceData) return;

      const w = canvas.width;
      const h = canvas.height;
      const offCanvas = document.createElement('canvas');
      offCanvas.width = w;
      offCanvas.height = h;
      const offCtx = offCanvas.getContext('2d');

      offCtx.translate(w, 0);
      offCtx.scale(-1, 1);
      offCtx.drawImage(canvas, 0, 0);

      ctx.clearRect(0, 0, w, h);
      ctx.drawImage(offCanvas, 0, 0);

      const newImageData = ctx.getImageData(0, 0, w, h);
      if (state.croppedImageData) {
        state.croppedImageData = newImageData;
      } else {
        state.originalImageData = newImageData;
      }

      transformCanvas.width = w;
      transformCanvas.height = h;
      transformCtx.drawImage(offCanvas, 0, 0);
      adjustCanvasDisplay(w, h);
      markCurrentFileDirty();
    }

    document.getElementById('rotateLeftBtn').addEventListener('click', () => applyRotation(-90));
    document.getElementById('rotateRightBtn').addEventListener('click', () => applyRotation(90));
    document.getElementById('mirrorBtn').addEventListener('click', () => applyMirror());

    document.getElementById('applyRotateBtn').addEventListener('click', () => {
      const angle = parseFloat(document.getElementById('rotateAngle').value) || 0;
      if (angle !== 0) {
        applyRotation(angle);
        document.getElementById('rotateAngle').value = 0;
      }
    });

    async function applyAutoFrameToCurrent() {
      if (state.currentStep !== 1) return;
      const source = state.loadedBaseImageData || state.originalImageData;
      if (!source) return;

      const button = document.getElementById('autoFrameBtn');
      const previousText = button ? button.textContent : '';
      if (button) {
        button.disabled = true;
        button.textContent = i18n[currentLang].autoFrameAnalyzing || 'Analyzing frame borders...';
      }

      try {
        const ready = await ensureOpenCvReady();
        if (!ready) {
          alert(i18n[currentLang].autoFrameCvLoadError || 'OpenCV failed to load. Auto frame is unavailable.');
          return;
        }

        const result = await detectFrameAndRotation(source);
        if (!result) {
          alert(i18n[currentLang].autoFrameNoReliableBorder || 'No reliable frame border detected. Please crop manually.');
          return;
        }

        const detail = formatAutoFrameDetail(result);
        state.originalImageData = source;
        const lowBehavior = state.autoFrame.lowConfidenceBehavior || 'suggest';
        let applied = false;

        if (result.confidenceLevel === 'low') {
          if (lowBehavior === 'rotateOnly') {
            if (Math.abs(result.angle) > 0.05) {
              applied = applyAutoFrameRotationOnly(result);
              if (applied) {
                const template = i18n[currentLang].autoFrameRotateOnlyApplied
                  || 'Low confidence: applied rotation only ({angle}°).';
                alert(template.replace('{angle}', String(result.angle)));
              }
            } else {
              alert(i18n[currentLang].autoFrameNoReliableBorder || 'No reliable frame border detected. Please crop manually.');
            }
          } else if (lowBehavior === 'ignore') {
            alert(i18n[currentLang].autoFrameNoReliableBorder || 'No reliable frame border detected. Please crop manually.');
          } else {
            const title = i18n[currentLang].autoFrameLowConfidenceTitle
              || 'Low-confidence frame detected. Apply suggested crop anyway?';
            if (window.confirm(`${title}\n${detail}`)) {
              applied = applyAutoFrameResult(result);
            }
          }
        } else if (result.confidenceLevel === 'high' && state.autoFrame.autoApplyHighConfidence) {
          applied = applyAutoFrameResult(result);
        } else {
          const title = i18n[currentLang].autoFramePreviewTitle || 'Reliable frame detected. Apply auto rotation and crop?';
          if (window.confirm(`${title}\n${detail}`)) {
            applied = applyAutoFrameResult(result);
          }
        }

        if (applied) {
          markCurrentFileDirty();
        } else {
          state.autoFrame.lastDiagnostics = {
            confidence: result.confidence,
            detectedFormat: result.detectedFormat || 'unknown',
            method: result.diagnostics && result.diagnostics.method ? result.diagnostics.method : 'unknown',
            confidenceLevel: result.confidenceLevel || inferConfidenceLevel(result.confidence || 0)
          };
          updateAutoFrameDiagnosticsUI();
        }
      } finally {
        if (button) {
          button.textContent = previousText || (i18n[currentLang].autoFrame || 'Auto Frame');
          updateAutoFrameButtons();
        }
      }
    }

    async function applyAutoFrameToSelected() {
      if (state.currentStep !== 1) return;
      const selectedItems = state.fileQueue.filter(item => item.selected);
      if (selectedItems.length < 1) return;

      const ready = await ensureOpenCvReady();
      if (!ready) {
        alert(i18n[currentLang].autoFrameCvLoadError || 'OpenCV failed to load. Auto frame is unavailable.');
        return;
      }

      const button = document.getElementById('autoFrameSelectedBtn');
      const previousText = button ? button.textContent : '';
      if (button) {
        button.disabled = true;
        button.textContent = i18n[currentLang].autoFrameAnalyzing || 'Analyzing frame borders...';
      }

      let successCount = 0;
      let rotateOnlyCount = 0;
      let failCount = 0;
      showBatchProgress(true);

      try {
        for (let i = 0; i < selectedItems.length; i++) {
          const item = selectedItems[i];
          updateBatchProgress(i + 1, selectedItems.length, item.file.name);

          try {
            const imageData = await loadFileToImageData(item.file);
            const result = await detectFrameAndRotation(imageData);
            if (!result) {
              failCount++;
              continue;
            }

            const existing = item.settings ? cloneSettings(item.settings) : createDefaultSettings(imageData);
            const lowBehavior = state.autoFrame.lowConfidenceBehavior || 'suggest';
            if (result.confidenceLevel === 'low') {
              if (lowBehavior === 'rotateOnly' && Math.abs(result.angle) > 0.05) {
                existing.rotationAngle = result.angle;
                existing.cropRegion = null;
                rotateOnlyCount++;
              } else {
                failCount++;
                continue;
              }
            } else {
              existing.rotationAngle = result.angle;
              existing.cropRegion = result.cropRegion ? { ...result.cropRegion } : null;
              successCount++;
            }

            existing.autoFrameMeta = {
              confidence: result.confidence,
              confidenceLevel: result.confidenceLevel || inferConfidenceLevel(result.confidence || 0),
              detectedFormat: result.detectedFormat || 'unknown',
              method: result.diagnostics && result.diagnostics.method ? result.diagnostics.method : 'unknown',
              rotateOnly: result.confidenceLevel === 'low' && (state.autoFrame.lowConfidenceBehavior || 'suggest') === 'rotateOnly',
              detectedAt: Date.now()
            };
            item.settings = existing;
            item.isDirty = false;
          } catch (err) {
            console.error('Auto frame batch item failed:', item.file.name, err);
            failCount++;
          }
        }
      } finally {
        showBatchProgress(false);
        if (button) {
          button.textContent = previousText || (i18n[currentLang].autoFrameSelected || 'Auto Frame Selected');
          updateAutoFrameButtons();
        }
      }

      const currentItem = getCurrentQueueItem();
      if (currentItem && currentItem.settings && currentItem.selected) {
        restoreSettings(currentItem.settings);
      }

      updateFileListUI();
      const template = i18n[currentLang].autoFrameBatchDoneExtended
        || i18n[currentLang].autoFrameBatchDone
        || 'Auto frame finished: {success} succeeded, {failed} failed.';
      alert(template
        .replace('{success}', String(successCount))
        .replace('{rotated}', String(rotateOnlyCount))
        .replace('{failed}', String(failCount)));
    }

    document.getElementById('autoFrameBtn').addEventListener('click', () => {
      applyAutoFrameToCurrent();
    });

    document.getElementById('autoFrameSelectedBtn').addEventListener('click', () => {
      applyAutoFrameToSelected();
    });

    // ===========================================
    // Cropping
    // ===========================================
    const cropOverlay = document.getElementById('cropOverlay');

    document.getElementById('cropBtn').addEventListener('click', () => {
      state.cropping = true;
      state.croppingActive = false;
      state.cropStart = null;
      activeCropPointerId = null;
      cropOverlay.style.display = 'block';
      cropOverlay.style.left = '0';
      cropOverlay.style.top = '0';
      cropOverlay.style.width = '0';
      cropOverlay.style.height = '0';
      canvasContainer.style.touchAction = 'none';

      document.getElementById('cropBtn').style.display = 'none';
      document.getElementById('applyCropBtn').style.display = 'inline-flex';
      document.getElementById('cancelCropBtn').style.display = 'inline-flex';
    });

    let activeCropPointerId = null;

    function startCropDrag(clientX, clientY) {
      if (!state.cropping) return;

      const rect = canvas.getBoundingClientRect();
      const scaleX = canvas.width / rect.width;
      const scaleY = canvas.height / rect.height;

      state.cropStart = {
        x: (clientX - rect.left) * scaleX,
        y: (clientY - rect.top) * scaleY
      };
      state.croppingActive = true;
    }

    function updateCropDrag(clientX, clientY) {
      if (!state.cropping || !state.croppingActive || !state.cropStart) return;

      const canvasRect = canvas.getBoundingClientRect();
      const containerRect = canvasContainer.getBoundingClientRect();

      const offsetX = canvasRect.left - containerRect.left;
      const offsetY = canvasRect.top - containerRect.top;

      const scaleX = canvas.width / canvasRect.width;
      const scaleY = canvas.height / canvasRect.height;

      const current = {
        x: (clientX - canvasRect.left) * scaleX,
        y: (clientY - canvasRect.top) * scaleY
      };

      const left = Math.min(state.cropStart.x, current.x);
      const top = Math.min(state.cropStart.y, current.y);
      const width = Math.abs(current.x - state.cropStart.x);
      const height = Math.abs(current.y - state.cropStart.y);

      const leftDisp = left / scaleX + offsetX;
      const topDisp = top / scaleY + offsetY;
      const widthDisp = width / scaleX;
      const heightDisp = height / scaleY;

      cropOverlay.style.left = leftDisp + 'px';
      cropOverlay.style.top = topDisp + 'px';
      cropOverlay.style.width = widthDisp + 'px';
      cropOverlay.style.height = heightDisp + 'px';
    }

    function finishCropDrag() {
      if (!state.cropping) return;
      state.croppingActive = false;
    }

    canvasContainer.addEventListener('mousedown', (e) => {
      startCropDrag(e.clientX, e.clientY);
    });

    canvasContainer.addEventListener('mousemove', (e) => {
      updateCropDrag(e.clientX, e.clientY);
    });

    canvasContainer.addEventListener('mouseup', finishCropDrag);
    canvasContainer.addEventListener('mouseleave', finishCropDrag);

    canvasContainer.addEventListener('pointerdown', (e) => {
      if (e.pointerType === 'mouse' || !state.cropping) return;
      e.preventDefault();
      activeCropPointerId = e.pointerId;
      canvasContainer.setPointerCapture(e.pointerId);
      startCropDrag(e.clientX, e.clientY);
    }, { passive: false });

    canvasContainer.addEventListener('pointermove', (e) => {
      if (e.pointerType === 'mouse') return;
      if (!state.cropping || activeCropPointerId !== e.pointerId) return;
      e.preventDefault();
      updateCropDrag(e.clientX, e.clientY);
    }, { passive: false });

    function finishCropPointer(e) {
      if (e.pointerType === 'mouse') return;
      if (activeCropPointerId !== e.pointerId) return;
      finishCropDrag();
      if (canvasContainer.hasPointerCapture(e.pointerId)) {
        canvasContainer.releasePointerCapture(e.pointerId);
      }
      activeCropPointerId = null;
    }

    canvasContainer.addEventListener('pointerup', finishCropPointer);
    canvasContainer.addEventListener('pointercancel', finishCropPointer);

    document.getElementById('cancelCropBtn').addEventListener('click', () => {
      state.cropping = false;
      state.croppingActive = false;
      state.cropStart = null;
      activeCropPointerId = null;
      cropOverlay.style.display = 'none';
      canvasContainer.style.touchAction = '';
      document.getElementById('cropBtn').style.display = 'inline-flex';
      document.getElementById('applyCropBtn').style.display = 'none';
      document.getElementById('cancelCropBtn').style.display = 'none';
    });

    document.getElementById('applyCropBtn').addEventListener('click', () => {
      const canvasRect = canvas.getBoundingClientRect();
      const containerRect = canvasContainer.getBoundingClientRect();

      // Calculate canvas offset within container (due to flexbox centering)
      const offsetX = canvasRect.left - containerRect.left;
      const offsetY = canvasRect.top - containerRect.top;

      const scaleX = canvas.width / canvasRect.width;
      const scaleY = canvas.height / canvasRect.height;

      // Subtract offset before converting to canvas coordinates
      const left = Math.floor((parseFloat(cropOverlay.style.left) - offsetX) * scaleX);
      const top = Math.floor((parseFloat(cropOverlay.style.top) - offsetY) * scaleY);
      const width = Math.floor(parseFloat(cropOverlay.style.width) * scaleX);
      const height = Math.floor(parseFloat(cropOverlay.style.height) * scaleY);

      if (width <= 0 || height <= 0) return;

      const baseCrop = state.cropRegion;
      const hasNestedCropBase = Boolean(state.croppedImageData && baseCrop);
      const absoluteCrop = {
        left: hasNestedCropBase ? baseCrop.left + left : left,
        top: hasNestedCropBase ? baseCrop.top + top : top,
        width,
        height
      };
      applyCropRegionToLoadedImage(absoluteCrop, { refreshDisplay: true });
      setStep2Mode(suggestStep2Mode());
      markCurrentFileDirty();

      state.cropping = false;
      state.croppingActive = false;
      state.cropStart = null;
      activeCropPointerId = null;
      cropOverlay.style.display = 'none';
      canvasContainer.style.touchAction = '';
      document.getElementById('cropBtn').style.display = 'inline-flex';
      document.getElementById('applyCropBtn').style.display = 'none';
      document.getElementById('cancelCropBtn').style.display = 'none';
    });

    // Convert button (skip to step 2)
    document.getElementById('convertBtn').addEventListener('click', () => {
      goToStep(2);
    });

    // Convert positive button (skip to step 2 with positive mode selected)
    document.getElementById('convertPositiveBtn').addEventListener('click', () => {
      state.filmType = 'positive';
      state.filmPreset = getDefaultPresetForType('positive');
      renderPresetOptions(state.filmPreset);
      setFilmTypeButtons(state.filmType);
      updateFilmModeUI();
      markCurrentFileDirty();
      goToStep(2);
    });

    // ===========================================
    // Reset & Start Over
    // ===========================================
    document.getElementById('resetBtn').addEventListener('click', () => {
      // Reset adjustments only
      state.exposure = 0;
      state.contrast = 0;
      state.highlights = 0;
      state.shadows = 0;
      state.temperature = 0;
      state.tint = 0;
      state.vibrance = 0;
      state.saturation = 0;
      state.cyan = 0;
      state.magenta = 0;
      state.yellow = 0;
      state.wbR = 1;
      state.wbG = 1;
      state.wbB = 1;

      updateSlidersFromState();
      initCurves(true);
      renderCurve();
      markCurrentFileDirty();
      updateFull();
    });

    document.getElementById('startOverBtn').addEventListener('click', () => {
      if (state.loadedBaseImageData || state.originalImageData) {
        state.originalImageData = state.loadedBaseImageData || state.originalImageData;
        state.rotationAngle = 0;
        state.cropRegion = null;
        state.croppedImageData = null;
        state.processedImageData = null;
        state.displayImageData = null;
        state.previewSourceImageData = null;
        state.histogramSourceImageData = null;
        state.webglSourceImageData = null;
        state.filmBaseSet = false;
        state.lastRenderQuality = 'full';
        if (webglState.gl) {
          webglState.sourceDirty = true;
          webglState.sourceSize = { w: 0, h: 0 };
        }
        if (fullUpdateTimer) {
          clearTimeout(fullUpdateTimer);
          fullUpdateTimer = null;
        }
        displayNegative(state.originalImageData);
        updateAutoFrameButtons();
        goToStep(1);
        document.getElementById('resetBtn').click();
        markCurrentFileDirty();
      }
    });

    document.getElementById('newImageBtn').addEventListener('click', () => {
      // Reset all state
      state.loadedBaseImageData = null;
      state.originalImageData = null;
      state.croppedImageData = null;
      state.cropRegion = null;
      state.rotationAngle = 0;
      state.processedImageData = null;
      state.displayImageData = null;
      state.previewSourceImageData = null;
      state.histogramSourceImageData = null;
      state.webglSourceImageData = null;
      state.filmBaseSet = false;
      state.currentStep = 1;
      state.lastRenderQuality = 'full';
      state.fileQueue = [];
      state.currentFileIndex = 0;
      state.batchSessionActive = false;
      state.batchMode = false;
      resetRollReferenceState();
      fullAdjustedBuffer = null;
      previewAdjustedBuffer = null;
      if (webglState.gl) {
        webglState.sourceDirty = true;
        webglState.sourceSize = { w: 0, h: 0 };
      }
      if (fullUpdateTimer) {
        clearTimeout(fullUpdateTimer);
        fullUpdateTimer = null;
      }

      // Reset UI
      canvas.style.display = 'none';
      glCanvas.style.display = 'none';
      document.getElementById('uploadPlaceholder').style.display = 'flex';
      document.getElementById('previewToolbar').style.display = 'none';
      document.getElementById('histogramContainer').style.display = 'none';
      document.getElementById('controlsPanel').style.display = 'none';
      document.getElementById('appFooter').style.display = 'none';

      // Reset adjustments
      document.getElementById('resetBtn').click();
      syncBatchUIState({ reason: 'newImageBtn' });

      // Trigger file selection
      fileInput.value = '';
      fileInput.click();
    });

    // ===========================================
    // Export
    // ===========================================
    const exportBtn = document.getElementById('exportBtn');
    const exportDropdownMenu = document.getElementById('exportDropdownMenu');

    // Toggle dropdown on main export button click
    exportBtn.addEventListener('click', (e) => {
      e.stopPropagation();
      exportDropdownMenu.classList.toggle('show');
    });

    // Prevent dropdown from closing when clicking inside it (for format settings)
    exportDropdownMenu.addEventListener('click', (e) => {
      // Only stop propagation if clicking on format settings, not export buttons
      if (e.target.closest('.export-format-section') || e.target.closest('.export-quality-section')) {
        e.stopPropagation();
      }
    });

    // Close dropdown when clicking elsewhere
    document.addEventListener('click', () => {
      exportDropdownMenu.classList.remove('show');
    });

    async function exportSingle() {
      const format = state.exportFormat;
      const ext = format === 'jpeg' ? '.jpg' : '.png';
      const mimeType = format === 'jpeg' ? 'image/jpeg' : 'image/png';
      const quality = format === 'jpeg' ? state.jpegQuality / 100 : undefined;

      const currentItem = getCurrentQueueItem();
      if (currentItem && state.currentStep >= 3 && state.processedImageData) {
        persistCurrentFileSettings({ silent: true });
        const adjusted = await processFileWithSettings(currentItem.file, currentItem.settings);
        const blob = await imageDataToBlob(adjusted, format, state.jpegQuality);
        const link = document.createElement('a');
        link.download = currentItem.file.name.replace(/\.[^.]+$/, '_converted' + ext);
        link.href = URL.createObjectURL(blob);
        link.click();
        URL.revokeObjectURL(link.href);
        return;
      }

      ensureFullRender();
      const dataURL = canvas.toDataURL(mimeType, quality);
      const link = document.createElement('a');
      link.download = 'converted_negative' + ext;
      link.href = dataURL;
      link.click();
    }

    document.getElementById('exportSingleBtn').addEventListener('click', async () => {
      await exportSingle();
    });

    document.getElementById('exportZipBtn').addEventListener('click', async () => {
      await exportBatchAsZip();
    });

    document.getElementById('exportAllBtn').addEventListener('click', async () => {
      await exportBatchIndividually();
    });

    // Format toggle buttons
    document.querySelectorAll('.format-btn').forEach(btn => {
      btn.addEventListener('click', () => {
        document.querySelectorAll('.format-btn').forEach(b => b.classList.remove('active'));
        btn.classList.add('active');
        state.exportFormat = btn.dataset.format;
        updateExportUI();
      });
    });

    // Quality slider
    document.getElementById('exportQualitySlider').addEventListener('input', (e) => {
      state.jpegQuality = parseInt(e.target.value);
      document.getElementById('exportQualityValue').textContent = state.jpegQuality + '%';
    });

    function updateExportUI() {
      const isJpeg = state.exportFormat === 'jpeg';
      const qualitySection = document.getElementById('exportQualitySection');
      qualitySection.classList.toggle('show', isJpeg);

      // Update export button text
      const exportBtn = document.getElementById('exportBtn');
      exportBtn.textContent = i18n[currentLang][isJpeg ? 'exportJpeg' : 'exportPng'];
      exportBtn.setAttribute('data-i18n', isJpeg ? 'exportJpeg' : 'exportPng');

      // Update export current button text
      const exportSingleBtn = document.getElementById('exportSingleBtn');
      exportSingleBtn.textContent = i18n[currentLang][isJpeg ? 'exportCurrentJpeg' : 'exportCurrent'];
      exportSingleBtn.setAttribute('data-i18n', isJpeg ? 'exportCurrentJpeg' : 'exportCurrent');
    }

    // ===========================================
    // Batch Processing
    // ===========================================
    function extractCurrentSettings() {
      return {
        cropRegion: state.cropRegion,
        rotationAngle: state.rotationAngle || 0,
        autoFrameMeta: state.autoFrame.lastDiagnostics ? { ...state.autoFrame.lastDiagnostics } : null,
        filmType: state.filmType,
        filmPreset: state.filmPreset,
        filmBase: { ...state.filmBase },
        exposure: state.exposure,
        contrast: state.contrast,
        highlights: state.highlights,
        shadows: state.shadows,
        temperature: state.temperature,
        tint: state.tint,
        vibrance: state.vibrance,
        saturation: state.saturation,
        cyan: state.cyan,
        magenta: state.magenta,
        yellow: state.yellow,
        wbR: state.wbR,
        wbG: state.wbG,
        wbB: state.wbB,
        curvePoints: {
          r: state.curvePoints.r.map(p => ({ ...p })),
          g: state.curvePoints.g.map(p => ({ ...p })),
          b: state.curvePoints.b.map(p => ({ ...p }))
        },
        curves: {
          r: new Uint8Array(state.curves.r),
          g: new Uint8Array(state.curves.g),
          b: new Uint8Array(state.curves.b)
        }
      };
    }

    function cloneSettings(settings) {
      if (!settings) return null;
      return {
        cropRegion: settings.cropRegion ? { ...settings.cropRegion } : null,
        rotationAngle: Number.isFinite(settings.rotationAngle) ? settings.rotationAngle : 0,
        autoFrameMeta: settings.autoFrameMeta ? { ...settings.autoFrameMeta } : null,
        filmType: settings.filmType,
        filmPreset: settings.filmPreset,
        filmBase: { ...settings.filmBase },
        exposure: settings.exposure,
        contrast: settings.contrast,
        highlights: settings.highlights,
        shadows: settings.shadows,
        temperature: settings.temperature,
        tint: settings.tint,
        vibrance: settings.vibrance,
        saturation: settings.saturation,
        cyan: settings.cyan,
        magenta: settings.magenta,
        yellow: settings.yellow,
        wbR: settings.wbR,
        wbG: settings.wbG,
        wbB: settings.wbB,
        curvePoints: {
          r: settings.curvePoints.r.map(p => ({ ...p })),
          g: settings.curvePoints.g.map(p => ({ ...p })),
          b: settings.curvePoints.b.map(p => ({ ...p }))
        },
        curves: {
          r: new Uint8Array(settings.curves.r),
          g: new Uint8Array(settings.curves.g),
          b: new Uint8Array(settings.curves.b)
        }
      };
    }

    function markCurrentFileDirty() {
      const item = getCurrentQueueItem();
      if (!item) return;
      if (item.isDirty) return;
      item.isDirty = true;
      if (state.batchSessionActive) {
        updateFileListUI();
      } else {
        updateCurrentFileLabel();
      }
    }

    function persistCurrentFileSettings(options = {}) {
      const { silent = false, force = false } = options;
      const item = getCurrentQueueItem();
      if (!item) return false;
      if (!state.originalImageData) return false;
      if (!force && !item.isDirty && item.settings) return false;

      item.settings = extractCurrentSettings();
      item.isDirty = false;
      updateFileListUI();

      if (!silent) {
        alert(i18n[currentLang].settingsSaved || 'Settings saved for current image');
      }
      return true;
    }

    function applySettingsToItems(baseSettings, items, options = {}) {
      const includeCrop = Boolean(options.includeCrop);
      const copied = cloneSettings(baseSettings);
      if (!copied) return 0;

      let count = 0;
      items.forEach(item => {
        const next = cloneSettings(copied);
        if (!includeCrop) {
          const existingCrop = item.settings && item.settings.cropRegion ? { ...item.settings.cropRegion } : null;
          const existingRotation = item.settings && Number.isFinite(item.settings.rotationAngle)
            ? item.settings.rotationAngle
            : 0;
          next.cropRegion = existingCrop;
          next.rotationAngle = existingRotation;
        }
        item.settings = next;
        item.isDirty = false;
        count++;
      });
      return count;
    }

    function applyCurrentSettingsToSelected() {
      if (state.currentStep < 3 || !state.processedImageData) {
        alert(i18n[currentLang].finishProcessing || 'Please complete the workflow (step 3) before saving settings.');
        return;
      }

      const selectedItems = state.fileQueue.filter(item => item.selected);
      if (selectedItems.length < 1) {
        alert(i18n[currentLang].noSelectedFiles || 'No selected images to apply settings.');
        return;
      }

      const baseSettings = extractCurrentSettings();
      applySettingsToItems(baseSettings, selectedItems, { includeCrop: false });

      updateFileListUI();
      const template = i18n[currentLang].appliedToSelected || 'Applied current settings to {count} image(s).';
      alert(template.replace('{count}', String(selectedItems.length)));
    }

    function setRollReferenceFromCurrent() {
      if (state.currentStep < 3 || !state.processedImageData) {
        alert(i18n[currentLang].finishProcessing || 'Please complete the workflow (step 3) before saving settings.');
        return;
      }
      const currentItem = getCurrentQueueItem();
      state.rollReference.enabled = true;
      state.rollReference.sourceFileId = currentItem ? currentItem.id : null;
      state.rollReference.settingsSnapshot = extractCurrentSettings();
      persistCurrentFileSettings({ silent: true, force: true });
      updateRollReferenceUI();
      updateStep2GuideCard({ skipFirstHint: true });
      alert(i18n[currentLang].rollReferenceSet || 'Current image has been set as the roll reference.');
    }

    function applyRollReferenceToSelected() {
      if (!hasRollReference()) {
        alert(i18n[currentLang].rollReferenceMissing || 'No roll reference is set.');
        return;
      }
      const selectedItems = state.fileQueue.filter(item => item.selected);
      if (selectedItems.length < 1) {
        alert(i18n[currentLang].noSelectedFiles || 'No selected images to apply settings.');
        return;
      }
      const applied = applySettingsToItems(
        state.rollReference.settingsSnapshot,
        selectedItems,
        { includeCrop: state.rollReference.applyCrop }
      );

      const currentItem = getCurrentQueueItem();
      if (currentItem && currentItem.selected && currentItem.settings) {
        restoreSettings(currentItem.settings);
        if (state.currentStep >= 3 && state.originalImageData) {
          processNegative();
        }
      }

      updateFileListUI();
      const template = i18n[currentLang].rollReferenceApplied || 'Applied roll reference to {count} image(s).';
      alert(template.replace('{count}', String(applied)));
    }

    function clearRollReference() {
      resetRollReferenceState();
      updateRollReferenceUI();
      updateStep2GuideCard({ skipFirstHint: true });
      alert(i18n[currentLang].rollReferenceCleared || 'Roll reference cleared.');
    }

    function getSettingsForExport(index, item) {
      if (!item) return null;
      if (index === state.currentFileIndex && (item.isDirty || !item.settings)) {
        persistCurrentFileSettings({ silent: true, force: true });
      }
      return item.settings || null;
    }

    function applyAdjustmentsWithSettings(imageData, settings) {
      const output = new ImageData(new Uint8ClampedArray(imageData.data.length), imageData.width, imageData.height);
      applyAdjustmentsToBuffer(imageData, settings, output, 'full');
      return output;
    }

    function sanitizeCropRegionForImage(cropRegion, imageData) {
      if (!cropRegion || !imageData) return null;
      const imageWidth = imageData.width | 0;
      const imageHeight = imageData.height | 0;
      if (imageWidth < 1 || imageHeight < 1) return null;

      const leftRaw = Number(cropRegion.left);
      const topRaw = Number(cropRegion.top);
      const widthRaw = Number(cropRegion.width);
      const heightRaw = Number(cropRegion.height);
      if (!Number.isFinite(leftRaw) || !Number.isFinite(topRaw) || !Number.isFinite(widthRaw) || !Number.isFinite(heightRaw)) {
        return null;
      }

      const left = clampBetween(Math.floor(leftRaw), 0, imageWidth - 1);
      const top = clampBetween(Math.floor(topRaw), 0, imageHeight - 1);
      const maxWidth = imageWidth - left;
      const maxHeight = imageHeight - top;
      if (maxWidth < 1 || maxHeight < 1) return null;

      const width = clampBetween(Math.floor(widthRaw), 1, maxWidth);
      const height = clampBetween(Math.floor(heightRaw), 1, maxHeight);
      if (width < 1 || height < 1) return null;

      return { left, top, width, height };
    }

    function applyCropRegionToLoadedImage(cropRegion, options = {}) {
      const { refreshDisplay = false } = options;
      if (!state.originalImageData) {
        state.cropRegion = null;
        state.croppedImageData = null;
        return false;
      }

      const sanitized = sanitizeCropRegionForImage(cropRegion, state.originalImageData);
      state.cropRegion = sanitized;
      state.croppedImageData = sanitized ? cropImageData(state.originalImageData, sanitized) : null;

      if (refreshDisplay) {
        displayNegative(state.croppedImageData || state.originalImageData);
      }
      return Boolean(sanitized);
    }

    function cropImageData(imageData, cropRegion) {
      const sanitized = sanitizeCropRegionForImage(cropRegion, imageData);
      if (!sanitized) return imageData;
      const { left, top, width, height } = sanitized;
      const croppedData = new ImageData(
        new Uint8ClampedArray(width * height * 4),
        width,
        height
      );

      for (let y = 0; y < height; y++) {
        for (let x = 0; x < width; x++) {
          const srcIdx = ((top + y) * imageData.width + left + x) * 4;
          const dstIdx = (y * width + x) * 4;
          croppedData.data[dstIdx] = imageData.data[srcIdx];
          croppedData.data[dstIdx + 1] = imageData.data[srcIdx + 1];
          croppedData.data[dstIdx + 2] = imageData.data[srcIdx + 2];
          croppedData.data[dstIdx + 3] = 255;
        }
      }

      return croppedData;
    }

    async function loadFileToImageData(file) {
      const arrayBuffer = await file.arrayBuffer();
      const fileName = file.name.toLowerCase();

      if (['.cr2', '.nef', '.arw', '.dng', '.raw', '.rw2', '.tif', '.tiff'].some(ext => fileName.endsWith(ext))) {
        return await loadRawFile(arrayBuffer, fileName);
      } else if (file.type === 'image/png') {
        return loadPngFile(arrayBuffer);
      } else {
        return await loadStandardImage(file);
      }
    }

    async function imageDataToBlob(imageData, format = null, quality = null) {
      format = format || state.exportFormat;
      quality = quality !== null ? quality : state.jpegQuality;

      const tempCanvas = document.createElement('canvas');
      tempCanvas.width = imageData.width;
      tempCanvas.height = imageData.height;
      const tempCtx = tempCanvas.getContext('2d');
      tempCtx.putImageData(imageData, 0, 0);

      return new Promise(resolve => {
        if (format === 'jpeg') {
          tempCanvas.toBlob(resolve, 'image/jpeg', quality / 100);
        } else {
          tempCanvas.toBlob(resolve, 'image/png');
        }
      });
    }

    function updateBatchProgress(current, total, fileName) {
      const percent = Math.round((current / total) * 100);
      document.getElementById('batchProgressFill').style.width = percent + '%';
      document.getElementById('batchProgressText').textContent = `${current} / ${total}`;
      document.getElementById('batchProgressCurrent').textContent = fileName || '';
    }

    function showBatchProgress(show) {
      document.getElementById('batchProgressOverlay').style.display = show ? 'flex' : 'none';
    }

    // Process a single file with given settings (streaming - no memory accumulation)
    async function processOneFile(file, settings) {
      const imageData = await loadFileToImageData(file);

      let workingData = imageData;
      const rotationAngle = Number.isFinite(settings.rotationAngle) ? settings.rotationAngle : 0;
      if (Math.abs(rotationAngle) > 0.001) {
        workingData = applyRotationToImageData(workingData, rotationAngle);
      }
      if (settings.cropRegion) {
        const cropRegion = sanitizeCropRegionForImage(settings.cropRegion, workingData);
        if (cropRegion) {
          workingData = cropImageData(workingData, cropRegion);
        }
      }

      let processed;
      const preset = getPresetOrFallback(settings.filmPreset, settings.filmType);
      const presetType = (preset && preset.type) ? preset.type : settings.filmType;
      if (settings.filmType === 'positive' || presetType === 'positive') {
        processed = convertPositiveFilm(workingData);
      } else if (settings.filmType === 'bw' || presetType === 'bw') {
        const bwParams = getBwPresetParams(preset);
        processed = convertBWNegative(workingData, {
          contrast: bwParams.contrast,
          gamma: bwParams.gamma
        });
      } else {
        processed = convertColorNegative(workingData, settings.filmBase);
      }

      return applyAdjustmentsWithSettings(processed, settings);
    }

    // Get selected files for batch processing
    function getSelectedFiles() {
      return state.fileQueue
        .map((item, index) => ({ item, index }))
        .filter(({ item }) => item.selected);
    }

    // Create default settings with auto-detected film base
    function createDefaultSettings(imageData) {
      const filmBase = autoDetectFilmBase(imageData);
      return {
        cropRegion: null,
        rotationAngle: 0,
        autoFrameMeta: null,
        filmType: 'color',
        filmPreset: 'generic_color',
        filmBase: filmBase,
        exposure: 0,
        contrast: 0,
        highlights: 0,
        shadows: 0,
        temperature: 0,
        tint: 0,
        vibrance: 0,
        saturation: 0,
        cyan: 0,
        magenta: 0,
        yellow: 0,
        wbR: 1,
        wbG: 1,
        wbB: 1,
        curvePoints: {
          r: [{ x: 0, y: 0 }, { x: 255, y: 255 }],
          g: [{ x: 0, y: 0 }, { x: 255, y: 255 }],
          b: [{ x: 0, y: 0 }, { x: 255, y: 255 }]
        },
        curves: {
          r: new Uint8Array(256).map((_, i) => i),
          g: new Uint8Array(256).map((_, i) => i),
          b: new Uint8Array(256).map((_, i) => i)
        }
      };
    }

    // Process a file with its own settings or auto-detect
    async function processFileWithSettings(file, savedSettings) {
      // Load the image
      const imageData = await loadFileToImageData(file);

      // Use saved settings or create default with auto-detect
      const settings = savedSettings || createDefaultSettings(imageData);

      // Apply crop if set
      let workingData = imageData;
      const rotationAngle = Number.isFinite(settings.rotationAngle) ? settings.rotationAngle : 0;
      if (Math.abs(rotationAngle) > 0.001) {
        workingData = applyRotationToImageData(workingData, rotationAngle);
      }
      if (settings.cropRegion) {
        const cropRegion = sanitizeCropRegionForImage(settings.cropRegion, workingData);
        if (cropRegion) {
          workingData = cropImageData(workingData, cropRegion);
        }
      }

      // Convert negative
      let processed;
      const preset = getPresetOrFallback(settings.filmPreset, settings.filmType);
      const presetType = (preset && preset.type) ? preset.type : settings.filmType;
      if (settings.filmType === 'positive' || presetType === 'positive') {
        processed = convertPositiveFilm(workingData);
      } else if (settings.filmType === 'bw' || presetType === 'bw') {
        const bwParams = getBwPresetParams(preset);
        processed = convertBWNegative(workingData, {
          contrast: bwParams.contrast,
          gamma: bwParams.gamma
        });
      } else {
        processed = convertColorNegative(workingData, settings.filmBase);
      }

      // Apply adjustments
      return applyAdjustmentsWithSettings(processed, settings);
    }

    // Streaming ZIP export: process → add to zip → free memory → next
    async function exportBatchAsZip() {
      const selectedFiles = getSelectedFiles();
      if (selectedFiles.length < 1) return;

      const zip = new JSZip();
      let processedCount = 0;

      showBatchProgress(true);

      try {
        for (const { item, index } of selectedFiles) {
          item.status = 'processing';
          updateFileListUI();
          processedCount++;
          updateBatchProgress(processedCount, selectedFiles.length, item.file.name);

          try {
            const settingsForFile = getSettingsForExport(index, item);
            const adjusted = await processFileWithSettings(item.file, settingsForFile);
            const blob = await imageDataToBlob(adjusted);

            const ext = state.exportFormat === 'jpeg' ? '.jpg' : '.png';
            const name = item.file.name.replace(/\.[^.]+$/, '_converted' + ext);
            zip.file(name, blob);
            item.status = 'done';
          } catch (err) {
            console.error(`Error processing ${item.file.name}:`, err);
            item.status = 'error';
            item.error = err.message;
          }

          updateFileListUI();
          await new Promise(r => setTimeout(r, 10));
        }

        updateBatchProgress(selectedFiles.length, selectedFiles.length, 'Creating ZIP...');
        const zipBlob = await zip.generateAsync({
          type: 'blob',
          compression: 'DEFLATE',
          compressionOptions: { level: 6 }
        });

        const link = document.createElement('a');
        link.download = 'converted_negatives.zip';
        link.href = URL.createObjectURL(zipBlob);
        link.click();
        URL.revokeObjectURL(link.href);
      } finally {
        showBatchProgress(false);
      }
    }

    // Streaming individual download: process → download → free → next
    async function exportBatchIndividually() {
      const selectedFiles = getSelectedFiles();
      if (selectedFiles.length < 1) return;

      let processedCount = 0;

      showBatchProgress(true);

      try {
        for (const { item, index } of selectedFiles) {
          item.status = 'processing';
          updateFileListUI();
          processedCount++;
          updateBatchProgress(processedCount, selectedFiles.length, item.file.name);

          try {
            const settingsForFile = getSettingsForExport(index, item);
            const adjusted = await processFileWithSettings(item.file, settingsForFile);
            const blob = await imageDataToBlob(adjusted);

            const ext = state.exportFormat === 'jpeg' ? '.jpg' : '.png';
            const name = item.file.name.replace(/\.[^.]+$/, '_converted' + ext);
            const link = document.createElement('a');
            link.download = name;
            link.href = URL.createObjectURL(blob);
            link.click();
            URL.revokeObjectURL(link.href);

            item.status = 'done';
          } catch (err) {
            console.error(`Error processing ${item.file.name}:`, err);
            item.status = 'error';
          }

          updateFileListUI();
          await new Promise(r => setTimeout(r, 200));
        }
      } finally {
        showBatchProgress(false);
      }
    }

    // ===========================================
    // File List UI
    // ===========================================
    function updateFileListUI() {
      const container = document.getElementById('fileListItems');
      const countEl = document.getElementById('fileListCount');
      const selectedCount = state.fileQueue.filter(f => f.selected).length;
      const settingsCount = state.fileQueue.filter(f => f.settings).length;

      // Show: selected/total (settings saved count)
      countEl.textContent = `${selectedCount}/${state.fileQueue.length} (${settingsCount} ${i18n[currentLang].configured || 'configured'})`;
      container.innerHTML = '';

      state.fileQueue.forEach((item, index) => {
        const el = document.createElement('div');
        el.className = 'file-list-item';
        if (index === state.currentFileIndex) el.classList.add('active');
        if (item.settings) el.classList.add('has-settings');
        if (item.isDirty) el.classList.add('is-dirty');

        const statusClass = item.status;
        const statusText = i18n[currentLang][item.status === 'processing' ? 'processingStatus' : item.status] || item.status;
        const settingsBadge = item.settings ? `<span class="file-list-settings-badge">${i18n[currentLang].customSettings || 'Custom'}</span>` : '';
        const unsavedBadge = item.isDirty ? `<span class="file-list-unsaved-badge">${i18n[currentLang].unsaved || 'Unsaved'}</span>` : '';

        el.innerHTML = `
          <input type="checkbox" class="file-list-checkbox" ${item.selected ? 'checked' : ''} data-index="${index}">
          <span class="file-list-name">${item.file.name}${settingsBadge}${unsavedBadge}</span>
          <span class="file-list-status ${statusClass}">${statusText}</span>
        `;

        // Checkbox toggle
        el.querySelector('.file-list-checkbox').addEventListener('click', (e) => {
          e.stopPropagation();
          state.fileQueue[index].selected = e.target.checked;
          updateFileListUI();
          updateExportButtons();
        });

        // Click on item to view/edit
        el.addEventListener('click', (e) => {
          if (e.target.classList.contains('file-list-checkbox')) return;
          switchToFile(index);
        });

        container.appendChild(el);
      });

      updateAutoFrameButtons();
      syncBatchUIState({ reason: 'updateFileListUI' });
    }

    async function switchToFile(index) {
      if (index < 0 || index >= state.fileQueue.length) return;
      if (index === state.currentFileIndex) return;

      persistCurrentFileSettings({ silent: true });
      state.currentFileIndex = index;
      const fileItem = state.fileQueue[index];

      // Load the file
      await loadFile(fileItem.file);

      // If this file has saved settings, restore them
      if (fileItem.settings) {
        restoreSettings(fileItem.settings);
        fileItem.isDirty = false;
      }

      updateFileListUI();
    }

    // Save current settings to the current file's queue entry
    function saveCurrentFileSettings() {
      persistCurrentFileSettings({ silent: false, force: true });
    }

    // Restore settings from a saved settings object
    function restoreSettings(settings) {
      if (!settings) return;

      state.rotationAngle = Number.isFinite(settings.rotationAngle) ? normalizeAngleDegrees(settings.rotationAngle) : 0;

      if (state.loadedBaseImageData) {
        state.originalImageData = state.loadedBaseImageData;
      }

      if (state.originalImageData && Math.abs(state.rotationAngle) > 0.001) {
        state.originalImageData = applyRotationToImageData(state.originalImageData, state.rotationAngle);
      }

      // Restore crop region after rotation
      applyCropRegionToLoadedImage(settings.cropRegion, { refreshDisplay: true });
      if (state.originalImageData) {
        settings.rotationAngle = state.rotationAngle;
        settings.cropRegion = state.cropRegion ? { ...state.cropRegion } : null;
      }

      if (settings.autoFrameMeta) {
        state.autoFrame.lastDiagnostics = {
          confidence: settings.autoFrameMeta.confidence,
          detectedFormat: settings.autoFrameMeta.detectedFormat || 'unknown',
          method: settings.autoFrameMeta.method || 'unknown',
          confidenceLevel: settings.autoFrameMeta.confidenceLevel || inferConfidenceLevel(settings.autoFrameMeta.confidence || 0),
          rotateOnly: Boolean(settings.autoFrameMeta.rotateOnly)
        };
      } else {
        state.autoFrame.lastDiagnostics = null;
      }
      updateAutoFrameDiagnosticsUI();

      // Restore film settings
      state.filmType = sanitizePresetType(settings.filmType || 'color');
      state.filmPreset = resolvePresetId(settings.filmPreset) || getDefaultPresetForType(state.filmType);
      state.filmBase = { ...settings.filmBase };
      state.filmBaseSet = true;

      // Restore adjustments
      state.exposure = settings.exposure;
      state.contrast = settings.contrast;
      state.highlights = settings.highlights;
      state.shadows = settings.shadows;
      state.temperature = settings.temperature;
      state.tint = settings.tint;
      state.vibrance = settings.vibrance;
      state.saturation = settings.saturation;
      state.cyan = settings.cyan;
      state.magenta = settings.magenta;
      state.yellow = settings.yellow;
      state.wbR = settings.wbR;
      state.wbG = settings.wbG;
      state.wbB = settings.wbB;

      // Restore curves
      state.curvePoints = {
        r: settings.curvePoints.r.map(p => ({ ...p })),
        g: settings.curvePoints.g.map(p => ({ ...p })),
        b: settings.curvePoints.b.map(p => ({ ...p }))
      };
      ['r', 'g', 'b'].forEach(ch => updateCurveFromPoints(ch));

      // Update UI to reflect restored settings
      updateSlidersFromState();
      renderCurve();
    }

    // Update all slider UI elements from state
    function updateSlidersFromState() {
      syncAllSlidersFromState();

      // Update film type buttons
      const preset = getPresetOrFallback(state.filmPreset, state.filmType);
      state.filmPreset = preset ? preset.id : getDefaultPresetForType(state.filmType);
      if (preset && state.filmType !== preset.type) {
        state.filmType = preset.type;
      }
      renderPresetOptions(state.filmPreset);
      setFilmTypeButtons(state.filmType);
      updateFilmModeUI();
    }

    function updateExportButtons() {
      // Enable batch export when there are selected files
      const selectedCount = state.fileQueue.filter(f => f.selected).length;
      document.getElementById('exportZipBtn').disabled = selectedCount < 1;
      document.getElementById('exportAllBtn').disabled = selectedCount < 1;
      updateAutoFrameButtons();
    }

    function normalizeAutoFrame120Options() {
      const map = state.autoFrame.allowed120Formats || {};
      const anyEnabled = AUTO_FRAME_DEFAULT_120_FORMATS.some(fmt => map[fmt] !== false);
      if (!anyEnabled) {
        map['6x6'] = true;
      }
      AUTO_FRAME_DEFAULT_120_FORMATS.forEach(fmt => {
        if (typeof map[fmt] !== 'boolean') {
          map[fmt] = true;
        }
      });
      state.autoFrame.allowed120Formats = map;
    }

    function updateAutoFrameConfigUI() {
      const enabledInput = document.getElementById('autoFrameEnabledInput');
      const autoApplyInput = document.getElementById('autoFrameAutoApplyInput');
      const formatSelect = document.getElementById('autoFrameFormatSelect');
      const lowSelect = document.getElementById('autoFrameLowConfidenceSelect');
      const option645 = document.getElementById('autoFrame120_645');
      const option66 = document.getElementById('autoFrame120_66');
      const option67 = document.getElementById('autoFrame120_67');
      const option69 = document.getElementById('autoFrame120_69');
      const optionsContainer = document.getElementById('autoFrame120Options');
      if (!enabledInput || !autoApplyInput || !formatSelect || !lowSelect) return;

      normalizeAutoFrame120Options();
      enabledInput.checked = Boolean(state.autoFrame.enabled);
      autoApplyInput.checked = Boolean(state.autoFrame.autoApplyHighConfidence);
      formatSelect.value = state.autoFrame.formatPreference || 'auto';
      lowSelect.value = state.autoFrame.lowConfidenceBehavior || 'suggest';
      if (option645) option645.checked = state.autoFrame.allowed120Formats['6x4.5'] !== false;
      if (option66) option66.checked = state.autoFrame.allowed120Formats['6x6'] !== false;
      if (option67) option67.checked = state.autoFrame.allowed120Formats['6x7'] !== false;
      if (option69) option69.checked = state.autoFrame.allowed120Formats['6x9'] !== false;
      if (optionsContainer) {
        optionsContainer.style.opacity = formatSelect.value === '135' ? '0.55' : '1';
      }
    }

    function formatDetectedFormatLabel(formatKey) {
      if (!formatKey || formatKey === 'unknown') return 'unknown';
      if (formatKey === '135') return '135';
      if (String(formatKey).startsWith('120-')) return formatKey.replace('120-', '120 ');
      return String(formatKey);
    }

    function updateAutoFrameDiagnosticsUI() {
      const box = document.getElementById('autoFrameDiagnosticsBox');
      if (!box) return;
      const diag = state.autoFrame.lastDiagnostics;
      if (!diag) {
        box.style.display = 'none';
        box.textContent = '';
        return;
      }
      const template = i18n[currentLang].autoFrameDiagnostics
        || 'Detection: method {method} | format {format} | confidence {confidence}';
      box.textContent = template
        .replace('{method}', String(diag.method || 'unknown'))
        .replace('{format}', formatDetectedFormatLabel(diag.detectedFormat))
        .replace('{confidence}', Number.isFinite(diag.confidence) ? diag.confidence.toFixed(2) : '0.00');
      box.style.display = 'block';
    }

    function applyAutoFrameConfigFromUI() {
      const enabledInput = document.getElementById('autoFrameEnabledInput');
      const autoApplyInput = document.getElementById('autoFrameAutoApplyInput');
      const formatSelect = document.getElementById('autoFrameFormatSelect');
      const lowSelect = document.getElementById('autoFrameLowConfidenceSelect');
      const option645 = document.getElementById('autoFrame120_645');
      const option66 = document.getElementById('autoFrame120_66');
      const option67 = document.getElementById('autoFrame120_67');
      const option69 = document.getElementById('autoFrame120_69');

      if (enabledInput) state.autoFrame.enabled = Boolean(enabledInput.checked);
      if (autoApplyInput) state.autoFrame.autoApplyHighConfidence = Boolean(autoApplyInput.checked);
      if (formatSelect) state.autoFrame.formatPreference = formatSelect.value === '135' || formatSelect.value === '120' ? formatSelect.value : 'auto';
      if (lowSelect) {
        const value = lowSelect.value;
        state.autoFrame.lowConfidenceBehavior = (value === 'rotateOnly' || value === 'ignore') ? value : 'suggest';
      }

      state.autoFrame.allowed120Formats = {
        '6x4.5': option645 ? Boolean(option645.checked) : true,
        '6x6': option66 ? Boolean(option66.checked) : true,
        '6x7': option67 ? Boolean(option67.checked) : true,
        '6x9': option69 ? Boolean(option69.checked) : true
      };
      normalizeAutoFrame120Options();
      updateAutoFrameConfigUI();
      updateAutoFrameButtons();
    }

    function updateAutoFrameButtons() {
      const currentBtn = document.getElementById('autoFrameBtn');
      const selectedBtn = document.getElementById('autoFrameSelectedBtn');
      if (!currentBtn || !selectedBtn) return;

      const stepReady = state.currentStep === 1;
      currentBtn.disabled = !state.originalImageData || !state.autoFrame.enabled || !stepReady;
      const selectedCount = state.fileQueue.filter(f => f.selected).length;
      selectedBtn.disabled = !state.autoFrame.enabled || selectedCount < 1 || !stepReady;
      updateAutoFrameConfigUI();
    }

    function showBatchUI(show, reason) {
      setFileListVisible(show, reason || 'showBatchUI');
      updateBatchStep3GuideVisibility();
    }

    // Select all button
    document.getElementById('selectAllBtn').addEventListener('click', () => {
      state.fileQueue.forEach(item => item.selected = true);
      updateFileListUI();
      updateExportButtons();
    });

    // Select none button
    document.getElementById('selectNoneBtn').addEventListener('click', () => {
      state.fileQueue.forEach(item => item.selected = false);
      updateFileListUI();
      updateExportButtons();
    });

    // Save settings button
    document.getElementById('saveSettingsBtn').addEventListener('click', () => {
      if (state.currentStep < 3) {
        alert(i18n[currentLang].finishProcessing || 'Please complete the workflow (step 3) before saving settings.');
        return;
      }
      saveCurrentFileSettings();
    });

    document.getElementById('applyToSelectedBtn').addEventListener('click', () => {
      applyCurrentSettingsToSelected();
    });

    document.getElementById('setRollReferenceBtn').addEventListener('click', () => {
      setRollReferenceFromCurrent();
    });

    document.getElementById('applyRollReferenceBtn').addEventListener('click', () => {
      applyRollReferenceToSelected();
    });

    document.getElementById('clearRollReferenceBtn').addEventListener('click', () => {
      clearRollReference();
    });

    document.getElementById('lockRollReference').addEventListener('change', (e) => {
      state.rollReference.applyLock = Boolean(e.target.checked);
      updateRollReferenceUI();
    });

    document.getElementById('applyCropWithReference').addEventListener('change', (e) => {
      state.rollReference.applyCrop = Boolean(e.target.checked);
      updateRollReferenceUI();
    });

    ['autoFrameEnabledInput', 'autoFrameAutoApplyInput', 'autoFrameFormatSelect', 'autoFrameLowConfidenceSelect',
      'autoFrame120_645', 'autoFrame120_66', 'autoFrame120_67', 'autoFrame120_69']
      .forEach(id => {
        const el = document.getElementById(id);
        if (!el) return;
        el.addEventListener('change', applyAutoFrameConfigFromUI);
      });
    updateAutoFrameConfigUI();

    function openAddFilesPicker() {
      const input = document.createElement('input');
      input.type = 'file';
      input.multiple = true;
      input.accept = '.cr2,.nef,.arw,.dng,.raw,.rw2,.tif,.tiff,image/*';
      input.onchange = (e) => {
        if (e.target.files.length > 0) {
          addFilesToQueue(Array.from(e.target.files));
          if (!state.originalImageData && state.fileQueue.length > 0) {
            loadFile(state.fileQueue[state.currentFileIndex].file);
          }
        }
      };
      input.click();
    }

    // Add more files button
    document.getElementById('addMoreFilesBtn').addEventListener('click', () => {
      openAddFilesPicker();
    });

    // Add files button in toolbar (single image + batch)
    document.getElementById('addFilesToolbarBtn').addEventListener('click', () => {
      openAddFilesPicker();
    });

    // Clear file list button
    document.getElementById('clearFileListBtn').addEventListener('click', () => {
      state.fileQueue = [];
      state.currentFileIndex = 0;
      state.batchSessionActive = false;
      resetRollReferenceState();
      updateFileListUI();
      syncBatchUIState({ reason: 'clearFileListBtn' });
      updateExportButtons();
    });

    function createQueueItemId(file) {
      return `${file.name}::${file.size}::${file.lastModified || 0}`;
    }

    function addFilesToQueue(files) {
      // Filter for supported image files
      const supportedExtensions = ['.cr2', '.nef', '.arw', '.dng', '.raw', '.rw2', '.tif', '.tiff', '.png', '.jpg', '.jpeg', '.gif', '.webp', '.bmp'];
      const validFiles = files.filter(file => {
        const ext = '.' + file.name.split('.').pop().toLowerCase();
        return supportedExtensions.includes(ext) || file.type.startsWith('image/');
      });

      if (validFiles.length === 0) return;

      // Add files to queue
      for (const file of validFiles) {
        // Avoid duplicates
        const id = createQueueItemId(file);
        if (!state.fileQueue.some(f => f.id === id)) {
          const newItem = {
            id,
            file: file,
            selected: true,  // Selected by default
            status: 'pending',
            error: null,
            settings: null,  // null = use auto-detect, otherwise saved settings
            isDirty: false
          };
          if (hasRollReference() && state.rollReference.applyLock) {
            const applied = applySettingsToItems(
              state.rollReference.settingsSnapshot,
              [newItem],
              { includeCrop: state.rollReference.applyCrop }
            );
            if (applied > 0) {
              newItem.status = 'pending';
            }
          }
          state.fileQueue.push(newItem);
        }
      }

      if (state.fileQueue.length > 1) {
        state.batchSessionActive = true;
      }
      syncBatchUIState({ reason: 'addFilesToQueue' });

      updateFileListUI();
      updateExportButtons();
    }

    // ===========================================
    // File Input Handling
    // ===========================================
    const fileInput = document.getElementById('fileInput');
    const folderInput = document.getElementById('folderInput');
    const uploadBtn = document.getElementById('uploadBtn');
    const uploadFolderBtn = document.getElementById('uploadFolderBtn');

    uploadBtn.addEventListener('click', () => fileInput.click());
    uploadFolderBtn.addEventListener('click', () => folderInput.click());

    fileInput.addEventListener('change', (e) => {
      const files = Array.from(e.target.files);
      if (files.length === 0) return;

      // Reset state for new batch
      state.fileQueue = [];
      state.currentFileIndex = 0;
      state.cropRegion = null;
      state.rotationAngle = 0;
      state.loadedBaseImageData = null;
      state.batchSessionActive = false;
      resetRollReferenceState();
      syncBatchUIState({ reason: 'fileInput_change_reset' });

      addFilesToQueue(files);

      // Load the first file
      if (state.fileQueue.length > 0) {
        loadFile(state.fileQueue[0].file);
      }
    });

    folderInput.addEventListener('change', (e) => {
      const files = Array.from(e.target.files);
      if (files.length === 0) return;

      // Reset state for new batch
      state.fileQueue = [];
      state.currentFileIndex = 0;
      state.cropRegion = null;
      state.rotationAngle = 0;
      state.loadedBaseImageData = null;
      state.batchSessionActive = false;
      resetRollReferenceState();
      syncBatchUIState({ reason: 'folderInput_change_reset' });

      addFilesToQueue(files);

      // Load the first file
      if (state.fileQueue.length > 0) {
        loadFile(state.fileQueue[0].file);
      }
    });

    canvasContainer.addEventListener('dragover', (e) => {
      e.preventDefault();
      canvasContainer.style.borderColor = 'var(--accent)';
    });

    canvasContainer.addEventListener('dragleave', () => {
      canvasContainer.style.borderColor = '';
    });

    canvasContainer.addEventListener('drop', (e) => {
      e.preventDefault();
      canvasContainer.style.borderColor = '';

      const files = Array.from(e.dataTransfer.files);
      if (files.length === 0) return;

      // Reset state for new batch
      state.fileQueue = [];
      state.currentFileIndex = 0;
      state.cropRegion = null;
      state.rotationAngle = 0;
      state.loadedBaseImageData = null;
      state.batchSessionActive = false;
      resetRollReferenceState();
      syncBatchUIState({ reason: 'drop_reset' });

      addFilesToQueue(files);

      // Load the first file
      if (state.fileQueue.length > 0) {
        loadFile(state.fileQueue[0].file);
      }
    });

    // ===========================================
    // Window Resize
    // ===========================================
    window.addEventListener('resize', () => {
      if (canvas.width > 0 && canvas.height > 0) {
        adjustCanvasDisplay(canvas.width, canvas.height);
      }
    });
  </script>
</body>
</html>
