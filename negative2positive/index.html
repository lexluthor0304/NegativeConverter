<!DOCTYPE html>
<html lang="zh">

<head>
  <meta charset="UTF-8">
  <title>Film Negative → Positive (旋转+实时剪裁+白平衡+温度/色调)</title>
  <style>
    /* 整体页面样式：黑色背景与霓虹风格字体 */
    body {
      font-family: "Courier New", Courier, monospace;
      background: #000;
      color: #0ff;
      padding: 20px;
      margin: 0;
      text-align: center;
    }

    h2 {
      text-align: center;
      text-shadow: 0 0 10px #ff00ff, 0 0 20px #ff00ff;
      margin: 20px auto;
    }

    /* 容器尺寸与 canvas 显示尺寸同步 */
    #canvasContainer {
      position: relative;
      display: inline-block;
      border: 2px solid #0ff;
      box-shadow: 0 0 20px #0ff;
      margin-bottom: 20px;
    }

    canvas {
      border: 1px solid #0ff;
      background: #111;
    }

    /* 剪裁覆盖层：霓虹粉色虚线边框与半透明粉色背景 */
    #cropOverlay {
      border: 2px dashed #ff00ff;
      position: absolute;
      pointer-events: none;
      display: none;
      background: rgba(255, 0, 255, 0.2);
      z-index: 100;
    }

    .control {
      margin-top: 10px;
      text-align: center;
    }

    /* 固定滑块长度 */
    input[type="range"] {
      width: 300px;
    }

    input[type="number"] {
      width: 60px;
      margin-left: 10px;
      background: #222;
      border: 1px solid #0ff;
      color: #0ff;
    }

    /* 文件上传、按钮样式 */
    input[type="file"],
    button {
      background: #222;
      border: 1px solid #0ff;
      color: #0ff;
      padding: 5px 10px;
      cursor: pointer;
      transition: all 0.3s ease;
    }

    input[type="file"]:hover,
    button:hover {
      background: #0ff;
      color: #000;
    }

    /* 滑块样式定制 */
    input[type="range"] {
      -webkit-appearance: none;
      background: #222;
    }

    input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      width: 15px;
      height: 15px;
      background: #ff00ff;
      border: 1px solid #0ff;
      cursor: pointer;
      box-shadow: 0 0 5px #ff00ff;
    }
  </style>
  <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
  <!-- 引入 UPNG.js 以支持 PNG 的 16 bit 解析 -->
  <script src="https://cdn.jsdelivr.net/npm/pako/dist/pako.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/upng-js@2.1.0/UPNG.min.js"></script>
  <script>
    const i18n = {
      zh: {
        title: "Film Negative → Positive (旋转+实时剪裁+白平衡+温度/色调)",
        guideTitle: "📘 使用方法（快速上手）",
        steps: [
          "上传底片图像：点击“选择文件”，上传扫描好的底片图像。",
          "旋转图像：使用滑块或输入角度，纠正扫描角度后点击“应用旋转”。",
          "剪裁图像：点击“开始剪裁”，用鼠标拖出区域后点击“应用剪裁”。",
          "白平衡调整：点击图中应为灰色的地方（如墙面、衣服阴影等）。",
          "调整色温/色调：拖动滑块或输入数值微调颜色。",
          "下载结果：点击“下载校正图像”保存处理后的图片。"
        ]
      },
      en: {
        title: "Film Negative → Positive (Rotate + Crop + White Balance + Temp/Tint)",
        guideTitle: "📘 Quick Start Guide",
        steps: [
          "Upload a negative: Click 'Choose File' and upload your scanned film.",
          "Rotate: Use the slider or input box to correct rotation, then click 'Apply Rotation'.",
          "Crop: Click 'Start Crop', drag a region, then click 'Apply Crop'.",
          "White Balance: Click a gray area in the image (e.g., wall, clothing shadow, etc).",
          "Adjust Temp/Tint: Use sliders or input numbers to fine-tune colors.",
          "Download: Click 'Download Corrected Image' to save the result."
        ]
      },
      ja: {
        title: "フィルムネガ → ポジ (回転＋トリミング＋ホワイトバランス＋色温度/色合い)",
        guideTitle: "📘 使い方（簡単）",
        steps: [
          "ネガ画像をアップロード：「ファイルを選択」でスキャン済みネガを選択。",
          "回転：スライダーや数値入力で回転を調整、「回転を適用」をクリック。",
          "トリミング：「トリミング開始」で範囲を選び、「適用」をクリック。",
          "ホワイトバランス：画像内のグレー部分（壁・服の影など）をクリック。",
          "色温度・色合い調整：スライダーまたは数値入力で微調整。",
          "ダウンロード：「補正画像をダウンロード」で保存。"
        ]
      }
    };
  </script>
</head>

<body>
  <script>
    document.addEventListener("DOMContentLoaded", () => {
      const lang = navigator.language.startsWith("ja") ? "ja"
        : navigator.language.startsWith("en") ? "en"
          : "zh";
      const text = i18n[lang];
      document.getElementById("title").textContent = text.title;
      document.getElementById("guideTitle").textContent = text.guideTitle;
      const list = document.getElementById("steps");
      list.innerHTML = "";
      text.steps.forEach(step => {
        const li = document.createElement("li");
        const parts = step.split("：");
        if (parts.length === 2) {
          li.innerHTML = `<b>${parts[0]}：</b>${parts[1]}`;
        } else {
          li.textContent = step;
        }
        list.appendChild(li);
      });
    });
  </script>
  <h2 id="title">Film Negative → Positive (旋转+实时剪裁+白平衡+温度/色调)</h2>
  <div style="padding:16px; margin-bottom:20px;">
    <h3 id="guideTitle">📘 使用方法（快速上手）</h3>
    <ol id="steps" style="padding-left: 20px; line-height: 1.6;">
      <li><b>上传底片图像：</b>点击“选择文件”，上传扫描好的底片图像。</li>
      <li><b>旋转图像：</b>使用滑块或输入角度，纠正扫描角度后点击“应用旋转”。</li>
      <li><b>剪裁图像：</b>点击“开始剪裁”，用鼠标拖出区域后点击“应用剪裁”。</li>
      <li><b>白平衡调整：</b>点击图中应为灰色的地方（如墙面、衣服阴影等）。</li>
      <li><b>调整色温/色调：</b>拖动滑块或输入数值微调颜色。</li>
      <li><b>下载结果：</b>点击“下载校正图像”保存处理后的图片。</li>
    </ol>
  </div>
  <input type="file" id="upload" accept="image/*" class="control"><br>
  <!-- 旋转控件 -->
  <div id="rotateControls" class="control" style="display:none;">
    <label>旋转: <span id="rotateVal">0</span>°</label>
    <input type="range" id="rotate" min="-180" max="180" step="1" value="0">
    <input type="number" id="rotateInput" min="-180" max="180" step="1" value="0">
    <button id="applyRotate">应用旋转</button>
  </div>
  <!-- 剪裁控件 -->
  <div id="cropControls" class="control" style="display:none;">
    <button id="startCrop">开始剪裁</button>
    <button id="applyCrop" style="display:none;">应用剪裁</button>
    <button id="cancelCrop" style="display:none;">取消剪裁</button>
  </div>
  <!-- canvas 容器 -->
  <div id="canvasContainer">
    <canvas id="canvas"></canvas>
    <div id="cropOverlay"></div>
  </div>
  <!-- 温度/色调调整 -->
  <div id="adjustControls" class="control" style="display:none;">
    <label>温度: <span id="tempVal">0</span></label>
    <input type="range" id="temp" min="-100" max="100" step="1" value="0">
    <input type="number" id="tempInput" min="-100" max="100" step="1" value="0">
    <br>
    <label>色调: <span id="tintVal">0</span></label>
    <input type="range" id="tint" min="-100" max="100" step="1" value="0">
    <input type="number" id="tintInput" min="-100" max="100" step="1" value="0">
  </div>
  <div class="control" style="display:none;" id="downloadDiv">
    <button id="download">下载校正图像</button>
  </div>

  <script>
    $(function () {
      let canvas = $("#canvas")[0],
          ctx = canvas.getContext("2d");
      // 离屏 canvas 保存变换基底（旋转、剪裁后）
      let transformCanvas = document.createElement("canvas"),
          transformCtx = transformCanvas.getContext("2d");
      let invertedImageData = null; // 当前反转后的图像数据（内部像素）
      let basePixels = null;        // 白平衡校正+归一化后的数据（用于温度/色调调整）
      let cropping = false;         // 剪裁模式标志
      let cropStart = null;         // 剪裁起点（内部坐标）
      let croppingActive = false;   // 是否正在拖拽选择

      // 根据内部像素尺寸调整 canvas 与容器的 CSS 显示尺寸
      function adjustCanvasDisplay(w, h) {
        const maxWidth = window.innerWidth - 40,
              maxHeight = window.innerHeight - 200;
        let scale = Math.min(maxWidth / w, maxHeight / h, 1);
        $("#canvas").css({ width: w * scale, height: h * scale });
        $("#canvasContainer").css({ width: w * scale, height: h * scale });
      }

      // 当选择文件时，根据是否为 PNG，分支处理
      $("#upload").on("change", function (e) {
        let file = e.target.files[0];
        if (!file) return;

        // 如果是 PNG，使用 UPNG.js 解析（支持 16 bit）
        if (file.type === "image/png") {
          let reader = new FileReader();
          reader.onload = function (event) {
            // ---------- UPNG.js 解析部分 ----------
            const arrayBuffer = event.target.result;
            const decoded = UPNG.decode(arrayBuffer);
            const width = decoded.width;
            const height = decoded.height;
            const ctype = decoded.ctype; // 通道类型 (RGB, RGBA, 灰度 等)
            const depth = decoded.depth;
            const data = decoded.data;

            const channelCount = (ctype & 2 ? 3 : 1) + (ctype & 4 ? 1 : 0);
            const pixelCount = width * height;

            // 统一转换到 16bit (0..65535) 范围
            let raw16 = new Uint16Array(pixelCount * channelCount);
            if (depth <= 8) {
              for (let i = 0; i < raw16.length; i++) {
                raw16[i] = data[i] * 257; // 扩展 0..255 => 0..65535
              }
            } else {
              for (let i = 0; i < raw16.length; i++) {
                let hi = data[2 * i],
                    lo = data[2 * i + 1];
                raw16[i] = (hi << 8) | lo;
              }
            }

            // 负片 -> 正片
            for (let i = 0; i < raw16.length; i++) {
              raw16[i] = 65535 - raw16[i];
            }

            // 最终显示时需降到 8 bit
            let final8 = new Uint8ClampedArray(pixelCount * 4);
            for (let i = 0; i < pixelCount; i++) {
              let idx16 = i * channelCount;
              let idx8 = i * 4;
              // R
              final8[idx8] = raw16[idx16] >>> 8;
              // G / B
              if (channelCount >= 3) {
                final8[idx8 + 1] = raw16[idx16 + 1] >>> 8;
                final8[idx8 + 2] = raw16[idx16 + 2] >>> 8;
              } else {
                // 若灰度，则让 G/B 与 R 一致
                final8[idx8 + 1] = final8[idx8];
                final8[idx8 + 2] = final8[idx8];
              }
              // A
              if (channelCount === 4) {
                final8[idx8 + 3] = raw16[idx16 + 3] >>> 8;
              } else {
                final8[idx8 + 3] = 255;
              }
            }

            // 写到 canvas
            canvas.width = width;
            canvas.height = height;
            adjustCanvasDisplay(width, height);

            let imageData = ctx.createImageData(width, height);
            imageData.data.set(final8);
            ctx.putImageData(imageData, 0, 0);

            // 同步到 transformCanvas
            invertedImageData = imageData;
            transformCanvas.width = width;
            transformCanvas.height = height;
            transformCtx.putImageData(invertedImageData, 0, 0);

            // 显示旋转、剪裁控件
            $("#rotateControls, #cropControls").show();
          };
          reader.readAsArrayBuffer(file);

        } else {
          // 若不是 PNG，则直接使用浏览器原生方式 (Image 对象 + drawImage)
          let reader = new FileReader();
          reader.onload = function (event) {
            let img = new Image();
            img.onload = function () {
              canvas.width = img.width;
              canvas.height = img.height;
              adjustCanvasDisplay(img.width, img.height);

              // 原生绘制
              ctx.drawImage(img, 0, 0);
              let rawData = ctx.getImageData(0, 0, canvas.width, canvas.height);
              let invertedImageData = ctx.createImageData(rawData);
              for (let i = 0; i < rawData.data.length; i += 4) {
                invertedImageData.data[i]     = 255 - rawData.data[i];
                invertedImageData.data[i + 1] = 255 - rawData.data[i + 1];
                invertedImageData.data[i + 2] = 255 - rawData.data[i + 2];
                invertedImageData.data[i + 3] = 255;
              }
              ctx.putImageData(invertedImageData, 0, 0);

              // 同步到 transformCanvas
              transformCanvas.width = canvas.width;
              transformCanvas.height = canvas.height;
              transformCtx.putImageData(invertedImageData, 0, 0);

              // 显示旋转、剪裁控件
              $("#rotateControls, #cropControls").show();
            };
            img.src = event.target.result;
          };
          reader.readAsDataURL(file);
        }
      });

      // 旋转预览（不更新离屏基底）
      function previewRotation(angleRad) {
        let w = transformCanvas.width, h = transformCanvas.height;
        let cos = Math.abs(Math.cos(angleRad)), sin = Math.abs(Math.sin(angleRad));
        let newW = Math.ceil(w * cos + h * sin),
            newH = Math.ceil(w * sin + h * cos);
        let offCanvas = document.createElement("canvas");
        offCanvas.width = newW;
        offCanvas.height = newH;
        let offCtx = offCanvas.getContext("2d");
        offCtx.translate(newW / 2, newH / 2);
        offCtx.rotate(angleRad);
        offCtx.drawImage(transformCanvas, -w / 2, -h / 2);

        canvas.width = newW;
        canvas.height = newH;
        adjustCanvasDisplay(newW, newH);
        ctx.clearRect(0, 0, newW, newH);
        ctx.drawImage(offCanvas, 0, 0);
        invertedImageData = ctx.getImageData(0, 0, newW, newH);
      }

      // 旋转滑块与数字输入框双向绑定
      $("#rotate").on("input", function () {
        $("#rotateVal").text($(this).val());
        $("#rotateInput").val($(this).val());
        let angle = parseFloat($(this).val()) * Math.PI / 180;
        previewRotation(angle);
      });
      $("#rotateInput").on("input", function () {
        let val = $(this).val();
        $("#rotateVal").text(val);
        $("#rotate").val(val);
        let angle = parseFloat(val) * Math.PI / 180;
        previewRotation(angle);
      });

      // 应用旋转：更新 transformCanvas
      $("#applyRotate").on("click", function () {
        let newData = ctx.getImageData(0, 0, canvas.width, canvas.height);
        invertedImageData = newData;
        transformCanvas.width = canvas.width;
        transformCanvas.height = canvas.height;
        transformCtx.putImageData(newData, 0, 0);
        // 重置旋转控件
        $("#rotate").val(0);
        $("#rotateInput").val(0);
        $("#rotateVal").text("0");
      });

      // 剪裁逻辑
      $("#startCrop").on("click", function () {
        cropping = true;
        $("#cropOverlay").css({
          display: "block",
          left: 0,
          top: 0,
          width: 0,
          height: 0
        });
        $("#applyCrop, #cancelCrop").show();
        $(this).hide();
      });

      $("#canvasContainer").on("mousedown", function (e) {
        if (!cropping) return;
        croppingActive = true;
        let containerOffset = $("#canvasContainer").offset();
        let dispWidth = $("#canvas").width(),
            dispHeight = $("#canvas").height();
        let scaleX = canvas.width / dispWidth,
            scaleY = canvas.height / dispHeight;
        cropStart = {
          x: (e.pageX - containerOffset.left) * scaleX,
          y: (e.pageY - containerOffset.top) * scaleY
        };
      });

      $("#canvasContainer").on("mousemove", function (e) {
        if (!cropping || !croppingActive) return;
        let containerOffset = $("#canvasContainer").offset();
        let dispWidth = $("#canvas").width(),
            dispHeight = $("#canvas").height();
        let scaleX = canvas.width / dispWidth,
            scaleY = canvas.height / dispHeight;
        let current = {
          x: (e.pageX - containerOffset.left) * scaleX,
          y: (e.pageY - containerOffset.top) * scaleY
        };
        let leftInternal = Math.min(cropStart.x, current.x),
            topInternal = Math.min(cropStart.y, current.y),
            widthInternal = Math.abs(current.x - cropStart.x),
            heightInternal = Math.abs(current.y - cropStart.y);

        // 转换为显示坐标
        let leftDisp = leftInternal / scaleX,
            topDisp = topInternal / scaleY,
            widthDisp = widthInternal / scaleX,
            heightDisp = heightInternal / scaleY;

        $("#cropOverlay").css({
          left: leftDisp,
          top: topDisp,
          width: widthDisp,
          height: heightDisp
        });
      });

      $("#canvasContainer").on("mouseup", function () {
        if (!cropping) return;
        croppingActive = false;
      });

      $("#cancelCrop").on("click", function () {
        cropping = false;
        $("#cropOverlay").hide();
        $("#applyCrop, #cancelCrop").hide();
        $("#startCrop").show();
      });

      $("#applyCrop").on("click", function () {
        let dispWidth = $("#canvas").width(),
            dispHeight = $("#canvas").height();
        let scaleX = canvas.width / dispWidth,
            scaleY = canvas.height / dispHeight;
        let overlay = $("#cropOverlay");
        let leftDisp = parseFloat(overlay.css("left")),
            topDisp = parseFloat(overlay.css("top")),
            widthDisp = parseFloat(overlay.css("width")),
            heightDisp = parseFloat(overlay.css("height"));
        let leftInternal = leftDisp * scaleX,
            topInternal = topDisp * scaleY,
            widthInternal = widthDisp * scaleX,
            heightInternal = heightDisp * scaleY;

        if (widthInternal <= 0 || heightInternal <= 0) return;

        let croppedData = transformCtx.getImageData(leftInternal, topInternal, widthInternal, heightInternal);
        canvas.width = widthInternal;
        canvas.height = heightInternal;
        adjustCanvasDisplay(widthInternal, heightInternal);
        ctx.putImageData(croppedData, 0, 0);
        invertedImageData = ctx.getImageData(0, 0, widthInternal, heightInternal);

        transformCanvas.width = widthInternal;
        transformCanvas.height = heightInternal;
        transformCtx.putImageData(invertedImageData, 0, 0);

        cropping = false;
        $("#cropOverlay").hide();
        $("#applyCrop, #cancelCrop").hide();
        $("#startCrop").show();
      });

      // 点击画布，做白平衡校正（剪裁模式下不响应）
      $("#canvas").on("click", function (e) {
        if (cropping) return;
        let offset = $("#canvas").offset();
        let scaleX = canvas.width / $("#canvas").width(),
            scaleY = canvas.height / $("#canvas").height();
        let x = Math.floor((e.pageX - offset.left) * scaleX),
            y = Math.floor((e.pageY - offset.top) * scaleY);
        let idx = (y * canvas.width + x) * 4;
        let d = invertedImageData.data;
        let clickedR = d[idx], clickedG = d[idx + 1], clickedB = d[idx + 2];
        let gray = (clickedR + clickedG + clickedB) / 3;
        let sR = clickedR ? (gray / clickedR) : 1;
        let sG = clickedG ? (gray / clickedG) : 1;
        let sB = clickedB ? (gray / clickedB) : 1;
        let total = canvas.width * canvas.height;
        let corrected = new Float32Array(d.length);
        for (let i = 0; i < total; i++) {
          corrected[i * 4] = d[i * 4] * sR;
          corrected[i * 4 + 1] = d[i * 4 + 1] * sG;
          corrected[i * 4 + 2] = d[i * 4 + 2] * sB;
          corrected[i * 4 + 3] = 255;
        }
        let rMin = Infinity, rMax = -Infinity,
            gMin = Infinity, gMax = -Infinity,
            bMin = Infinity, bMax = -Infinity;
        for (let i = 0; i < total; i++) {
          let r = corrected[i * 4],
              g = corrected[i * 4 + 1],
              b = corrected[i * 4 + 2];
          rMin = Math.min(rMin, r); rMax = Math.max(rMax, r);
          gMin = Math.min(gMin, g); gMax = Math.max(gMax, g);
          bMin = Math.min(bMin, b); bMax = Math.max(bMax, b);
        }
        let finalImg = ctx.createImageData(canvas.width, canvas.height);
        for (let i = 0; i < total; i++) {
          finalImg.data[i * 4] =
            ((corrected[i * 4] - rMin) / (rMax - rMin)) * 255;
          finalImg.data[i * 4 + 1] =
            ((corrected[i * 4 + 1] - gMin) / (gMax - gMin)) * 255;
          finalImg.data[i * 4 + 2] =
            ((corrected[i * 4 + 2] - bMin) / (bMax - bMin)) * 255;
          finalImg.data[i * 4 + 3] = 255;
        }
        ctx.putImageData(finalImg, 0, 0);

        basePixels = new Float32Array(finalImg.data);
        transformCanvas.width = canvas.width;
        transformCanvas.height = canvas.height;
        transformCtx.putImageData(finalImg, 0, 0);

        $("#adjustControls, #downloadDiv").show();
      });

      // 温度 / 色调调整：滑块与数字输入框双向绑定
      function updateAdjust() {
        let temp = parseInt($("#temp").val()),
            tint = parseInt($("#tint").val());
        $("#tempVal").text(temp);
        $("#tintVal").text(tint);
        $("#tempInput").val(temp);
        $("#tintInput").val(tint);

        let total = canvas.width * canvas.height;
        let adjusted = ctx.createImageData(canvas.width, canvas.height);
        let tempFactor = temp / 100,
            tintFactor = tint / 100;
        for (let i = 0; i < total; i++) {
          let idx = i * 4;
          let r = basePixels[idx],
              g = basePixels[idx + 1],
              b = basePixels[idx + 2];
          let newR = r * (1 + tempFactor);
          let newG = g * (1 + tintFactor);
          let newB = b * (1 - tempFactor);
          adjusted.data[idx]     = Math.min(255, Math.max(0, newR));
          adjusted.data[idx + 1] = Math.min(255, Math.max(0, newG));
          adjusted.data[idx + 2] = Math.min(255, Math.max(0, newB));
          adjusted.data[idx + 3] = 255;
        }
        ctx.putImageData(adjusted, 0, 0);
      }

      $("#temp").on("input", function () {
        $("#tempVal").text($(this).val());
        $("#tempInput").val($(this).val());
        updateAdjust();
      });
      $("#tempInput").on("input", function () {
        $("#tempVal").text($(this).val());
        $("#temp").val($(this).val());
        updateAdjust();
      });
      $("#tint").on("input", function () {
        $("#tintVal").text($(this).val());
        $("#tintInput").val($(this).val());
        updateAdjust();
      });
      $("#tintInput").on("input", function () {
        $("#tintVal").text($(this).val());
        $("#tint").val($(this).val());
        updateAdjust();
      });

      // 下载
      $("#download").on("click", function () {
        let link = document.createElement("a");
        link.download = "corrected_film.png";
        link.href = canvas.toDataURL("image/png");
        link.click();
      });
    });
  </script>
</body>
</html>